From 29c760d8bb6338679abaf8a30549341bd181cc51 Mon Sep 17 00:00:00 2001
From: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
Date: Thu, 18 Jul 2013 15:11:25 +0300
Subject: [PATCH 3/4] egl: Update to Wayland 1.2 server API

Since Wayland 1.2, struct wl_buffer and a few functions are deprecated.

References to wl_buffer are replaced with wl_resource and some getter
functions and calls to deprecated functions are replaced with the proper
new API. The latter changes are related to resource versioning.

Signed-off-by: Ander Conselvan de Oliveira <ander.conselvan.de.oliveira@intel.com>
---
 docs/specs/WL_bind_wayland_display.spec            |  8 ++-
 include/EGL/eglmesaext.h                           |  6 +-
 src/egl/drivers/dri2/egl_dri2.c                    | 28 +++++----
 src/egl/drivers/dri2/egl_dri2.h                    |  1 -
 src/egl/main/eglapi.c                              |  2 +-
 src/egl/main/eglapi.h                              |  2 +-
 src/egl/wayland/wayland-drm/wayland-drm.c          | 66 +++++++++++++---------
 src/egl/wayland/wayland-drm/wayland-drm.h          | 13 +++--
 .../state_trackers/egl/common/egl_g3d_api.c        |  2 +-
 .../state_trackers/egl/common/egl_g3d_image.c      |  4 +-
 .../egl/common/native_wayland_bufmgr.h             |  6 +-
 .../egl/common/native_wayland_drm_bufmgr.c         | 25 +++++---
 src/gbm/backends/dri/gbm_dri.c                     |  5 +-
 13 files changed, 99 insertions(+), 69 deletions(-)

diff --git a/docs/specs/WL_bind_wayland_display.spec b/docs/specs/WL_bind_wayland_display.spec
index 02bd6ea..8f0083c 100644
--- a/docs/specs/WL_bind_wayland_display.spec
+++ b/docs/specs/WL_bind_wayland_display.spec
@@ -17,7 +17,7 @@ Status
 
 Version
 
-    Version 1, March 1, 2011
+    Version 5, July 16, 2013
 
 Number
 
@@ -57,7 +57,7 @@ New Procedures and Functions
                                          struct wl_display *display);
 
     EGLBoolean eglQueryWaylandBufferWL(EGLDisplay dpy,
-                                       struct wl_buffer *buffer,
+                                       struct wl_resource *buffer,
                                        EGLint attribute, EGLint *value);
 
 New Tokens
@@ -173,3 +173,7 @@ Revision History
         Use EGL_TEXTURE_FORMAT, EGL_TEXTURE_RGB, and EGL_TEXTURE_RGBA,
         and just define the new YUV texture formats.  Add support for
         EGL_WIDTH and EGL_HEIGHT in the query attributes (Kristian HÃ¸gsberg)
+    Version 5, July 16, 2013
+        Change eglQueryWaylandBufferWL to take a resource pointer to the
+        buffer instead of a pointer to a struct wl_buffer, as the latter has
+        been deprecated. (Ander Conselvan de Oliveira)
diff --git a/include/EGL/eglmesaext.h b/include/EGL/eglmesaext.h
index d476d18..e0eae28 100644
--- a/include/EGL/eglmesaext.h
+++ b/include/EGL/eglmesaext.h
@@ -120,15 +120,15 @@ typedef EGLDisplay (EGLAPIENTRYP PFNEGLGETDRMDISPLAYMESA) (int fd);
 #define EGL_TEXTURE_Y_XUXV_WL           0x31D9
 
 struct wl_display;
-struct wl_buffer;
+struct wl_resource;
 #ifdef EGL_EGLEXT_PROTOTYPES
 EGLAPI EGLBoolean EGLAPIENTRY eglBindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display);
 EGLAPI EGLBoolean EGLAPIENTRY eglUnbindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display);
-EGLAPI EGLBoolean EGLAPIENTRY eglQueryWaylandBufferWL(EGLDisplay dpy, struct wl_buffer *buffer, EGLint attribute, EGLint *value);
+EGLAPI EGLBoolean EGLAPIENTRY eglQueryWaylandBufferWL(EGLDisplay dpy, struct wl_resource *buffer, EGLint attribute, EGLint *value);
 #endif
 typedef EGLBoolean (EGLAPIENTRYP PFNEGLBINDWAYLANDDISPLAYWL) (EGLDisplay dpy, struct wl_display *display);
 typedef EGLBoolean (EGLAPIENTRYP PFNEGLUNBINDWAYLANDDISPLAYWL) (EGLDisplay dpy, struct wl_display *display);
-typedef EGLBoolean (EGLAPIENTRYP PFNEGLQUERYWAYLANDBUFFERWL) (EGLDisplay dpy, struct wl_buffer *buffer, EGLint attribute, EGLint *value);
+typedef EGLBoolean (EGLAPIENTRYP PFNEGLQUERYWAYLANDBUFFERWL) (EGLDisplay dpy, struct wl_resource *buffer, EGLint attribute, EGLint *value);
 
 #endif
 
diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 52fcb3f..bdbb450 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -41,6 +41,10 @@
 
 #include "egl_dri2.h"
 
+#ifdef HAVE_WAYLAND_PLATFORM
+#include "wayland-drm.h"
+#endif
+
 const __DRIuseInvalidateExtension use_invalidate = {
    { __DRI_USE_INVALIDATE, 1 }
 };
@@ -1195,7 +1199,7 @@ dri2_create_image_wayland_wl_buffer(_EGL
 				    EGLClientBuffer _buffer,
 				    const EGLint *attr_list)
 {
-   struct wl_drm_buffer *buffer = (struct wl_drm_buffer *) _buffer;
+   struct wl_drm_buffer *buffer;
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    const struct wl_drm_components_descriptor *f;
    __DRIimage *dri_image;
@@ -1203,7 +1207,8 @@ dri2_create_image_wayland_wl_buffer(_EGL
    EGLint err;
    int32_t plane;
 
-   if (!wayland_buffer_is_drm(dri2_dpy->wl_server_drm, &buffer->buffer))
+   buffer = wayland_drm_buffer_get(dri2_dpy->wl_server_drm, (struct wl_resource *) _buffer);
+   if (!buffer)
        return NULL;
 
    err = _eglParseImageAttribList(&attrs, disp, attr_list);
@@ -1508,8 +1513,8 @@ dri2_wl_reference_buffer(void *user_data
 
    if (fd == -1)
       img = dri2_dpy->image->createImageFromNames(dri2_dpy->dri_screen,
-                                                  buffer->buffer.width,
-                                                  buffer->buffer.height,
+                                                  buffer->width,
+                                                  buffer->height,
                                                   buffer->format,
                                                   (int*)&name, 1,
                                                   buffer->stride,
@@ -1517,8 +1522,8 @@ dri2_wl_reference_buffer(void *user_data
                                                   NULL);
    else
       img = dri2_dpy->image->createImageFromFds(dri2_dpy->dri_screen,
-                                                buffer->buffer.width,
-                                                buffer->buffer.height,
+                                                buffer->width,
+                                                buffer->height,
                                                 buffer->format,
                                                 &fd, 1,
                                                 buffer->stride,
@@ -1612,14 +1617,15 @@ dri2_unbind_wayland_display_wl(_EGLDrive
 
 static EGLBoolean
 dri2_query_wayland_buffer_wl(_EGLDriver *drv, _EGLDisplay *disp,
-                             struct wl_buffer *_buffer,
+                             struct wl_resource *buffer_resource,
                              EGLint attribute, EGLint *value)
 {
-   struct wl_drm_buffer *buffer = (struct wl_drm_buffer *) _buffer;
+   struct wl_drm_buffer *buffer;
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    const struct wl_drm_components_descriptor *format;
 
-   if (!wayland_buffer_is_drm(dri2_dpy->wl_server_drm, &buffer->buffer))
+   buffer = wayland_drm_buffer_get(dri2_dpy->wl_server_drm, buffer_resource);
+   if (!buffer)
       return EGL_FALSE;
 
    format = buffer->driver_format;
@@ -1628,10 +1634,10 @@ dri2_query_wayland_buffer_wl(_EGLDriver
       *value = format->components;
       return EGL_TRUE;
    case EGL_WIDTH:
-      *value = buffer->buffer.width;
+      *value = buffer->width;
       return EGL_TRUE;
    case EGL_HEIGHT:
-      *value = buffer->buffer.height;
+      *value = buffer->height;
       return EGL_TRUE;
    }
 
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index 6dfdf94..fba5f81 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -37,7 +37,6 @@
 
 #ifdef HAVE_WAYLAND_PLATFORM
 #include <wayland-client.h>
-#include "wayland-drm.h"
 #include "wayland-egl-priv.h"
 #endif
 
diff --git a/src/egl/main/eglapi.c b/src/egl/main/eglapi.c
index 4a9831b..a788295 100644
--- a/src/egl/main/eglapi.c
+++ b/src/egl/main/eglapi.c
@@ -1571,7 +1571,7 @@ eglUnbindWaylandDisplayWL(EGLDisplay dpy, struct wl_display *display)
 }
 
 EGLBoolean EGLAPIENTRY
-eglQueryWaylandBufferWL(EGLDisplay dpy,struct wl_buffer *buffer,
+eglQueryWaylandBufferWL(EGLDisplay dpy, struct wl_resource *buffer,
                         EGLint attribute, EGLint *value)
 {
    _EGLDisplay *disp = _eglLockDisplay(dpy);
diff --git a/src/egl/main/eglapi.h b/src/egl/main/eglapi.h
index ee382d0..4a4f976 100644
--- a/src/egl/main/eglapi.h
+++ b/src/egl/main/eglapi.h
@@ -123,7 +123,7 @@ typedef EGLBoolean (*ExportDRMImageMESA_t)(_EGLDriver *drv, _EGLDisplay *disp, _
 struct wl_display;
 typedef EGLBoolean (*BindWaylandDisplayWL_t)(_EGLDriver *drv, _EGLDisplay *disp, struct wl_display *display);
 typedef EGLBoolean (*UnbindWaylandDisplayWL_t)(_EGLDriver *drv, _EGLDisplay *disp, struct wl_display *display);
-typedef EGLBoolean (*QueryWaylandBufferWL_t)(_EGLDriver *drv, _EGLDisplay *displ, struct wl_buffer *buffer, EGLint attribute, EGLint *value);
+typedef EGLBoolean (*QueryWaylandBufferWL_t)(_EGLDriver *drv, _EGLDisplay *displ, struct wl_resource *buffer, EGLint attribute, EGLint *value);
 #endif
 
 typedef EGLBoolean (*PostSubBufferNV_t)(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surface, EGLint x, EGLint y, EGLint width, EGLint height);
diff --git a/src/egl/wayland/wayland-drm/wayland-drm.c b/src/egl/wayland/wayland-drm/wayland-drm.c
index 7e2073a..d317c5e 100644
--- a/src/egl/wayland/wayland-drm/wayland-drm.c
+++ b/src/egl/wayland/wayland-drm/wayland-drm.c
@@ -37,6 +37,8 @@
 #include "wayland-drm.h"
 #include "wayland-drm-server-protocol.h"
 
+#define MIN(x,y) (((x)<(y))?(x):(y))
+
 struct wl_drm {
 	struct wl_display *display;
 
@@ -83,8 +85,8 @@ create_buffer(struct wl_client *client,
 	}
 
 	buffer->drm = drm;
-	buffer->buffer.width = width;
-	buffer->buffer.height = height;
+	buffer->width = width;
+	buffer->height = height;
 	buffer->format = format;
 	buffer->offset[0] = offset0;
 	buffer->stride[0] = stride0;
@@ -101,16 +103,17 @@ create_buffer(struct wl_client *client,
 		return;
 	}
 
-	buffer->buffer.resource.object.id = id;
-	buffer->buffer.resource.object.interface = &wl_buffer_interface;
-	buffer->buffer.resource.object.implementation =
-		(void (**)(void)) &drm->buffer_interface;
-	buffer->buffer.resource.data = buffer;
-
-	buffer->buffer.resource.destroy = destroy_buffer;
-	buffer->buffer.resource.client = resource->client;
+	buffer->resource =
+		wl_resource_create(client, &wl_buffer_interface, 1, id);
+	if (!buffer->resource) {
+		wl_resource_post_no_memory(resource);
+		free(buffer);
+		return;
+	}
 
-	wl_client_add_resource(resource->client, &buffer->buffer.resource);
+	wl_resource_set_implementation(buffer->resource,
+				       (void (**)(void)) &drm->buffer_interface,
+				       buffer, destroy_buffer);
 }
 
 static void
@@ -205,8 +208,15 @@ bind_drm(struct wl_client *client, void
 	struct wl_resource *resource;
         uint32_t capabilities;
 
-	resource = wl_client_add_object(client, &wl_drm_interface,
-					&drm_interface, id, data);
+	resource = wl_resource_create(client, &wl_drm_interface,
+				      MIN(version, 2), id);
+	if (!resource) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+
+	wl_resource_set_implementation(resource, &drm_interface, data, NULL);
+
 	wl_resource_post_event(resource, WL_DRM_DEVICE, drm->device_name);
 	wl_resource_post_event(resource, WL_DRM_FORMAT,
 			       WL_DRM_FORMAT_ARGB8888);
@@ -229,6 +239,21 @@ bind_drm(struct wl_client *client, void
            wl_resource_post_event(resource, WL_DRM_CAPABILITIES, capabilities);
 }
 
+struct wl_drm_buffer *
+wayland_drm_buffer_get(struct wl_drm *drm, struct wl_resource *resource)
+{
+	struct wl_drm_buffer *buffer;
+
+	if (resource == NULL)
+		return NULL;
+
+	if (wl_resource_instance_of(resource, &wl_buffer_interface,
+				    &drm->buffer_interface))
+		return wl_resource_get_user_data(resource);
+	else
+		return NULL;
+}
+
 struct wl_drm *
 wayland_drm_init(struct wl_display *display, char *device_name,
                  struct wayland_drm_callbacks *callbacks, void *user_data,
@@ -245,7 +270,7 @@ wayland_drm_init(struct wl_display *disp
         drm->flags = flags;
         drm->buffer_interface.destroy = buffer_destroy;
 
-	wl_display_add_global(display, &wl_drm_interface, drm, bind_drm);
+	wl_global_create(display, &wl_drm_interface, 2, drm, bind_drm);
 
 	return drm;
 }
@@ -260,25 +285,14 @@ wayland_drm_uninit(struct wl_drm *drm)
 	free(drm);
 }
 
-int
-wayland_buffer_is_drm(struct wl_drm *drm, struct wl_buffer *buffer)
-{
-	return buffer->resource.object.implementation == 
-		(void (**)(void)) &drm->buffer_interface;
-}
-
 uint32_t
-wayland_drm_buffer_get_format(struct wl_buffer *buffer_base)
+wayland_drm_buffer_get_format(struct wl_drm_buffer *buffer)
 {
-	struct wl_drm_buffer *buffer = (struct wl_drm_buffer *) buffer_base;
-
 	return buffer->format;
 }
 
 void *
-wayland_drm_buffer_get_buffer(struct wl_buffer *buffer_base)
+wayland_drm_buffer_get_buffer(struct wl_drm_buffer *buffer)
 {
-	struct wl_drm_buffer *buffer = (struct wl_drm_buffer *) buffer_base;
-
 	return buffer->driver_buffer;
 }
diff --git a/src/egl/wayland/wayland-drm/wayland-drm.h b/src/egl/wayland/wayland-drm/wayland-drm.h
index 335073a..ca04882 100644
--- a/src/egl/wayland/wayland-drm/wayland-drm.h
+++ b/src/egl/wayland/wayland-drm/wayland-drm.h
@@ -70,8 +70,9 @@ enum wl_drm_format {
 struct wl_drm;
 
 struct wl_drm_buffer {
-	struct wl_buffer buffer;
+	struct wl_resource *resource;
 	struct wl_drm *drm;
+	int32_t width, height;
 	uint32_t format;
         const void *driver_format;
         int32_t offset[3];
@@ -90,6 +91,9 @@ struct wayland_drm_callbacks {
 
 enum { WAYLAND_DRM_PRIME = 0x01 };
 
+struct wl_drm_buffer *
+wayland_drm_buffer_get(struct wl_drm *drm, struct wl_resource *resource);
+
 struct wl_drm *
 wayland_drm_init(struct wl_display *display, char *device_name,
 		 struct wayland_drm_callbacks *callbacks, void *user_data,
@@ -98,13 +102,10 @@ wayland_drm_init(struct wl_display *disp
 void
 wayland_drm_uninit(struct wl_drm *drm);
 
-int
-wayland_buffer_is_drm(struct wl_drm *drm, struct wl_buffer *buffer);
-
 uint32_t
-wayland_drm_buffer_get_format(struct wl_buffer *buffer_base);
+wayland_drm_buffer_get_format(struct wl_drm_buffer *buffer);
 
 void *
-wayland_drm_buffer_get_buffer(struct wl_buffer *buffer);
+wayland_drm_buffer_get_buffer(struct wl_drm_buffer *buffer);
 
 #endif
diff --git a/src/gallium/state_trackers/egl/common/egl_g3d_api.c b/src/gallium/state_trackers/egl/common/egl_g3d_api.c
index 59187a9..46a3245 100644
--- a/src/gallium/state_trackers/egl/common/egl_g3d_api.c
+++ b/src/gallium/state_trackers/egl/common/egl_g3d_api.c
@@ -874,7 +874,7 @@ egl_g3d_unbind_wayland_display_wl(_EGLDriver *drv, _EGLDisplay *dpy,
 
 static EGLBoolean
 egl_g3d_query_wayland_buffer_wl(_EGLDriver *drv, _EGLDisplay *dpy,
-                                struct wl_buffer *buffer,
+                                struct wl_resource *buffer,
                                 EGLint attribute, EGLint *value)
 {
    struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
diff --git a/src/gallium/state_trackers/egl/common/egl_g3d_image.c b/src/gallium/state_trackers/egl/common/egl_g3d_image.c
index aa1980b..c459dc3 100644
--- a/src/gallium/state_trackers/egl/common/egl_g3d_image.c
+++ b/src/gallium/state_trackers/egl/common/egl_g3d_image.c
@@ -183,7 +183,7 @@ egl_g3d_reference_drm_buffer(_EGLDisplay *dpy, EGLint name,
 #ifdef EGL_WL_bind_wayland_display
 
 static struct pipe_resource *
-egl_g3d_reference_wl_buffer(_EGLDisplay *dpy, struct wl_buffer *buffer,
+egl_g3d_reference_wl_buffer(_EGLDisplay *dpy, struct wl_resource *buffer,
                             _EGLImage *img, const EGLint *attribs)
 {
    struct egl_g3d_display *gdpy = egl_g3d_display(dpy);
@@ -253,7 +253,7 @@ egl_g3d_create_image(_EGLDriver *drv, _EGLDisplay *dpy, _EGLContext *ctx,
 #ifdef EGL_WL_bind_wayland_display
    case EGL_WAYLAND_BUFFER_WL:
       ptex = egl_g3d_reference_wl_buffer(dpy,
-            (struct wl_buffer *) buffer, &gimg->base, attribs);
+            (struct wl_resource *) buffer, &gimg->base, attribs);
       break;
 #endif
 #ifdef EGL_ANDROID_image_native_buffer
diff --git a/src/gallium/state_trackers/egl/common/native_wayland_bufmgr.h b/src/gallium/state_trackers/egl/common/native_wayland_bufmgr.h
index dd27828..eb324bf 100644
--- a/src/gallium/state_trackers/egl/common/native_wayland_bufmgr.h
+++ b/src/gallium/state_trackers/egl/common/native_wayland_bufmgr.h
@@ -27,7 +27,7 @@
 
 struct native_display;
 struct wl_display;
-struct wl_buffer;
+struct wl_resource;
 struct pipe_resource;
 
 struct native_display_wayland_bufmgr {
@@ -38,11 +38,11 @@ struct native_display_wayland_bufmgr {
                              struct wl_display *wl_dpy);
 
    struct pipe_resource *(*buffer_get_resource)(struct native_display *ndpy,
-                                                struct wl_buffer *buffer);
+                                                struct wl_resource *buffer);
                              
 
    boolean (*query_buffer)(struct native_display *ndpy,
-                           struct wl_buffer *buffer,
+                           struct wl_resource *buffer,
                            int attribute, int *value);
 };
 
diff --git a/src/gallium/state_trackers/egl/common/native_wayland_drm_bufmgr.c b/src/gallium/state_trackers/egl/common/native_wayland_drm_bufmgr.c
index 1603a3a..9b69cb9 100644
--- a/src/gallium/state_trackers/egl/common/native_wayland_drm_bufmgr.c
+++ b/src/gallium/state_trackers/egl/common/native_wayland_drm_bufmgr.c
@@ -70,8 +70,8 @@ wayland_drm_bufmgr_reference_buffer(void
    templ.target = PIPE_TEXTURE_2D;
    templ.format = pf;
    templ.bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
-   templ.width0 = buffer->buffer.width;
-   templ.height0 = buffer->buffer.height;
+   templ.width0 = buffer->width;
+   templ.height0 = buffer->height;
    templ.depth0 = 1;
    templ.array_size = 1;
 
@@ -137,22 +137,31 @@ wayland_drm_bufmgr_unbind_display(struct
 
 static struct pipe_resource *
 wayland_drm_bufmgr_wl_buffer_get_resource(struct native_display *ndpy,
-                                          struct wl_buffer *buffer)
+                                          struct wl_resourcer *buffer_resource)
 {
+   struct wayland_drm_bufmgr *bufmgr = wayland_drm_bufmgr(ndpy->wayland_bufmgr);
+   struct wl_drm_buffer *buffer = wayland_drm_buffer_get(bufmgr->wl_server_drm, buffer_resource);
+
+   if (!buffer)
+      return NULL;
+
    return wayland_drm_buffer_get_buffer(buffer);
 }
 
 static EGLBoolean
 wayland_drm_bufmgr_query_buffer(struct native_display *ndpy,
-                                struct wl_buffer *_buffer,
+                                struct wl_resource *buffer_resource,
                                 EGLint attribute, EGLint *value)
 {
-   struct wl_drm_buffer *buffer = (struct wl_drm_buffer *) _buffer;
-   struct pipe_resource *resource = buffer->driver_buffer;
+   struct wayland_drm_bufmgr *bufmgr = wayland_drm_bufmgr(ndpy->wayland_bufmgr);
+   struct wl_drm_buffer *buffer = wayland_drm_buffer_get(bufmgr->wl_server_drm, buffer_resource);
+   struct pipe_resource *resource;
 
-   if (!wayland_buffer_is_drm(wayland_drm_bufmgr(ndpy->wayland_bufmgr)->wl_server_drm, &buffer->buffer))
+   if (!buffer)
       return EGL_FALSE;
 
+   resource = buffer->driver_buffer;
+
    switch (attribute) {
    case EGL_TEXTURE_FORMAT:
       switch (resource->format) {
@@ -166,10 +175,10 @@ wayland_drm_bufmgr_query_buffer(struct n
          return EGL_FALSE;
       }
    case EGL_WIDTH:
-      *value = buffer->buffer.width;
+      *value = buffer->width;
       return EGL_TRUE;
    case EGL_HEIGHT:
-      *value = buffer->buffer.height;
+      *value = buffer->height;
       return EGL_TRUE;
    default:
       return EGL_FALSE;
diff --git a/src/gbm/backends/dri/gbm_dri.c b/src/gbm/backends/dri/gbm_dri.c
index a3a0530..f7da79c 100644
--- a/src/gbm/backends/dri/gbm_dri.c
+++ b/src/gbm/backends/dri/gbm_dri.c
@@ -374,12 +374,13 @@ gbm_dri_bo_import(struct gbm_device *gbm
 #if HAVE_WAYLAND_PLATFORM
    case GBM_BO_IMPORT_WL_BUFFER:
    {
-      struct wl_drm_buffer *wb = (struct wl_drm_buffer *) buffer;
+      struct wl_drm_buffer *wb;
 
       if (dri->wl_drm == NULL)
          return NULL;
 
-      if (!wayland_buffer_is_drm(dri->wl_drm, buffer))
+      wb = wayland_drm_buffer_get(dri->wl_drm, (struct wl_resource *) buffer);
+      if (!wb);
          return NULL;
 
       image = wb->driver_buffer;
