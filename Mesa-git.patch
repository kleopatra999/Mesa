diff --git a/docs/relnotes-8.0.2.html b/docs/relnotes-8.0.2.html
index ad1818c..d73ba9f 100644
--- a/docs/relnotes-8.0.2.html
+++ b/docs/relnotes-8.0.2.html
@@ -28,7 +28,9 @@ for DRI hardware acceleration.
 
 <h2>MD5 checksums</h2>
 <pre>
-tdb
+70eb3dc74fbfcd72f6776268ee1db52e  MesaLib-8.0.2.tar.gz
+a368104e5700707048dc3e8691a9a7a1  MesaLib-8.0.2.tar.bz2
+d5e5cdb85d2afdbcd1c0623d3ed1c54d  MesaLib-8.0.2.zip
 </pre>
 
 <h2>New features</h2>
diff --git a/src/gallium/drivers/r300/r300_blit.c b/src/gallium/drivers/r300/r300_blit.c
index d132638..920612b 100644
--- a/src/gallium/drivers/r300/r300_blit.c
+++ b/src/gallium/drivers/r300/r300_blit.c
@@ -63,8 +63,13 @@ static void r300_blitter_begin(struct r300_context* r300, enum r300_blitter_op o
     util_blitter_save_vertex_shader(r300->blitter, r300->vs_state.state);
     util_blitter_save_viewport(r300->blitter, &r300->viewport);
     util_blitter_save_vertex_elements(r300->blitter, r300->velems);
-    util_blitter_save_vertex_buffers(r300->blitter, r300->vbuf_mgr->nr_vertex_buffers,
-                                     r300->vbuf_mgr->vertex_buffer);
+    if (r300->vbuf_mgr) {
+        util_blitter_save_vertex_buffers(r300->blitter, r300->vbuf_mgr->nr_vertex_buffers,
+                                         r300->vbuf_mgr->vertex_buffer);
+    } else {
+        util_blitter_save_vertex_buffers(r300->blitter, r300->swtcl_nr_vertex_buffers,
+                                         r300->swtcl_vertex_buffer);
+    }
 
     if (op & R300_SAVE_FRAMEBUFFER) {
         util_blitter_save_framebuffer(r300->blitter, r300->fb_state.state);
diff --git a/src/gallium/drivers/r300/r300_context.c b/src/gallium/drivers/r300/r300_context.c
index 7d289ca..1626768 100644
--- a/src/gallium/drivers/r300/r300_context.c
+++ b/src/gallium/drivers/r300/r300_context.c
@@ -419,17 +419,19 @@ struct pipe_context* r300_create_context(struct pipe_screen* screen,
     r300_init_query_functions(r300);
     r300_init_state_functions(r300);
     r300_init_resource_functions(r300);
-    
+
     r300->context.create_video_decoder = vl_create_decoder;
     r300->context.create_video_buffer = vl_video_buffer_create;
 
-    r300->vbuf_mgr = u_vbuf_create(&r300->context, 1024 * 1024, 16,
+    if (r300->screen->caps.has_tcl) {
+        r300->vbuf_mgr = u_vbuf_create(&r300->context, 1024 * 1024, 16,
                                        PIPE_BIND_VERTEX_BUFFER |
                                        PIPE_BIND_INDEX_BUFFER,
                                        U_VERTEX_FETCH_DWORD_ALIGNED);
-    if (!r300->vbuf_mgr)
-        goto fail;
-    r300->vbuf_mgr->caps.format_fixed32 = 0;
+        if (!r300->vbuf_mgr)
+            goto fail;
+        r300->vbuf_mgr->caps.format_fixed32 = 0;
+    }
 
     r300->blitter = util_blitter_create(&r300->context);
     if (r300->blitter == NULL)
diff --git a/src/gallium/drivers/r300/r300_context.h b/src/gallium/drivers/r300/r300_context.h
index e40b7af..8264b28 100644
--- a/src/gallium/drivers/r300/r300_context.h
+++ b/src/gallium/drivers/r300/r300_context.h
@@ -581,6 +581,9 @@ struct r300_context {
     void *dsa_decompress_zmask;
 
     struct u_vbuf *vbuf_mgr;
+    struct pipe_index_buffer swtcl_index_buffer;
+    struct pipe_vertex_buffer swtcl_vertex_buffer[PIPE_MAX_ATTRIBS];
+    unsigned swtcl_nr_vertex_buffers;
 
     struct util_slab_mempool pool_transfers;
 
diff --git a/src/gallium/drivers/r300/r300_render.c b/src/gallium/drivers/r300/r300_render.c
index 83cad42..1542648 100644
--- a/src/gallium/drivers/r300/r300_render.c
+++ b/src/gallium/drivers/r300/r300_render.c
@@ -818,7 +818,7 @@ static void r300_swtcl_draw_vbo(struct pipe_context* pipe,
     struct pipe_transfer *ib_transfer = NULL;
     int i;
     void *indices = NULL;
-    boolean indexed = info->indexed && r300->vbuf_mgr->index_buffer.buffer;
+    boolean indexed = info->indexed && r300->swtcl_index_buffer.buffer;
 
     if (r300->skip_rendering) {
         return;
@@ -831,10 +831,10 @@ static void r300_swtcl_draw_vbo(struct pipe_context* pipe,
             (indexed ? PREP_INDEXED : 0),
             indexed ? 256 : 6);
 
-    for (i = 0; i < r300->vbuf_mgr->nr_vertex_buffers; i++) {
-        if (r300->vbuf_mgr->vertex_buffer[i].buffer) {
+    for (i = 0; i < r300->swtcl_nr_vertex_buffers; i++) {
+        if (r300->swtcl_vertex_buffer[i].buffer) {
             void *buf = pipe_buffer_map(pipe,
-                                  r300->vbuf_mgr->vertex_buffer[i].buffer,
+                                  r300->swtcl_vertex_buffer[i].buffer,
                                   PIPE_TRANSFER_READ |
                                   PIPE_TRANSFER_UNSYNCHRONIZED,
                                   &vb_transfer[i]);
@@ -843,7 +843,7 @@ static void r300_swtcl_draw_vbo(struct pipe_context* pipe,
     }
 
     if (indexed) {
-        indices = pipe_buffer_map(pipe, r300->vbuf_mgr->index_buffer.buffer,
+        indices = pipe_buffer_map(pipe, r300->swtcl_index_buffer.buffer,
                                   PIPE_TRANSFER_READ |
                                   PIPE_TRANSFER_UNSYNCHRONIZED, &ib_transfer);
     }
@@ -856,8 +856,8 @@ static void r300_swtcl_draw_vbo(struct pipe_context* pipe,
     draw_flush(r300->draw);
     r300->draw_vbo_locked = FALSE;
 
-    for (i = 0; i < r300->vbuf_mgr->nr_vertex_buffers; i++) {
-        if (r300->vbuf_mgr->vertex_buffer[i].buffer) {
+    for (i = 0; i < r300->swtcl_nr_vertex_buffers; i++) {
+        if (r300->swtcl_vertex_buffer[i].buffer) {
             pipe_buffer_unmap(pipe, vb_transfer[i]);
             draw_set_mapped_vertex_buffer(r300->draw, i, NULL);
         }
diff --git a/src/gallium/drivers/r300/r300_screen.c b/src/gallium/drivers/r300/r300_screen.c
index 763321b..f28b0be 100644
--- a/src/gallium/drivers/r300/r300_screen.c
+++ b/src/gallium/drivers/r300/r300_screen.c
@@ -212,6 +212,7 @@ static int r300_get_shader_param(struct pipe_screen *pscreen, unsigned shader, e
         switch (param)
         {
         case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
+        case PIPE_SHADER_CAP_SUBROUTINES:
             return 0;
         default:;
         }
diff --git a/src/gallium/drivers/r300/r300_state.c b/src/gallium/drivers/r300/r300_state.c
index 2bc7036..c43352a 100644
--- a/src/gallium/drivers/r300/r300_state.c
+++ b/src/gallium/drivers/r300/r300_state.c
@@ -1048,6 +1048,10 @@ static void* r300_create_rs_state(struct pipe_context* pipe,
 
     /* Override some states for Draw. */
     rs->rs_draw.sprite_coord_enable = 0; /* We can do this in HW. */
+    rs->rs_draw.offset_point = 0;
+    rs->rs_draw.offset_line = 0;
+    rs->rs_draw.offset_tri = 0;
+    rs->rs_draw.offset_clamp = 0;
 
 #ifdef PIPE_ARCH_LITTLE_ENDIAN
     vap_control_status = R300_VC_NO_SWAP;
@@ -1595,7 +1599,6 @@ static void r300_set_vertex_buffers(struct pipe_context* pipe,
                                     const struct pipe_vertex_buffer* buffers)
 {
     struct r300_context* r300 = r300_context(pipe);
-    unsigned i;
     struct pipe_vertex_buffer dummy_vb = {0};
 
     /* There must be at least one vertex buffer set, otherwise it locks up. */
@@ -1605,18 +1608,13 @@ static void r300_set_vertex_buffers(struct pipe_context* pipe,
         count = 1;
     }
 
-    u_vbuf_set_vertex_buffers(r300->vbuf_mgr, count, buffers);
-
     if (r300->screen->caps.has_tcl) {
-        /* HW TCL. */
-        for (i = 0; i < count; i++) {
-            if (buffers[i].buffer &&
-		!r300_resource(buffers[i].buffer)->b.user_ptr) {
-            }
-        }
+        u_vbuf_set_vertex_buffers(r300->vbuf_mgr, count, buffers);
         r300->vertex_arrays_dirty = TRUE;
     } else {
-        /* SW TCL. */
+        util_copy_vertex_buffers(r300->swtcl_vertex_buffer,
+                                 &r300->swtcl_nr_vertex_buffers,
+                                 buffers, count);
         draw_set_vertex_buffers(r300->draw, count, buffers);
     }
 }
@@ -1626,9 +1624,15 @@ static void r300_set_index_buffer(struct pipe_context* pipe,
 {
     struct r300_context* r300 = r300_context(pipe);
 
-    u_vbuf_set_index_buffer(r300->vbuf_mgr, ib);
-
-    if (!r300->screen->caps.has_tcl) {
+    if (r300->screen->caps.has_tcl) {
+        u_vbuf_set_index_buffer(r300->vbuf_mgr, ib);
+    } else {
+        if (ib) {
+            pipe_resource_reference(&r300->swtcl_index_buffer.buffer, ib->buffer);
+            memcpy(&r300->swtcl_index_buffer, ib, sizeof(*ib));
+        } else {
+            pipe_resource_reference(&r300->swtcl_index_buffer.buffer, NULL);
+        }
         draw_set_index_buffer(r300->draw, ib);
     }
 }
@@ -1702,11 +1706,11 @@ static void* r300_create_vertex_elements_state(struct pipe_context* pipe,
         return NULL;
 
     velems->count = count;
-    velems->vmgr_elements =
-        u_vbuf_create_vertex_elements(r300->vbuf_mgr, count, attribs,
-                                          velems->velem);
 
     if (r300_screen(pipe->screen)->caps.has_tcl) {
+        velems->vmgr_elements =
+            u_vbuf_create_vertex_elements(r300->vbuf_mgr, count, attribs,
+                                          velems->velem);
         /* Setup PSC.
          * The unused components will be replaced by (..., 0, 1). */
         r300_vertex_psc(velems);
@@ -1716,6 +1720,8 @@ static void* r300_create_vertex_elements_state(struct pipe_context* pipe,
                 align(util_format_get_blocksize(velems->velem[i].src_format), 4);
             velems->vertex_size_dwords += velems->format_size[i] / 4;
         }
+    } else {
+        memcpy(velems->velem, attribs, count * sizeof(struct pipe_vertex_element));
     }
 
     return velems;
@@ -1733,9 +1739,9 @@ static void r300_bind_vertex_elements_state(struct pipe_context *pipe,
 
     r300->velems = velems;
 
-    u_vbuf_bind_vertex_elements(r300->vbuf_mgr, state, velems->vmgr_elements);
-
-    if (r300->draw) {
+    if (r300->screen->caps.has_tcl) {
+        u_vbuf_bind_vertex_elements(r300->vbuf_mgr, state, velems->vmgr_elements);
+    } else {
         draw_set_vertex_elements(r300->draw, velems->count, velems->velem);
         return;
     }
@@ -1750,7 +1756,9 @@ static void r300_delete_vertex_elements_state(struct pipe_context *pipe, void *s
     struct r300_context *r300 = r300_context(pipe);
     struct r300_vertex_element_state *velems = state;
 
-    u_vbuf_destroy_vertex_elements(r300->vbuf_mgr, velems->vmgr_elements);
+    if (r300->screen->caps.has_tcl) {
+        u_vbuf_destroy_vertex_elements(r300->vbuf_mgr, velems->vmgr_elements);
+    }
     FREE(state);
 }
 
@@ -1765,10 +1773,10 @@ static void* r300_create_vs_state(struct pipe_context* pipe,
     vs->state.tokens = tgsi_dup_tokens(shader->tokens);
 
     if (r300->screen->caps.has_tcl) {
-        r300_init_vs_outputs(vs);
+        r300_init_vs_outputs(r300, vs);
         r300_translate_vertex_shader(r300, vs);
     } else {
-        r300_draw_init_vertex_shader(r300->draw, vs);
+        r300_draw_init_vertex_shader(r300, vs);
     }
 
     return vs;
diff --git a/src/gallium/drivers/r300/r300_vs.c b/src/gallium/drivers/r300/r300_vs.c
index 1eef071..4faf2b5 100644
--- a/src/gallium/drivers/r300/r300_vs.c
+++ b/src/gallium/drivers/r300/r300_vs.c
@@ -36,6 +36,7 @@
 
 /* Convert info about VS output semantics into r300_shader_semantics. */
 static void r300_shader_read_vs_outputs(
+    struct r300_context *r300,
     struct tgsi_shader_info* info,
     struct r300_shader_semantics* vs_outputs)
 {
@@ -83,6 +84,14 @@ static void r300_shader_read_vs_outputs(
                 fprintf(stderr, "r300 VP: cannot handle edgeflag output.\n");
                 break;
 
+            case TGSI_SEMANTIC_CLIPVERTEX:
+                assert(index == 0);
+                /* Draw does clip vertex for us. */
+                if (r300->screen->caps.has_tcl) {
+                    fprintf(stderr, "r300 VP: cannot handle clip vertex output.\n");
+                }
+                break;
+
             default:
                 fprintf(stderr, "r300 VP: unknown vertex output semantic: %i.\n",
                         info->output_semantic_name[i]);
@@ -160,10 +169,11 @@ static void set_vertex_inputs_outputs(struct r300_vertex_program_compiler * c)
     c->code->outputs[outputs->wpos] = reg++;
 }
 
-void r300_init_vs_outputs(struct r300_vertex_shader *vs)
+void r300_init_vs_outputs(struct r300_context *r300,
+                          struct r300_vertex_shader *vs)
 {
     tgsi_scan_shader(vs->state.tokens, &vs->info);
-    r300_shader_read_vs_outputs(&vs->info, &vs->outputs);
+    r300_shader_read_vs_outputs(r300, &vs->info, &vs->outputs);
 }
 
 static void r300_dummy_vertex_shader(
@@ -187,7 +197,7 @@ static void r300_dummy_vertex_shader(
     ureg_destroy(ureg);
 
     shader->dummy = TRUE;
-    r300_init_vs_outputs(shader);
+    r300_init_vs_outputs(r300, shader);
     r300_translate_vertex_shader(r300, shader);
 }
 
diff --git a/src/gallium/drivers/r300/r300_vs.h b/src/gallium/drivers/r300/r300_vs.h
index a482ddc..b02d5d7 100644
--- a/src/gallium/drivers/r300/r300_vs.h
+++ b/src/gallium/drivers/r300/r300_vs.h
@@ -56,12 +56,13 @@ struct r300_vertex_shader {
     void *draw_vs;
 };
 
-void r300_init_vs_outputs(struct r300_vertex_shader *vs);
+void r300_init_vs_outputs(struct r300_context *r300,
+                          struct r300_vertex_shader *vs);
 
 void r300_translate_vertex_shader(struct r300_context *r300,
                                   struct r300_vertex_shader *vs);
 
-void r300_draw_init_vertex_shader(struct draw_context *draw,
+void r300_draw_init_vertex_shader(struct r300_context *r300,
                                   struct r300_vertex_shader *vs);
 
 #endif /* R300_VS_H */
diff --git a/src/gallium/drivers/r300/r300_vs_draw.c b/src/gallium/drivers/r300/r300_vs_draw.c
index 2939963..69d6758 100644
--- a/src/gallium/drivers/r300/r300_vs_draw.c
+++ b/src/gallium/drivers/r300/r300_vs_draw.c
@@ -29,7 +29,7 @@
  *
  * Transformations:
  * 1) If the secondary color output is present, the primary color must be
- *    inserted before it.
+ *    present too.
  * 2) If any back-face color output is present, there must be all 4 color
  *    outputs and missing ones must be inserted.
  * 3) Insert a trailing texcoord output containing a copy of POS, for WPOS.
@@ -52,7 +52,6 @@ struct vs_transform_context {
 
     boolean color_used[2];
     boolean bcolor_used[2];
-    boolean temp_used[128];
 
     /* Index of the pos output, typically 0. */
     unsigned pos_output;
@@ -72,6 +71,8 @@ struct vs_transform_context {
     boolean first_instruction;
     /* End instruction processed? */
     boolean end_instruction;
+
+    boolean temp_used[1024];
 };
 
 static void emit_temp(struct tgsi_transform_context *ctx, unsigned reg)
@@ -102,9 +103,9 @@ static void emit_output(struct tgsi_transform_context *ctx,
     ++vsctx->num_outputs;
 }
 
-static void insert_output(struct tgsi_transform_context *ctx,
-                          struct tgsi_full_declaration *before,
-                          unsigned name, unsigned index, unsigned interp)
+static void insert_output_before(struct tgsi_transform_context *ctx,
+                                 struct tgsi_full_declaration *before,
+                                 unsigned name, unsigned index, unsigned interp)
 {
     struct vs_transform_context *vsctx = (struct vs_transform_context *)ctx;
     unsigned i;
@@ -115,28 +116,29 @@ static void insert_output(struct tgsi_transform_context *ctx,
     }
 
     /* Insert the new output. */
-    emit_output(ctx, name, index, interp, before->Range.First);
+    emit_output(ctx, name, index, interp,
+                before->Range.First + vsctx->decl_shift);
 
     ++vsctx->decl_shift;
 }
 
-static void insert_trailing_bcolor(struct tgsi_transform_context *ctx,
-                                   struct tgsi_full_declaration *before)
+static void insert_output_after(struct tgsi_transform_context *ctx,
+                                struct tgsi_full_declaration *after,
+                                unsigned name, unsigned index, unsigned interp)
 {
     struct vs_transform_context *vsctx = (struct vs_transform_context *)ctx;
+    unsigned i;
 
-    /* If BCOLOR0 is used, make sure BCOLOR1 is present too. Otherwise
-     * the rasterizer doesn't do the color selection correctly. */
-    if (vsctx->bcolor_used[0] && !vsctx->bcolor_used[1]) {
-        if (before) {
-            insert_output(ctx, before, TGSI_SEMANTIC_BCOLOR, 1,
-                          TGSI_INTERPOLATE_LINEAR);
-        } else {
-            emit_output(ctx, TGSI_SEMANTIC_BCOLOR, 1,
-                        TGSI_INTERPOLATE_LINEAR, vsctx->num_outputs);
-        }
-        vsctx->bcolor_used[1] = TRUE;
+    /* Make a place for the new output. */
+    for (i = after->Range.First+1; i < Elements(vsctx->out_remap); i++) {
+        ++vsctx->out_remap[i];
     }
+
+    /* Insert the new output. */
+    emit_output(ctx, name, index, interp,
+                after->Range.First + 1);
+
+    ++vsctx->decl_shift;
 }
 
 static void transform_decl(struct tgsi_transform_context *ctx,
@@ -153,41 +155,38 @@ static void transform_decl(struct tgsi_transform_context *ctx,
 
             case TGSI_SEMANTIC_COLOR:
                 assert(decl->Semantic.Index < 2);
-                vsctx->color_used[decl->Semantic.Index] = TRUE;
 
                 /* We must rasterize the first color if the second one is
                  * used, otherwise the rasterizer doesn't do the color
                  * selection correctly. Declare it, but don't write to it. */
                 if (decl->Semantic.Index == 1 && !vsctx->color_used[0]) {
-                    insert_output(ctx, decl, TGSI_SEMANTIC_COLOR, 0,
-                                  TGSI_INTERPOLATE_LINEAR);
+                    insert_output_before(ctx, decl, TGSI_SEMANTIC_COLOR, 0,
+                                         TGSI_INTERPOLATE_LINEAR);
                     vsctx->color_used[0] = TRUE;
                 }
                 break;
 
             case TGSI_SEMANTIC_BCOLOR:
                 assert(decl->Semantic.Index < 2);
-                vsctx->bcolor_used[decl->Semantic.Index] = TRUE;
 
                 /* We must rasterize all 4 colors if back-face colors are
                  * used, otherwise the rasterizer doesn't do the color
                  * selection correctly. Declare it, but don't write to it. */
                 if (!vsctx->color_used[0]) {
-                    insert_output(ctx, decl, TGSI_SEMANTIC_COLOR, 0,
-                                  TGSI_INTERPOLATE_LINEAR);
+                    insert_output_before(ctx, decl, TGSI_SEMANTIC_COLOR, 0,
+                                         TGSI_INTERPOLATE_LINEAR);
                     vsctx->color_used[0] = TRUE;
                 }
                 if (!vsctx->color_used[1]) {
-                    insert_output(ctx, decl, TGSI_SEMANTIC_COLOR, 1,
-                                  TGSI_INTERPOLATE_LINEAR);
+                    insert_output_before(ctx, decl, TGSI_SEMANTIC_COLOR, 1,
+                                         TGSI_INTERPOLATE_LINEAR);
                     vsctx->color_used[1] = TRUE;
                 }
                 if (decl->Semantic.Index == 1 && !vsctx->bcolor_used[0]) {
-                    insert_output(ctx, decl, TGSI_SEMANTIC_BCOLOR, 0,
-                                  TGSI_INTERPOLATE_LINEAR);
+                    insert_output_before(ctx, decl, TGSI_SEMANTIC_BCOLOR, 0,
+                                         TGSI_INTERPOLATE_LINEAR);
                     vsctx->bcolor_used[0] = TRUE;
                 }
-                /* One more case is handled in insert_trailing_bcolor. */
                 break;
 
             case TGSI_SEMANTIC_GENERIC:
@@ -195,11 +194,6 @@ static void transform_decl(struct tgsi_transform_context *ctx,
                 break;
         }
 
-        if (decl->Semantic.Name != TGSI_SEMANTIC_BCOLOR) {
-            /* Insert it as soon as possible. */
-            insert_trailing_bcolor(ctx, decl);
-        }
-
         /* Since we're inserting new outputs in between, the following outputs
          * should be moved to the right so that they don't overlap with
          * the newly added ones. */
@@ -214,6 +208,14 @@ static void transform_decl(struct tgsi_transform_context *ctx,
     }
 
     ctx->emit_declaration(ctx, decl);
+
+    /* Insert BCOLOR1 if needed. */
+    if (decl->Declaration.File == TGSI_FILE_OUTPUT &&
+        decl->Semantic.Name == TGSI_SEMANTIC_BCOLOR &&
+        !vsctx->bcolor_used[1]) {
+        insert_output_after(ctx, decl, TGSI_SEMANTIC_BCOLOR, 1,
+                            TGSI_INTERPOLATE_LINEAR);
+    }
 }
 
 static void transform_inst(struct tgsi_transform_context *ctx,
@@ -226,10 +228,6 @@ static void transform_inst(struct tgsi_transform_context *ctx,
     if (!vsctx->first_instruction) {
         vsctx->first_instruction = TRUE;
 
-        /* The trailing BCOLOR should be inserted before the code
-         * if it hasn't already been done so. */
-        insert_trailing_bcolor(ctx, NULL);
-
         /* Insert the generic output for WPOS. */
         emit_output(ctx, TGSI_SEMANTIC_GENERIC, vsctx->last_generic + 1,
                     TGSI_INTERPOLATE_PERSPECTIVE, vsctx->num_outputs);
@@ -309,14 +307,18 @@ static void transform_inst(struct tgsi_transform_context *ctx,
     ctx->emit_instruction(ctx, inst);
 }
 
-void r300_draw_init_vertex_shader(struct draw_context *draw,
+void r300_draw_init_vertex_shader(struct r300_context *r300,
                                   struct r300_vertex_shader *vs)
 {
+    struct draw_context *draw = r300->draw;
     struct pipe_shader_state new_vs;
+    struct tgsi_shader_info info;
     struct vs_transform_context transform;
     const uint newLen = tgsi_num_tokens(vs->state.tokens) + 100 /* XXX */;
     unsigned i;
 
+    tgsi_scan_shader(vs->state.tokens, &info);
+
     new_vs.tokens = tgsi_alloc_tokens(newLen);
     if (new_vs.tokens == NULL)
         return;
@@ -329,6 +331,22 @@ void r300_draw_init_vertex_shader(struct draw_context *draw,
     transform.base.transform_instruction = transform_inst;
     transform.base.transform_declaration = transform_decl;
 
+    for (i = 0; i < info.num_outputs; i++) {
+        unsigned index = info.output_semantic_index[i];
+
+        switch (info.output_semantic_name[i]) {
+            case TGSI_SEMANTIC_COLOR:
+                assert(index < 2);
+                transform.color_used[index] = TRUE;
+                break;
+
+            case TGSI_SEMANTIC_BCOLOR:
+                assert(index < 2);
+                transform.bcolor_used[index] = TRUE;
+                break;
+        }
+    }
+
     tgsi_transform_shader(vs->state.tokens,
                           (struct tgsi_token*)new_vs.tokens,
                           newLen, &transform.base);
@@ -350,7 +368,7 @@ void r300_draw_init_vertex_shader(struct draw_context *draw,
     vs->state.tokens = new_vs.tokens;
 
     /* Init the VS output table for the rasterizer. */
-    r300_init_vs_outputs(vs);
+    r300_init_vs_outputs(r300, vs);
 
     /* Make the last generic be WPOS. */
     vs->outputs.wpos = vs->outputs.generic[transform.last_generic + 1];
diff --git a/src/glsl/Android.mk b/src/glsl/Android.mk
index d7d17dd..84a8655 100644
--- a/src/glsl/Android.mk
+++ b/src/glsl/Android.mk
@@ -39,6 +39,7 @@ LOCAL_SRC_FILES := \
 	$(LIBGLSL_CXX_SOURCES)
 
 LOCAL_C_INCLUDES := \
+	external/astl/include \
 	$(MESA_TOP)/src/mapi \
 	$(MESA_TOP)/src/mesa
 
diff --git a/src/glx/apple/apple_glx_drawable.c b/src/glx/apple/apple_glx_drawable.c
index 5530224..db28302 100644
--- a/src/glx/apple/apple_glx_drawable.c
+++ b/src/glx/apple/apple_glx_drawable.c
@@ -135,6 +135,7 @@ release_drawable(struct apple_glx_drawable *d)
 static bool
 destroy_drawable(struct apple_glx_drawable *d)
 {
+   int err;
 
    d->lock(d);
 
@@ -172,6 +173,12 @@ destroy_drawable(struct apple_glx_drawable *d)
 
    apple_glx_diagnostic("%s: freeing %p\n", __func__, (void *) d);
 
+   err = pthread_mutex_destroy(&d->mutex);
+   if (err) {
+      fprintf(stderr, "pthread_mutex_destroy error: %s\n", strerror(err));
+      abort();
+   }
+   
    free(d);
 
    /* So that the locks are balanced and the caller correctly unlocks. */
diff --git a/src/glx/apple/apple_glx_surface.c b/src/glx/apple/apple_glx_surface.c
index 39f5130..d42fa3b 100644
--- a/src/glx/apple/apple_glx_surface.c
+++ b/src/glx/apple/apple_glx_surface.c
@@ -206,6 +206,10 @@ apple_glx_surface_destroy(unsigned int uid)
    if (d) {
       d->types.surface.pending_destroy = true;
       d->release(d);
+
+      /* apple_glx_drawable_find_by_uid returns a locked drawable */
+      d->unlock(d);
+
       /* 
        * We release 2 references to the surface.  One was acquired by
        * the find, and the other was leftover from a context, or 
@@ -217,7 +221,5 @@ apple_glx_surface_destroy(unsigned int uid)
        * by a glViewport callback (see apple_glx_context_update()).
        */
       d->destroy(d);
-
-      d->unlock(d);
    }
 }
diff --git a/src/mapi/glapi/glapi_gentable.c b/src/mapi/glapi/glapi_gentable.c
index 5c04801..640c495 100644
--- a/src/mapi/glapi/glapi_gentable.c
+++ b/src/mapi/glapi/glapi_gentable.c
@@ -105,7 +105,7 @@ __glapi_gentable_set_remaining_noop(struct _glapi_table *disp) {
 
 struct _glapi_table *
 _glapi_create_table_from_handle(void *handle, const char *symbol_prefix) {
-    struct _glapi_table *disp = calloc(1, sizeof(struct _glapi_table));
+    struct _glapi_table *disp = calloc(_glapi_get_dispatch_table_size(), sizeof(void *));
     char symboln[512];
 
     if(!disp)
diff --git a/src/mesa/drivers/dri/i915/i915_context.c b/src/mesa/drivers/dri/i915/i915_context.c
index 36563ef..dc32292 100644
--- a/src/mesa/drivers/dri/i915/i915_context.c
+++ b/src/mesa/drivers/dri/i915/i915_context.c
@@ -76,6 +76,8 @@ i915InvalidateState(struct gl_context * ctx, GLuint new_state)
        i915_update_provoking_vertex(ctx);
    if (new_state & (_NEW_PROGRAM | _NEW_PROGRAM_CONSTANTS))
        i915_update_program(ctx);
+   if (new_state & (_NEW_PROGRAM | _NEW_POINT))
+       i915_update_sprite_point_enable(ctx);
 }
 
 
diff --git a/src/mesa/drivers/dri/i915/i915_context.h b/src/mesa/drivers/dri/i915/i915_context.h
index 8167137..7037465 100644
--- a/src/mesa/drivers/dri/i915/i915_context.h
+++ b/src/mesa/drivers/dri/i915/i915_context.h
@@ -40,6 +40,7 @@
 #define I915_FALLBACK_POINT_SMOOTH	 0x80000
 #define I915_FALLBACK_POINT_SPRITE_COORD_ORIGIN	 0x100000
 #define I915_FALLBACK_DRAW_OFFSET	 0x200000
+#define I915_FALLBACK_COORD_REPLACE	 0x400000
 
 #define I915_UPLOAD_CTX              0x1
 #define I915_UPLOAD_BUFFERS          0x2
@@ -338,6 +339,7 @@ extern void i915InitStateFunctions(struct dd_function_table *functions);
 extern void i915InitState(struct i915_context *i915);
 extern void i915_update_stencil(struct gl_context * ctx);
 extern void i915_update_provoking_vertex(struct gl_context *ctx);
+extern void i915_update_sprite_point_enable(struct gl_context *ctx);
 
 
 /*======================================================================
diff --git a/src/mesa/drivers/dri/i915/i915_state.c b/src/mesa/drivers/dri/i915/i915_state.c
index 756001f..94c7327 100644
--- a/src/mesa/drivers/dri/i915/i915_state.c
+++ b/src/mesa/drivers/dri/i915/i915_state.c
@@ -652,6 +652,48 @@ i915PointParameterfv(struct gl_context * ctx, GLenum pname, const GLfloat *param
    }
 }
 
+void
+i915_update_sprite_point_enable(struct gl_context *ctx)
+{
+   struct intel_context *intel = intel_context(ctx);
+   /* _NEW_PROGRAM */
+   struct i915_fragment_program *p =
+      (struct i915_fragment_program *) ctx->FragmentProgram._Current;
+   const GLbitfield64 inputsRead = p->FragProg.Base.InputsRead;
+   struct i915_context *i915 = i915_context(ctx);
+   GLuint s4 = i915->state.Ctx[I915_CTXREG_LIS4] & ~S4_VFMT_MASK;
+   int i;
+   GLuint coord_replace_bits = 0x0;
+   GLuint tex_coord_unit_bits = 0x0;
+
+   for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
+      /* _NEW_POINT */
+      if (ctx->Point.CoordReplace[i] && ctx->Point.PointSprite)
+         coord_replace_bits |= (1 << i);
+      if (inputsRead & FRAG_BIT_TEX(i))
+         tex_coord_unit_bits |= (1 << i);
+   }
+
+   /*
+    * Here we can't enable the SPRITE_POINT_ENABLE bit when the mis-match
+    * of tex_coord_unit_bits and coord_replace_bits, or this will make all
+    * the other non-point-sprite coords(like varying inputs, as we now use
+    * tex coord to implement varying inputs) be replaced to value (0, 0)-(1, 1).
+    *
+    * Thus, do fallback when needed.
+    */
+   FALLBACK(intel, I915_FALLBACK_COORD_REPLACE,
+            coord_replace_bits && coord_replace_bits != tex_coord_unit_bits);
+
+   s4 &= ~S4_SPRITE_POINT_ENABLE;
+   s4 |= (coord_replace_bits && coord_replace_bits == tex_coord_unit_bits) ?
+         S4_SPRITE_POINT_ENABLE : 0;
+   if (s4 != i915->state.Ctx[I915_CTXREG_LIS4]) {
+      i915->state.Ctx[I915_CTXREG_LIS4] = s4;
+      I915_STATECHANGE(i915, I915_UPLOAD_CTX);
+   }
+}
+
 
 /* =============================================================
  * Color masks
@@ -869,18 +911,7 @@ i915Enable(struct gl_context * ctx, GLenum cap, GLboolean state)
       break;
 
    case GL_POINT_SPRITE:
-      /* This state change is handled in i915_reduced_primitive_state because
-       * the hardware bit should only be set when rendering points.
-       */
-	 dw = i915->state.Ctx[I915_CTXREG_LIS4];
-      if (state)
-	 dw |= S4_SPRITE_POINT_ENABLE;
-      else
-	 dw &= ~S4_SPRITE_POINT_ENABLE;
-      if (dw != i915->state.Ctx[I915_CTXREG_LIS4]) {
-	 i915->state.Ctx[I915_CTXREG_LIS4] = dw;
-	 I915_STATECHANGE(i915, I915_UPLOAD_CTX);
-      }
+      /* Handle it at i915_update_sprite_point_enable () */
       break;
 
    case GL_POINT_SMOOTH:
diff --git a/src/mesa/drivers/dri/i915/intel_tris.c b/src/mesa/drivers/dri/i915/intel_tris.c
index a36011a..68f0e05 100644
--- a/src/mesa/drivers/dri/i915/intel_tris.c
+++ b/src/mesa/drivers/dri/i915/intel_tris.c
@@ -1198,6 +1198,7 @@ static char *fallbackStrings[] = {
    [19] = "Smooth point",
    [20] = "point sprite coord origin",
    [21] = "depth/color drawing offset",
+   [22] = "coord replace(SPRITE POINT ENABLE)",
 };
 
 
diff --git a/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp b/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp
index 0632052..cec1e95 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp
@@ -1921,7 +1921,10 @@ fs_visitor::emit_fb_writes()
 {
    this->current_annotation = "FB write header";
    bool header_present = true;
-   int base_mrf = 2;
+   /* We can potentially have a message length of up to 15, so we have to set
+    * base_mrf to either 0 or 1 in order to fit in m0..m15.
+    */
+   int base_mrf = 1;
    int nr = base_mrf;
    int reg_width = c->dispatch_width / 8;
 
diff --git a/src/mesa/drivers/dri/i965/gen6_sampler_state.c b/src/mesa/drivers/dri/i965/gen6_sampler_state.c
index 15cae0a..a9a9df5 100644
--- a/src/mesa/drivers/dri/i965/gen6_sampler_state.c
+++ b/src/mesa/drivers/dri/i965/gen6_sampler_state.c
@@ -41,7 +41,7 @@ upload_sampler_state_pointers(struct brw_context *brw)
 	     GS_SAMPLER_STATE_CHANGE |
 	     PS_SAMPLER_STATE_CHANGE |
 	     (4 - 2));
-   OUT_BATCH(0); /* VS */
+   OUT_BATCH(brw->sampler.offset); /* VS */
    OUT_BATCH(0); /* GS */
    OUT_BATCH(brw->sampler.offset);
    ADVANCE_BATCH();
diff --git a/src/mesa/drivers/dri/intel/intel_context.c b/src/mesa/drivers/dri/intel/intel_context.c
index d3c0d70..9cdd804 100644
--- a/src/mesa/drivers/dri/intel/intel_context.c
+++ b/src/mesa/drivers/dri/intel/intel_context.c
@@ -1225,6 +1225,10 @@ intel_process_dri2_buffer_with_separate_stencil(struct intel_context *intel,
    if (!rb)
       return;
 
+   /* Check if we failed to allocate the depth miptree earlier. */
+   if (buffer->attachment == __DRI_BUFFER_HIZ && rb->mt == NULL)
+     return;
+
    /* If the renderbuffer's and DRIbuffer's regions match, then continue. */
    if ((buffer->attachment != __DRI_BUFFER_HIZ &&
 	rb->mt &&
@@ -1266,6 +1270,7 @@ intel_process_dri2_buffer_with_separate_stencil(struct intel_context *intel,
     * due to failure to allocate new storage.
     */
    if (buffer->attachment == __DRI_BUFFER_HIZ) {
+      assert(rb->mt);
       intel_miptree_release(&rb->mt->hiz_mt);
    } else {
       intel_miptree_release(&rb->mt);
@@ -1291,6 +1296,7 @@ intel_process_dri2_buffer_with_separate_stencil(struct intel_context *intel,
 
    /* Associate buffer with new storage. */
    if (buffer->attachment == __DRI_BUFFER_HIZ) {
+      assert(rb->mt);
       rb->mt->hiz_mt = mt;
    } else {
       rb->mt = mt;
diff --git a/src/mesa/main/readpix.c b/src/mesa/main/readpix.c
index 5b3c246..f3a0d10 100644
--- a/src/mesa/main/readpix.c
+++ b/src/mesa/main/readpix.c
@@ -196,6 +196,11 @@ read_stencil_pixels( struct gl_context *ctx,
    ctx->Driver.UnmapRenderbuffer(ctx, rb);
 }
 
+
+/**
+ * Try to do glReadPixels of RGBA data using a simple memcpy or swizzle.
+ * \return GL_TRUE if successful, GL_FALSE otherwise (use the slow path)
+ */
 static GLboolean
 fast_read_rgba_pixels_memcpy( struct gl_context *ctx,
 			      GLint x, GLint y,
@@ -208,8 +213,20 @@ fast_read_rgba_pixels_memcpy( struct gl_context *ctx,
    struct gl_renderbuffer *rb = ctx->ReadBuffer->_ColorReadBuffer;
    GLubyte *dst, *map;
    int dstStride, stride, j, texelBytes;
+   GLboolean swizzle_rb = GL_FALSE, copy_xrgb = GL_FALSE;
 
-   if (!_mesa_format_matches_format_and_type(rb->Format, format, type))
+   /* XXX we could check for other swizzle/special cases here as needed */
+   if (rb->Format == MESA_FORMAT_RGBA8888_REV &&
+       format == GL_BGRA &&
+       type == GL_UNSIGNED_INT_8_8_8_8_REV) {
+      swizzle_rb = GL_TRUE;
+   }
+   else if (rb->Format == MESA_FORMAT_XRGB8888 &&
+            format == GL_BGRA &&
+            type == GL_UNSIGNED_INT_8_8_8_8_REV) {
+      copy_xrgb = GL_TRUE;
+   }
+   else if (!_mesa_format_matches_format_and_type(rb->Format, format, type))
       return GL_FALSE;
 
    /* check for things we can't handle here */
@@ -240,10 +257,39 @@ fast_read_rgba_pixels_memcpy( struct gl_context *ctx,
    }
 
    texelBytes = _mesa_get_format_bytes(rb->Format);
-   for (j = 0; j < height; j++) {
-      memcpy(dst, map, width * texelBytes);
-      dst += dstStride;
-      map += stride;
+
+   if (swizzle_rb) {
+      /* swap R/B */
+      for (j = 0; j < height; j++) {
+         int i;
+         for (i = 0; i < width; i++) {
+            GLuint *dst4 = (GLuint *) dst, *map4 = (GLuint *) map;
+            GLuint pixel = map4[i];
+            dst4[i] = (pixel & 0xff00ff00)
+                   | ((pixel & 0x00ff0000) >> 16)
+                   | ((pixel & 0x000000ff) << 16);
+         }
+         dst += dstStride;
+         map += stride;
+      }
+   } else if (copy_xrgb) {
+      /* convert xrgb -> argb */
+      for (j = 0; j < height; j++) {
+         GLuint *dst4 = (GLuint *) dst, *map4 = (GLuint *) map;
+         int i;
+         for (i = 0; i < width; i++) {
+            dst4[i] = map4[i] | 0xff000000;  /* set A=0xff */
+         }
+         dst += dstStride;
+         map += stride;
+      }
+   } else {
+      /* just memcpy */
+      for (j = 0; j < height; j++) {
+         memcpy(dst, map, width * texelBytes);
+         dst += dstStride;
+         map += stride;
+      }
    }
 
    ctx->Driver.UnmapRenderbuffer(ctx, rb);
