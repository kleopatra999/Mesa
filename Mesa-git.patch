diff --git a/configs/autoconf.in b/configs/autoconf.in
index 83737e3..a7f3c9d 100644
--- a/configs/autoconf.in
+++ b/configs/autoconf.in
@@ -124,7 +124,7 @@ INSTALL_INC_DIR = $(includedir)
 DRI_DRIVER_INSTALL_DIR = @DRI_DRIVER_INSTALL_DIR@
 
 # Where libGL will look for DRI hardware drivers
-DRI_DRIVER_SEARCH_DIR = $(DRI_DRIVER_INSTALL_DIR)
+DRI_DRIVER_SEARCH_DIR = @DRI_DRIVER_SEARCH_DIR@
 
 # Xorg driver install directory (for xorg state-tracker)
 XORG_DRIVER_INSTALL_DIR = @XORG_DRIVER_INSTALL_DIR@
diff --git a/configure.ac b/configure.ac
index 7518976..5d11cf8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -230,6 +230,8 @@ else
         LIB_EXTENSION='dylib' ;;
     cygwin* )
         LIB_EXTENSION='dll' ;;
+    aix* )
+        LIB_EXTENSION='a' ;;
     * )
         LIB_EXTENSION='so' ;;
     esac
@@ -647,6 +649,13 @@ AC_ARG_WITH([dri-driverdir],
     [DRI_DRIVER_INSTALL_DIR="$withval"],
     [DRI_DRIVER_INSTALL_DIR='${libdir}/dri'])
 AC_SUBST([DRI_DRIVER_INSTALL_DIR])
+dnl Extra search path for DRI drivers
+AC_ARG_WITH([dri-searchpath],
+    [AS_HELP_STRING([--with-dri-searchpath=DIRS...],
+        [semicolon delimited DRI driver search directories @<:@${libdir}/dri@:>@])],
+    [DRI_DRIVER_SEARCH_DIR="$withval"],
+    [DRI_DRIVER_SEARCH_DIR='${DRI_DRIVER_INSTALL_DIR}'])
+AC_SUBST([DRI_DRIVER_SEARCH_DIR])
 dnl Direct rendering or just indirect rendering
 AC_ARG_ENABLE([driglx-direct],
     [AS_HELP_STRING([--disable-driglx-direct],
diff --git a/docs/news.html b/docs/news.html
index 07ad42e..93da56a 100644
--- a/docs/news.html
+++ b/docs/news.html
@@ -10,6 +10,17 @@
 
 <H1>News</H1>
 
+<h2>September 28, 2009</h2>
+<p>
+<a href="relnotes-7.6.html">Mesa 7.6</a> is released.  This is a new feature
+release.  Those especially concerned about stability may want to wait for the
+follow-on 7.6.1 bug-fix release.
+</p>
+<p>
+<a href="relnotes-7.5.2.html">Mesa 7.5.2</a> is also released.
+This is a stable release fixing bugs since the 7.5.1 release.
+</p>
+
 
 <h2>September 3, 2009</h2>
 <p>
diff --git a/docs/relnotes-7.5.2.html b/docs/relnotes-7.5.2.html
index 0832e11..5c395d9 100644
--- a/docs/relnotes-7.5.2.html
+++ b/docs/relnotes-7.5.2.html
@@ -8,7 +8,7 @@
 
 <body bgcolor="#eeeeee">
 
-<H1>Mesa 7.5.2 Release Notes, (date tbd)</H1>
+<H1>Mesa 7.5.2 Release Notes, 28 September 2009</H1>
 
 <p>
 Mesa 7.5.2 is a bug-fix release fixing issues found since the 7.5.1 release.
@@ -31,7 +31,15 @@ for DRI hardware acceleration.
 
 <h2>MD5 checksums</h2>
 <pre>
-tbd
+43a90191dd9f76cd65dcc1ac91f3be70  MesaLib-7.5.2.tar.gz
+94e47a499f1226803869c2e37a6a8e3a  MesaLib-7.5.2.tar.bz2
+1ecb822b567ad67a0617361d45206b67  MesaLib-7.5.2.zip
+2718fdce7e075911d6147beb8f27104b  MesaDemos-7.5.2.tar.gz
+4e0f5ccd58afe21eddcd94327d926e86  MesaDemos-7.5.2.tar.bz2
+f621f8c223b278d7c8e49a012d56ca25  MesaDemos-7.5.2.zip
+83c16c1d6bcfcc3f97aab5d2fe430b4c  MesaGLUT-7.5.2.tar.gz
+e5d03bedae369ea3705783573bb33813  MesaGLUT-7.5.2.tar.bz2
+e82ba28e00d653e6f437d32be8ca8481  MesaGLUT-7.5.2.zip
 </pre>
 
 
@@ -55,6 +63,5 @@ tbd
     when using Gallium.
 </ul>
 
-
 </body>
 </html>
diff --git a/docs/relnotes-7.6.1.html b/docs/relnotes-7.6.1.html
new file mode 100644
index 0000000..9ee6bab
--- /dev/null
+++ b/docs/relnotes-7.6.1.html
@@ -0,0 +1,58 @@
+<HTML>
+
+<TITLE>Mesa Release Notes</TITLE>
+
+<head><link rel="stylesheet" type="text/css" href="mesa.css"></head>
+
+<BODY>
+
+<body bgcolor="#eeeeee">
+
+<H1>Mesa 7.6.1 Release Notes, (date tbd)</H1>
+
+<p>
+Mesa 7.6.1 is a bug-fix release fixing issues since version 7.6.
+</p>
+<p>
+Mesa 7.6.1 implements the OpenGL 2.1 API, but the version reported by
+glGetString(GL_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 2.1.
+</p>
+<p>
+See the <a href="install.html">Compiling/Installing page</a> for prerequisites
+for DRI hardware acceleration.
+</p>
+
+
+<h2>MD5 checksums</h2>
+<pre>
+tbd
+</pre>
+
+
+<h2>New features</h2>
+<ul>
+<li>Upgraded GL/glext.h to version 56, GL/glxext.h to version 25,
+    GL/wglext.h to version 17
+</ul>
+
+
+<h2>Bug fixes</h2>
+<ul>
+<li>Fixed crash caused by glXCopyContext() and glXDestroyContext(), bug 24217
+<li>glXQueryContext(GLX_RENDER_TYPE) returned wrong values (bug 24211)
+<li>GLSL sqrt(0) returned unpredictable results
+<li>Fixed default texture binding bug when a bound texture was deleted.
+<li>r300: Work around an issue with very large fragment programs on R500.
+<li>Fake glXQueryDrawable() didn't return good values (bug 24320)
+<li>Fixed AUX buffer breakage (bug 24426).
+<li>Fixed locale-dependent float parsing bug in GLSL compiler (bug 24531)
+<li>Fixed Gallium Cell driver compilation failure.
+<li>Fixed glGetTexLevelParameter(GL_TEXTURE_INTERNAL_FORMAT) query so that
+    it returns the actual compressed format chosen.
+<li>Fixed glBitmap bugs in Intel drivers.
+<li>Fixed a number of Microsoft Visual Studio compilation problems.
+</ul>
+
+</body>
+</html>
diff --git a/docs/relnotes.html b/docs/relnotes.html
index 560a660..d8cbc79 100644
--- a/docs/relnotes.html
+++ b/docs/relnotes.html
@@ -13,6 +13,7 @@ The release notes summarize what's new or changed in each Mesa release.
 </p>
 
 <UL>
+<LI><A HREF="relnotes-7.6.1.html">7.6.1 release notes</A>
 <LI><A HREF="relnotes-7.6.html">7.6 release notes</A>
 <LI><A HREF="relnotes-7.5.2.html">7.5.2 release notes</A>
 <LI><A HREF="relnotes-7.5.1.html">7.5.1 release notes</A>
diff --git a/include/GL/gl_mangle.h b/include/GL/gl_mangle.h
index 54147f7..59f6149 100644
--- a/include/GL/gl_mangle.h
+++ b/include/GL/gl_mangle.h
@@ -108,12 +108,20 @@
 #define glBlendColorEXT		MANGLE(BlendColorEXT)
 #define glBlendColor		MANGLE(BlendColor)
 #define glBlendEquationEXT		MANGLE(BlendEquationEXT)
+#define glBlendEquationi		MANGLE(BlendEquationi)
+#define glBlendEquationIndexedAMD		MANGLE(BlendEquationIndexedAMD)
 #define glBlendEquation		MANGLE(BlendEquation)
 #define glBlendEquationSeparateATI		MANGLE(BlendEquationSeparateATI)
 #define glBlendEquationSeparateEXT		MANGLE(BlendEquationSeparateEXT)
+#define glBlendEquationSeparatei		MANGLE(BlendEquationSeparatei)
+#define glBlendEquationSeparateIndexedAMD		MANGLE(BlendEquationSeparateIndexedAMD)
 #define glBlendEquationSeparate		MANGLE(BlendEquationSeparate)
+#define glBlendFunci		MANGLE(BlendFunci)
+#define glBlendFuncIndexedAMD		MANGLE(BlendFuncIndexedAMD)
 #define glBlendFunc		MANGLE(BlendFunc)
 #define glBlendFuncSeparateEXT		MANGLE(BlendFuncSeparateEXT)
+#define glBlendFuncSeparatei		MANGLE(BlendFuncSeparatei)
+#define glBlendFuncSeparateIndexedAMD		MANGLE(BlendFuncSeparateIndexedAMD)
 #define glBlendFuncSeparateINGR		MANGLE(BlendFuncSeparateINGR)
 #define glBlendFuncSeparate		MANGLE(BlendFuncSeparate)
 #define glBlitFramebufferEXT		MANGLE(BlitFramebufferEXT)
@@ -148,6 +156,7 @@
 #define glClientActiveTexture		MANGLE(ClientActiveTexture)
 #define glClientActiveVertexStreamATI		MANGLE(ClientActiveVertexStreamATI)
 #define glClientAttribDefaultEXT		MANGLE(ClientAttribDefaultEXT)
+#define glClientWaitSync		MANGLE(ClientWaitSync)
 #define glClipPlane		MANGLE(ClipPlane)
 #define glColor3b		MANGLE(Color3b)
 #define glColor3bv		MANGLE(Color3bv)
@@ -320,6 +329,7 @@
 #define glDeleteRenderbuffersEXT		MANGLE(DeleteRenderbuffersEXT)
 #define glDeleteRenderbuffers		MANGLE(DeleteRenderbuffers)
 #define glDeleteShader		MANGLE(DeleteShader)
+#define glDeleteSync		MANGLE(DeleteSync)
 #define glDeleteTexturesEXT		MANGLE(DeleteTexturesEXT)
 #define glDeleteTextures		MANGLE(DeleteTextures)
 #define glDeleteTransformFeedbacksNV		MANGLE(DeleteTransformFeedbacksNV)
@@ -341,6 +351,7 @@
 #define glDisableIndexedEXT		MANGLE(DisableIndexedEXT)
 #define glDisable		MANGLE(Disable)
 #define glDisableVariantClientStateEXT		MANGLE(DisableVariantClientStateEXT)
+#define glDisableVertexAttribAPPLE		MANGLE(DisableVertexAttribAPPLE)
 #define glDisableVertexAttribArrayARB		MANGLE(DisableVertexAttribArrayARB)
 #define glDisableVertexAttribArray		MANGLE(DisableVertexAttribArray)
 #define glDrawArraysEXT		MANGLE(DrawArraysEXT)
@@ -354,7 +365,9 @@
 #define glDrawBuffers		MANGLE(DrawBuffers)
 #define glDrawElementArrayAPPLE		MANGLE(DrawElementArrayAPPLE)
 #define glDrawElementArrayATI		MANGLE(DrawElementArrayATI)
+#define glDrawElementsBaseVertex		MANGLE(DrawElementsBaseVertex)
 #define glDrawElementsInstancedARB		MANGLE(DrawElementsInstancedARB)
+#define glDrawElementsInstancedBaseVertex		MANGLE(DrawElementsInstancedBaseVertex)
 #define glDrawElementsInstancedEXT		MANGLE(DrawElementsInstancedEXT)
 #define glDrawElementsInstanced		MANGLE(DrawElementsInstanced)
 #define glDrawElements		MANGLE(DrawElements)
@@ -362,6 +375,7 @@
 #define glDrawPixels		MANGLE(DrawPixels)
 #define glDrawRangeElementArrayAPPLE		MANGLE(DrawRangeElementArrayAPPLE)
 #define glDrawRangeElementArrayATI		MANGLE(DrawRangeElementArrayATI)
+#define glDrawRangeElementsBaseVertex		MANGLE(DrawRangeElementsBaseVertex)
 #define glDrawRangeElementsEXT		MANGLE(DrawRangeElementsEXT)
 #define glDrawRangeElements		MANGLE(DrawRangeElements)
 #define glDrawTransformFeedbackNV		MANGLE(DrawTransformFeedbackNV)
@@ -378,6 +392,7 @@
 #define glEnableIndexedEXT		MANGLE(EnableIndexedEXT)
 #define glEnable		MANGLE(Enable)
 #define glEnableVariantClientStateEXT		MANGLE(EnableVariantClientStateEXT)
+#define glEnableVertexAttribAPPLE		MANGLE(EnableVertexAttribAPPLE)
 #define glEnableVertexAttribArrayARB		MANGLE(EnableVertexAttribArrayARB)
 #define glEnableVertexAttribArray		MANGLE(EnableVertexAttribArray)
 #define glEndConditionalRender		MANGLE(EndConditionalRender)
@@ -409,6 +424,7 @@
 #define glExecuteProgramNV		MANGLE(ExecuteProgramNV)
 #define glExtractComponentEXT		MANGLE(ExtractComponentEXT)
 #define glFeedbackBuffer		MANGLE(FeedbackBuffer)
+#define glFenceSync		MANGLE(FenceSync)
 #define glFinalCombinerInputNV		MANGLE(FinalCombinerInputNV)
 #define glFinishAsyncSGIX		MANGLE(FinishAsyncSGIX)
 #define glFinishFenceAPPLE		MANGLE(FinishFenceAPPLE)
@@ -469,9 +485,11 @@
 #define glFramebufferTextureEXT		MANGLE(FramebufferTextureEXT)
 #define glFramebufferTextureFaceARB		MANGLE(FramebufferTextureFaceARB)
 #define glFramebufferTextureFaceEXT		MANGLE(FramebufferTextureFaceEXT)
+#define glFramebufferTextureFace		MANGLE(FramebufferTextureFace)
 #define glFramebufferTextureLayerARB		MANGLE(FramebufferTextureLayerARB)
 #define glFramebufferTextureLayerEXT		MANGLE(FramebufferTextureLayerEXT)
 #define glFramebufferTextureLayer		MANGLE(FramebufferTextureLayer)
+#define glFramebufferTexture		MANGLE(FramebufferTexture)
 #define glFrameTerminatorGREMEDY		MANGLE(FrameTerminatorGREMEDY)
 #define glFrameZoomSGIX		MANGLE(FrameZoomSGIX)
 #define glFreeObjectBufferATI		MANGLE(FreeObjectBufferATI)
@@ -523,6 +541,7 @@
 #define glGetBooleanIndexedvEXT		MANGLE(GetBooleanIndexedvEXT)
 #define glGetBooleani_v		MANGLE(GetBooleani_v)
 #define glGetBooleanv		MANGLE(GetBooleanv)
+#define glGetBufferParameteri64v		MANGLE(GetBufferParameteri64v)
 #define glGetBufferParameterivARB		MANGLE(GetBufferParameterivARB)
 #define glGetBufferParameteriv		MANGLE(GetBufferParameteriv)
 #define glGetBufferPointervARB		MANGLE(GetBufferPointervARB)
@@ -586,6 +605,8 @@
 #define glGetImageTransformParameterivHP		MANGLE(GetImageTransformParameterivHP)
 #define glGetInfoLogARB		MANGLE(GetInfoLogARB)
 #define glGetInstrumentsSGIX		MANGLE(GetInstrumentsSGIX)
+#define glGetInteger64i_v		MANGLE(GetInteger64i_v)
+#define glGetInteger64v		MANGLE(GetInteger64v)
 #define glGetIntegerIndexedvEXT		MANGLE(GetIntegerIndexedvEXT)
 #define glGetIntegeri_v		MANGLE(GetIntegeri_v)
 #define glGetIntegerv		MANGLE(GetIntegerv)
@@ -615,6 +636,7 @@
 #define glGetMinmaxParameterfv		MANGLE(GetMinmaxParameterfv)
 #define glGetMinmaxParameterivEXT		MANGLE(GetMinmaxParameterivEXT)
 #define glGetMinmaxParameteriv		MANGLE(GetMinmaxParameteriv)
+#define glGetMultisamplefv		MANGLE(GetMultisamplefv)
 #define glGetMultisamplefvNV		MANGLE(GetMultisamplefvNV)
 #define glGetMultiTexEnvfvEXT		MANGLE(GetMultiTexEnvfvEXT)
 #define glGetMultiTexEnvivEXT		MANGLE(GetMultiTexEnvivEXT)
@@ -642,6 +664,7 @@
 #define glGetObjectBufferfvATI		MANGLE(GetObjectBufferfvATI)
 #define glGetObjectBufferivATI		MANGLE(GetObjectBufferivATI)
 #define glGetObjectParameterfvARB		MANGLE(GetObjectParameterfvARB)
+#define glGetObjectParameterivAPPLE		MANGLE(GetObjectParameterivAPPLE)
 #define glGetObjectParameterivARB		MANGLE(GetObjectParameterivARB)
 #define glGetOcclusionQueryivNV		MANGLE(GetOcclusionQueryivNV)
 #define glGetOcclusionQueryuivNV		MANGLE(GetOcclusionQueryuivNV)
@@ -698,6 +721,7 @@
 #define glGetSharpenTexFuncSGIS		MANGLE(GetSharpenTexFuncSGIS)
 #define glGetStringi		MANGLE(GetStringi)
 #define glGetString		MANGLE(GetString)
+#define glGetSynciv		MANGLE(GetSynciv)
 #define glGetTexBumpParameterfvATI		MANGLE(GetTexBumpParameterfvATI)
 #define glGetTexBumpParameterivATI		MANGLE(GetTexBumpParameterivATI)
 #define glGetTexEnvfv		MANGLE(GetTexEnvfv)
@@ -715,6 +739,7 @@
 #define glGetTexParameterIuivEXT		MANGLE(GetTexParameterIuivEXT)
 #define glGetTexParameterIuiv		MANGLE(GetTexParameterIuiv)
 #define glGetTexParameteriv		MANGLE(GetTexParameteriv)
+#define glGetTexParameterPointervAPPLE		MANGLE(GetTexParameterPointervAPPLE)
 #define glGetTextureImageEXT		MANGLE(GetTextureImageEXT)
 #define glGetTextureLevelParameterfvEXT		MANGLE(GetTextureLevelParameterfvEXT)
 #define glGetTextureLevelParameterivEXT		MANGLE(GetTextureLevelParameterivEXT)
@@ -825,12 +850,14 @@
 #define glIsRenderbufferEXT		MANGLE(IsRenderbufferEXT)
 #define glIsRenderbuffer		MANGLE(IsRenderbuffer)
 #define glIsShader		MANGLE(IsShader)
+#define glIsSync		MANGLE(IsSync)
 #define glIsTextureEXT		MANGLE(IsTextureEXT)
 #define glIsTexture		MANGLE(IsTexture)
 #define glIsTransformFeedbackNV		MANGLE(IsTransformFeedbackNV)
 #define glIsVariantEnabledEXT		MANGLE(IsVariantEnabledEXT)
 #define glIsVertexArrayAPPLE		MANGLE(IsVertexArrayAPPLE)
 #define glIsVertexArray		MANGLE(IsVertexArray)
+#define glIsVertexAttribEnabledAPPLE		MANGLE(IsVertexAttribEnabledAPPLE)
 #define glLightEnviSGIX		MANGLE(LightEnviSGIX)
 #define glLightf		MANGLE(Lightf)
 #define glLightfv		MANGLE(Lightfv)
@@ -877,6 +904,10 @@
 #define glMapObjectBufferATI		MANGLE(MapObjectBufferATI)
 #define glMapParameterfvNV		MANGLE(MapParameterfvNV)
 #define glMapParameterivNV		MANGLE(MapParameterivNV)
+#define glMapVertexAttrib1dAPPLE		MANGLE(MapVertexAttrib1dAPPLE)
+#define glMapVertexAttrib1fAPPLE		MANGLE(MapVertexAttrib1fAPPLE)
+#define glMapVertexAttrib2dAPPLE		MANGLE(MapVertexAttrib2dAPPLE)
+#define glMapVertexAttrib2fAPPLE		MANGLE(MapVertexAttrib2fAPPLE)
 #define glMaterialf		MANGLE(Materialf)
 #define glMaterialfv		MANGLE(Materialfv)
 #define glMateriali		MANGLE(Materiali)
@@ -907,9 +938,11 @@
 #define glMatrixTranslatefEXT		MANGLE(MatrixTranslatefEXT)
 #define glMinmaxEXT		MANGLE(MinmaxEXT)
 #define glMinmax		MANGLE(Minmax)
+#define glMinSampleShading		MANGLE(MinSampleShading)
 #define glMultiDrawArraysEXT		MANGLE(MultiDrawArraysEXT)
 #define glMultiDrawArrays		MANGLE(MultiDrawArrays)
 #define glMultiDrawElementArrayAPPLE		MANGLE(MultiDrawElementArrayAPPLE)
+#define glMultiDrawElementsBaseVertex		MANGLE(MultiDrawElementsBaseVertex)
 #define glMultiDrawElementsEXT		MANGLE(MultiDrawElementsEXT)
 #define glMultiDrawElements		MANGLE(MultiDrawElements)
 #define glMultiDrawRangeElementArrayAPPLE		MANGLE(MultiDrawRangeElementArrayAPPLE)
@@ -1072,6 +1105,8 @@
 #define glNormalStream3ivATI		MANGLE(NormalStream3ivATI)
 #define glNormalStream3sATI		MANGLE(NormalStream3sATI)
 #define glNormalStream3svATI		MANGLE(NormalStream3svATI)
+#define glObjectPurgeableAPPLE		MANGLE(ObjectPurgeableAPPLE)
+#define glObjectUnpurgeableAPPLE		MANGLE(ObjectUnpurgeableAPPLE)
 #define glOrtho		MANGLE(Ortho)
 #define glPassTexCoordATI		MANGLE(PassTexCoordATI)
 #define glPassThrough		MANGLE(PassThrough)
@@ -1162,6 +1197,7 @@
 #define glProgramParameter4fvNV		MANGLE(ProgramParameter4fvNV)
 #define glProgramParameteriARB		MANGLE(ProgramParameteriARB)
 #define glProgramParameteriEXT		MANGLE(ProgramParameteriEXT)
+#define glProgramParameteri		MANGLE(ProgramParameteri)
 #define glProgramParameters4dvNV		MANGLE(ProgramParameters4dvNV)
 #define glProgramParameters4fvNV		MANGLE(ProgramParameters4fvNV)
 #define glProgramStringARB		MANGLE(ProgramStringARB)
@@ -1200,6 +1236,7 @@
 #define glProgramUniformMatrix4x3fvEXT		MANGLE(ProgramUniformMatrix4x3fvEXT)
 #define glProgramVertexLimitNV		MANGLE(ProgramVertexLimitNV)
 #define glProvokingVertexEXT		MANGLE(ProvokingVertexEXT)
+#define glProvokingVertex		MANGLE(ProvokingVertex)
 #define glPushAttrib		MANGLE(PushAttrib)
 #define glPushClientAttribDefaultEXT		MANGLE(PushClientAttribDefaultEXT)
 #define glPushClientAttrib		MANGLE(PushClientAttrib)
@@ -1283,6 +1320,7 @@
 #define glSampleCoverage		MANGLE(SampleCoverage)
 #define glSampleMapATI		MANGLE(SampleMapATI)
 #define glSampleMaskEXT		MANGLE(SampleMaskEXT)
+#define glSampleMaski		MANGLE(SampleMaski)
 #define glSampleMaskIndexedNV		MANGLE(SampleMaskIndexedNV)
 #define glSampleMaskSGIS		MANGLE(SampleMaskSGIS)
 #define glSamplePatternEXT		MANGLE(SamplePatternEXT)
@@ -1454,8 +1492,10 @@
 #define glTexGeniv		MANGLE(TexGeniv)
 #define glTexImage1D		MANGLE(TexImage1D)
 #define glTexImage2D		MANGLE(TexImage2D)
+#define glTexImage2DMultisample		MANGLE(TexImage2DMultisample)
 #define glTexImage3DEXT		MANGLE(TexImage3DEXT)
 #define glTexImage3D		MANGLE(TexImage3D)
+#define glTexImage3DMultisample		MANGLE(TexImage3DMultisample)
 #define glTexImage4DSGIS		MANGLE(TexImage4DSGIS)
 #define glTexParameterf		MANGLE(TexParameterf)
 #define glTexParameterfv		MANGLE(TexParameterfv)
@@ -1487,6 +1527,7 @@
 #define glTextureParameterIivEXT		MANGLE(TextureParameterIivEXT)
 #define glTextureParameterIuivEXT		MANGLE(TextureParameterIuivEXT)
 #define glTextureParameterivEXT		MANGLE(TextureParameterivEXT)
+#define glTextureRangeAPPLE		MANGLE(TextureRangeAPPLE)
 #define glTextureRenderbufferEXT		MANGLE(TextureRenderbufferEXT)
 #define glTextureSubImage1DEXT		MANGLE(TextureSubImage1DEXT)
 #define glTextureSubImage2DEXT		MANGLE(TextureSubImage2DEXT)
@@ -1828,6 +1869,7 @@
 #define glVertexWeighthvNV		MANGLE(VertexWeighthvNV)
 #define glVertexWeightPointerEXT		MANGLE(VertexWeightPointerEXT)
 #define glViewport		MANGLE(Viewport)
+#define glWaitSync		MANGLE(WaitSync)
 #define glWeightbvARB		MANGLE(WeightbvARB)
 #define glWeightdvARB		MANGLE(WeightdvARB)
 #define glWeightfvARB		MANGLE(WeightfvARB)
diff --git a/include/GL/glext.h b/include/GL/glext.h
index 24e6c5d..473b22a 100644
--- a/include/GL/glext.h
+++ b/include/GL/glext.h
@@ -29,9 +29,9 @@ extern "C" {
 */
 
 /* Header file version number, required by OpenGL ABI for Linux */
-/* glext.h last updated $Date$ */
+/* glext.h last updated $Date$ */
 /* Current version at http://www.opengl.org/registry/ */
-#define GL_GLEXT_VERSION 54
+#define GL_GLEXT_VERSION 56
 
 /* Function declaration macros - to move into glplatform.h */
 
@@ -4236,7 +4236,7 @@ extern "C" {
 #define GL_LUMINANCE16_SNORM              0x9019
 #define GL_LUMINANCE16_ALPHA16_SNORM      0x901A
 #define GL_INTENSITY16_SNORM              0x901B
-/* reuse GL_R_SNORM */
+/* reuse GL_RED_SNORM */
 /* reuse GL_RG_SNORM */
 /* reuse GL_RGB_SNORM */
 /* reuse GL_RGBA_SNORM */
@@ -4311,6 +4311,88 @@ extern "C" {
 #define GL_UNPACK_ROW_BYTES_APPLE         0x8A16
 #endif
 
+#ifndef GL_APPLE_rgb_422
+#define GL_RGB_422_APPLE                  0x8A1F
+/* reuse GL_UNSIGNED_SHORT_8_8_APPLE */
+/* reuse GL_UNSIGNED_SHORT_8_8_REV_APPLE */
+#endif
+
+#ifndef GL_NV_video_capture
+#define GL_VIDEO_BUFFER_NV                0x9020
+#define GL_VIDEO_BUFFER_BINDING_NV        0x9021
+#define GL_FIELD_UPPER_NV                 0x9022
+#define GL_FIELD_LOWER_NV                 0x9023
+#define GL_NUM_VIDEO_CAPTURE_STREAMS_NV   0x9024
+#define GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV 0x9025
+#define GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV 0x9026
+#define GL_LAST_VIDEO_CAPTURE_STATUS_NV   0x9027
+#define GL_VIDEO_BUFFER_PITCH_NV          0x9028
+#define GL_VIDEO_COLOR_CONVERSION_MATRIX_NV 0x9029
+#define GL_VIDEO_COLOR_CONVERSION_MAX_NV  0x902A
+#define GL_VIDEO_COLOR_CONVERSION_MIN_NV  0x902B
+#define GL_VIDEO_COLOR_CONVERSION_OFFSET_NV 0x902C
+#define GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV 0x902D
+#define GL_PARTIAL_SUCCESS_NV             0x902E
+#define GL_SUCCESS_NV                     0x902F
+#define GL_FAILURE_NV                     0x9030
+#define GL_YCBYCR8_422_NV                 0x9031
+#define GL_YCBAYCR8A_4224_NV              0x9032
+#define GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV  0x9033
+#define GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV 0x9034
+#define GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV  0x9035
+#define GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV 0x9036
+#define GL_Z4Y12Z4CB12Z4CR12_444_NV       0x9037
+#define GL_VIDEO_CAPTURE_FRAME_WIDTH_NV   0x9038
+#define GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV  0x9039
+#define GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV 0x903A
+#define GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV 0x903B
+#define GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV 0x903C
+#endif
+
+#ifndef GL_NV_copy_image
+#endif
+
+#ifndef GL_EXT_separate_shader_objects
+#define GL_ACTIVE_PROGRAM_EXT             0x8B8D
+#endif
+
+#ifndef GL_NV_parameter_buffer_object2
+#endif
+
+#ifndef GL_NV_shader_buffer_load
+#define GL_BUFFER_GPU_ADDRESS_NV          0x8F1D
+#define GL_GPU_ADDRESS_NV                 0x8F34
+#define GL_MAX_SHADER_BUFFER_ADDRESS_NV   0x8F35
+#endif
+
+#ifndef GL_NV_vertex_buffer_unified_memory
+#define GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV 0x8F1E
+#define GL_ELEMENT_ARRAY_UNIFIED_NV       0x8F1F
+#define GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV 0x8F20
+#define GL_VERTEX_ARRAY_ADDRESS_NV        0x8F21
+#define GL_NORMAL_ARRAY_ADDRESS_NV        0x8F22
+#define GL_COLOR_ARRAY_ADDRESS_NV         0x8F23
+#define GL_INDEX_ARRAY_ADDRESS_NV         0x8F24
+#define GL_TEXTURE_COORD_ARRAY_ADDRESS_NV 0x8F25
+#define GL_EDGE_FLAG_ARRAY_ADDRESS_NV     0x8F26
+#define GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV 0x8F27
+#define GL_FOG_COORD_ARRAY_ADDRESS_NV     0x8F28
+#define GL_ELEMENT_ARRAY_ADDRESS_NV       0x8F29
+#define GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV  0x8F2A
+#define GL_VERTEX_ARRAY_LENGTH_NV         0x8F2B
+#define GL_NORMAL_ARRAY_LENGTH_NV         0x8F2C
+#define GL_COLOR_ARRAY_LENGTH_NV          0x8F2D
+#define GL_INDEX_ARRAY_LENGTH_NV          0x8F2E
+#define GL_TEXTURE_COORD_ARRAY_LENGTH_NV  0x8F2F
+#define GL_EDGE_FLAG_ARRAY_LENGTH_NV      0x8F30
+#define GL_SECONDARY_COLOR_ARRAY_LENGTH_NV 0x8F31
+#define GL_FOG_COORD_ARRAY_LENGTH_NV      0x8F32
+#define GL_ELEMENT_ARRAY_LENGTH_NV        0x8F33
+#endif
+
+#ifndef GL_NV_texture_barrier
+#endif
+
 
 /*************************************************************/
 
@@ -9245,6 +9327,136 @@ typedef void (APIENTRYP PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType,
 #define GL_APPLE_row_bytes 1
 #endif
 
+#ifndef GL_APPLE_rgb_422
+#define GL_APPLE_rgb_422 1
+#endif
+
+#ifndef GL_NV_video_capture
+#define GL_NV_video_capture 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBeginVideoCaptureNV (GLuint);
+GLAPI void APIENTRY glBindVideoCaptureStreamBufferNV (GLuint, GLuint, GLenum, GLintptrARB);
+GLAPI void APIENTRY glBindVideoCaptureStreamTextureNV (GLuint, GLuint, GLenum, GLenum, GLuint);
+GLAPI void APIENTRY glEndVideoCaptureNV (GLuint);
+GLAPI void APIENTRY glGetVideoCaptureivNV (GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetVideoCaptureStreamivNV (GLuint, GLuint, GLenum, GLint *);
+GLAPI void APIENTRY glGetVideoCaptureStreamfvNV (GLuint, GLuint, GLenum, GLfloat *);
+GLAPI void APIENTRY glGetVideoCaptureStreamdvNV (GLuint, GLuint, GLenum, GLdouble *);
+GLAPI GLenum APIENTRY glVideoCaptureNV (GLuint, GLuint *, GLuint64EXT *);
+GLAPI void APIENTRY glVideoCaptureStreamParameterivNV (GLuint, GLuint, GLenum, const GLint *);
+GLAPI void APIENTRY glVideoCaptureStreamParameterfvNV (GLuint, GLuint, GLenum, const GLfloat *);
+GLAPI void APIENTRY glVideoCaptureStreamParameterdvNV (GLuint, GLuint, GLenum, const GLdouble *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
+typedef void (APIENTRYP PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
+typedef void (APIENTRYP PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
+typedef void (APIENTRYP PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
+typedef void (APIENTRYP PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params);
+typedef void (APIENTRYP PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params);
+typedef GLenum (APIENTRYP PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time);
+typedef void (APIENTRYP PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params);
+typedef void (APIENTRYP PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params);
+typedef void (APIENTRYP PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params);
+#endif
+
+#ifndef GL_NV_copy_image
+#define GL_NV_copy_image 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glCopyImageSubDataNV (GLuint, GLenum, GLint, GLint, GLint, GLint, GLuint, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
+#endif
+
+#ifndef GL_EXT_separate_shader_objects
+#define GL_EXT_separate_shader_objects 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glUseShaderProgramEXT (GLenum, GLuint);
+GLAPI void APIENTRY glActiveProgramEXT (GLuint);
+GLAPI GLuint APIENTRY glCreateShaderProgramEXT (GLenum, const GLchar *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);
+typedef void (APIENTRYP PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
+typedef GLuint (APIENTRYP PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar *string);
+#endif
+
+#ifndef GL_NV_parameter_buffer_object2
+#define GL_NV_parameter_buffer_object2 1
+#endif
+
+#ifndef GL_NV_shader_buffer_load
+#define GL_NV_shader_buffer_load 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glMakeBufferResidentNV (GLenum, GLenum);
+GLAPI void APIENTRY glMakeBufferNonResidentNV (GLenum);
+GLAPI GLboolean APIENTRY glIsBufferResidentNV (GLenum);
+GLAPI void APIENTRY glNamedMakeBufferResidentNV (GLuint, GLenum);
+GLAPI void APIENTRY glNamedMakeBufferNonResidentNV (GLuint);
+GLAPI GLboolean APIENTRY glIsNamedBufferResidentNV (GLuint);
+GLAPI void APIENTRY glGetBufferParameterui64vNV (GLenum, GLenum, GLuint64EXT *);
+GLAPI void APIENTRY glGetNamedBufferParameterui64vNV (GLuint, GLenum, GLuint64EXT *);
+GLAPI void APIENTRY glGetIntegerui64vNV (GLenum, GLuint64EXT *);
+GLAPI void APIENTRY glUniformui64NV (GLint, GLuint64EXT);
+GLAPI void APIENTRY glUniformui64vNV (GLint, GLsizei, const GLuint64EXT *);
+GLAPI void APIENTRY glGetUniformui64vNV (GLuint, GLint, GLuint64EXT *);
+GLAPI void APIENTRY glProgramUniformui64NV (GLuint, GLint, GLuint64EXT);
+GLAPI void APIENTRY glProgramUniformui64vNV (GLuint, GLint, GLsizei, const GLuint64EXT *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
+typedef void (APIENTRYP PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
+typedef GLboolean (APIENTRYP PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
+typedef void (APIENTRYP PFNGLNAMEDMAKEBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
+typedef void (APIENTRYP PFNGLNAMEDMAKEBUFFERNONRESIDENTNVPROC) (GLuint buffer);
+typedef GLboolean (APIENTRYP PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
+typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT *params);
+typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT *params);
+typedef void (APIENTRYP PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT *result);
+typedef void (APIENTRYP PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
+typedef void (APIENTRYP PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT *value);
+typedef void (APIENTRYP PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT *params);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT *value);
+#endif
+
+#ifndef GL_NV_vertex_buffer_unified_memory
+#define GL_NV_vertex_buffer_unified_memory 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBufferAddressRangeNV (GLenum, GLuint, GLuint64EXT, GLsizeiptr);
+GLAPI void APIENTRY glVertexFormatNV (GLint, GLenum, GLsizei);
+GLAPI void APIENTRY glNormalFormatNV (GLenum, GLsizei);
+GLAPI void APIENTRY glColorFormatNV (GLint, GLenum, GLsizei);
+GLAPI void APIENTRY glIndexFormatNV (GLenum, GLsizei);
+GLAPI void APIENTRY glTexCoordFormatNV (GLint, GLenum, GLsizei);
+GLAPI void APIENTRY glEdgeFlagFormatNV (GLsizei);
+GLAPI void APIENTRY glSecondaryColorFormatNV (GLint, GLenum, GLsizei);
+GLAPI void APIENTRY glFogCoordFormatNV (GLenum, GLsizei);
+GLAPI void APIENTRY glVertexAttribFormatNV (GLuint, GLint, GLenum, GLboolean, GLsizei);
+GLAPI void APIENTRY glVertexAttribIFormatNV (GLuint, GLint, GLenum, GLsizei);
+GLAPI void APIENTRY glGetIntegerui64i_vNV (GLenum, GLuint, GLuint64EXT *);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
+typedef void (APIENTRYP PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
+typedef void (APIENTRYP PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
+typedef void (APIENTRYP PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
+typedef void (APIENTRYP PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
+typedef void (APIENTRYP PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
+typedef void (APIENTRYP PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
+typedef void (APIENTRYP PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
+typedef void (APIENTRYP PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
+typedef void (APIENTRYP PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT *result);
+#endif
+
+#ifndef GL_NV_texture_barrier
+#define GL_NV_texture_barrier 1
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTextureBarrierNV (void);
+#endif /* GL_GLEXT_PROTOTYPES */
+typedef void (APIENTRYP PFNGLTEXTUREBARRIERNVPROC) (void);
+#endif
+
 
 #ifdef __cplusplus
 }
diff --git a/include/GL/glxext.h b/include/GL/glxext.h
index eac09f9..9ac0592 100644
--- a/include/GL/glxext.h
+++ b/include/GL/glxext.h
@@ -48,9 +48,9 @@ extern "C" {
 /*************************************************************/
 
 /* Header file version number, required by OpenGL ABI for Linux */
-/* glxext.h last updated 2009/08/03 */
+/* glxext.h last updated 2009/10/08 */
 /* Current version at http://www.opengl.org/registry/ */
-#define GLX_GLXEXT_VERSION 23
+#define GLX_GLXEXT_VERSION 25
 
 #ifndef GLX_VERSION_1_3
 #define GLX_WINDOW_BIT                     0x00000001
@@ -382,6 +382,20 @@ extern "C" {
 #ifndef GLX_NV_swap_group
 #endif
 
+#ifndef GLX_NV_video_capture
+#define GLX_DEVICE_ID_NV                   0x20CD
+#define GLX_UNIQUE_ID_NV                   0x20CE
+#define GLX_NUM_VIDEO_CAPTURE_SLOTS_NV     0x20CF
+#endif
+
+#ifndef GLX_EXT_swap_control
+#define GLX_SWAP_INTERVAL_EXT              0x20F1
+#define GLX_MAX_SWAP_INTERVAL_EXT          0x20F2
+#endif
+
+#ifndef GLX_NV_copy_image
+#endif
+
 
 /*************************************************************/
 
@@ -415,6 +429,14 @@ typedef struct {
 } GLXBufferClobberEventSGIX;
 #endif
 
+#ifndef GLX_NV_video_output
+typedef unsigned int GLXVideoDeviceNV;
+#endif
+
+#ifndef GLX_NV_video_capture
+typedef XID GLXVideoCaptureDeviceNV;
+#endif
+
 #ifndef GLEXT_64_TYPES_DEFINED
 /* This code block is duplicated in glext.h, so must be protected */
 #define GLEXT_64_TYPES_DEFINED
@@ -827,14 +849,80 @@ typedef void ( * PFNGLXRELEASETEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawab
 
 #ifndef GLX_NV_present_video
 #define GLX_NV_present_video 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+extern unsigned int * glXEnumerateVideoDevicesNV (Display *, int, int *);
+extern int glXBindVideoDeviceNV (Display *, unsigned int, unsigned int, const int *);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+typedef unsigned int * ( * PFNGLXENUMERATEVIDEODEVICESNVPROC) (Display *dpy, int screen, int *nelements);
+typedef int ( * PFNGLXBINDVIDEODEVICENVPROC) (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
 #endif
 
-#ifndef GLX_NV_video_out
-#define GLX_NV_video_out 1
+#ifndef GLX_NV_video_output
+#define GLX_NV_video_output 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+extern int glXGetVideoDeviceNV (Display *, int, int, GLXVideoDeviceNV *);
+extern int glXReleaseVideoDeviceNV (Display *, int, GLXVideoDeviceNV);
+extern int glXBindVideoImageNV (Display *, GLXVideoDeviceNV, GLXPbuffer, int);
+extern int glXReleaseVideoImageNV (Display *, GLXPbuffer);
+extern int glXSendPbufferToVideoNV (Display *, GLXPbuffer, int, unsigned long *, GLboolean);
+extern int glXGetVideoInfoNV (Display *, int, GLXVideoDeviceNV, unsigned long *, unsigned long *);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+typedef int ( * PFNGLXGETVIDEODEVICENVPROC) (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
+typedef int ( * PFNGLXRELEASEVIDEODEVICENVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
+typedef int ( * PFNGLXBINDVIDEOIMAGENVPROC) (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
+typedef int ( * PFNGLXRELEASEVIDEOIMAGENVPROC) (Display *dpy, GLXPbuffer pbuf);
+typedef int ( * PFNGLXSENDPBUFFERTOVIDEONVPROC) (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
+typedef int ( * PFNGLXGETVIDEOINFONVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
 #endif
 
 #ifndef GLX_NV_swap_group
 #define GLX_NV_swap_group 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+extern Bool glXJoinSwapGroupNV (Display *, GLXDrawable, GLuint);
+extern Bool glXBindSwapBarrierNV (Display *, GLuint, GLuint);
+extern Bool glXQuerySwapGroupNV (Display *, GLXDrawable, GLuint *, GLuint *);
+extern Bool glXQueryMaxSwapGroupsNV (Display *, int, GLuint *, GLuint *);
+extern Bool glXQueryFrameCountNV (Display *, int, GLuint *);
+extern Bool glXResetFrameCountNV (Display *, int);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+typedef Bool ( * PFNGLXJOINSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint group);
+typedef Bool ( * PFNGLXBINDSWAPBARRIERNVPROC) (Display *dpy, GLuint group, GLuint barrier);
+typedef Bool ( * PFNGLXQUERYSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
+typedef Bool ( * PFNGLXQUERYMAXSWAPGROUPSNVPROC) (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
+typedef Bool ( * PFNGLXQUERYFRAMECOUNTNVPROC) (Display *dpy, int screen, GLuint *count);
+typedef Bool ( * PFNGLXRESETFRAMECOUNTNVPROC) (Display *dpy, int screen);
+#endif
+
+#ifndef GLX_NV_video_capture
+#define GLX_NV_video_capture 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+extern int glXBindVideoCaptureDeviceNV (Display *, unsigned int, GLXVideoCaptureDeviceNV);
+extern GLXVideoCaptureDeviceNV * glXEnumerateVideoCaptureDevicesNV (Display *, int, int *);
+extern void glXLockVideoCaptureDeviceNV (Display *, GLXVideoCaptureDeviceNV);
+extern int glXQueryVideoCaptureDeviceNV (Display *, GLXVideoCaptureDeviceNV, int, int *);
+extern void glXReleaseVideoCaptureDeviceNV (Display *, GLXVideoCaptureDeviceNV);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+typedef int ( * PFNGLXBINDVIDEOCAPTUREDEVICENVPROC) (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
+typedef GLXVideoCaptureDeviceNV * ( * PFNGLXENUMERATEVIDEOCAPTUREDEVICESNVPROC) (Display *dpy, int screen, int *nelements);
+typedef void ( * PFNGLXLOCKVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
+typedef int ( * PFNGLXQUERYVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
+typedef void ( * PFNGLXRELEASEVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
+#endif
+
+#ifndef GLX_EXT_swap_control
+#define GLX_EXT_swap_control 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+extern int glXSwapIntervalEXT (Display *, GLXDrawable, int);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+typedef int ( * PFNGLXSWAPINTERVALEXTPROC) (Display *dpy, GLXDrawable drawable, int interval);
+#endif
+
+#ifndef GLX_NV_copy_image
+#define GLX_NV_copy_image 1
+#ifdef GLX_GLXEXT_PROTOTYPES
+extern void glXCopyImageSubDataNV (Display *, GLXContext, GLuint, GLenum, GLint, GLint, GLint, GLint, GLXContext, GLuint, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei);
+#endif /* GLX_GLXEXT_PROTOTYPES */
+typedef void ( * PFNGLXCOPYIMAGESUBDATANVPROC) (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
 #endif
 
 
diff --git a/include/GL/wglext.h b/include/GL/wglext.h
index 1f096fb..df96fbe 100644
--- a/include/GL/wglext.h
+++ b/include/GL/wglext.h
@@ -48,9 +48,9 @@ extern "C" {
 /*************************************************************/
 
 /* Header file version number */
-/* wglext.h last updated 2009/08/03 */
+/* wglext.h last updated 2009/09/16 */
 /* Current version at http://www.opengl.org/registry/ */
-#define WGL_WGLEXT_VERSION 15
+#define WGL_WGLEXT_VERSION 17
 
 #ifndef WGL_ARB_buffer_region
 #define WGL_FRONT_COLOR_BUFFER_BIT_ARB 0x00000001
@@ -388,6 +388,14 @@ extern "C" {
 #define WGL_GPU_NUM_SPI_AMD            0x21A8
 #endif
 
+#ifndef NV_video_capture
+#define WGL_UNIQUE_ID_NV               0x20CE
+#define WGL_NUM_VIDEO_CAPTURE_SLOTS_NV 0x20CF
+#endif
+
+#ifndef NV_copy_image
+#endif
+
 
 /*************************************************************/
 
@@ -400,7 +408,7 @@ DECLARE_HANDLE(HPBUFFEREXT);
 #ifndef WGL_NV_present_video
 DECLARE_HANDLE(HVIDEOOUTPUTDEVICENV);
 #endif
-#ifndef WGL_NV_video_out
+#ifndef WGL_NV_video_output
 DECLARE_HANDLE(HPVIDEODEV);
 #endif
 #ifndef WGL_NV_gpu_affinity
@@ -415,6 +423,9 @@ typedef struct _GPU_DEVICE {
     RECT   rcVirtualScreen;
 } GPU_DEVICE, *PGPU_DEVICE;
 #endif
+#ifndef WGL_NV_video_capture
+DECLARE_HANDLE(HVIDEOINPUTDEVICENV);
+#endif
 
 #ifndef WGL_ARB_buffer_region
 #define WGL_ARB_buffer_region 1
@@ -750,8 +761,8 @@ typedef BOOL (WINAPI * PFNWGLBINDVIDEODEVICENVPROC) (HDC hDC, unsigned int uVide
 typedef BOOL (WINAPI * PFNWGLQUERYCURRENTCONTEXTNVPROC) (int iAttribute, int *piValue);
 #endif
 
-#ifndef WGL_NV_video_out
-#define WGL_NV_video_out 1
+#ifndef WGL_NV_video_output
+#define WGL_NV_video_output 1
 #ifdef WGL_WGLEXT_PROTOTYPES
 extern BOOL WINAPI wglGetVideoDeviceNV (HDC, int, HPVIDEODEV *);
 extern BOOL WINAPI wglReleaseVideoDeviceNV (HPVIDEODEV);
@@ -826,6 +837,30 @@ typedef HGLRC (WINAPI * PFNWGLGETCURRENTASSOCIATEDCONTEXTAMDPROC) (void);
 typedef VOID (WINAPI * PFNWGLBLITCONTEXTFRAMEBUFFERAMDPROC) (HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
 #endif
 
+#ifndef WGL_NV_video_capture
+#define WGL_NV_video_capture 1
+#ifdef WGL_WGLEXT_PROTOTYPES
+extern BOOL WINAPI wglBindVideoCaptureDeviceNV (UINT, HVIDEOINPUTDEVICENV);
+extern UINT WINAPI wglEnumerateVideoCaptureDevicesNV (HDC, HVIDEOINPUTDEVICENV *);
+extern BOOL WINAPI wglLockVideoCaptureDeviceNV (HDC, HVIDEOINPUTDEVICENV);
+extern BOOL WINAPI wglQueryVideoCaptureDeviceNV (HDC, HVIDEOINPUTDEVICENV, int, int *);
+extern BOOL WINAPI wglReleaseVideoCaptureDeviceNV (HDC, HVIDEOINPUTDEVICENV);
+#endif /* WGL_WGLEXT_PROTOTYPES */
+typedef BOOL (WINAPI * PFNWGLBINDVIDEOCAPTUREDEVICENVPROC) (UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice);
+typedef UINT (WINAPI * PFNWGLENUMERATEVIDEOCAPTUREDEVICESNVPROC) (HDC hDc, HVIDEOINPUTDEVICENV *phDeviceList);
+typedef BOOL (WINAPI * PFNWGLLOCKVIDEOCAPTUREDEVICENVPROC) (HDC hDc, HVIDEOINPUTDEVICENV hDevice);
+typedef BOOL (WINAPI * PFNWGLQUERYVIDEOCAPTUREDEVICENVPROC) (HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue);
+typedef BOOL (WINAPI * PFNWGLRELEASEVIDEOCAPTUREDEVICENVPROC) (HDC hDc, HVIDEOINPUTDEVICENV hDevice);
+#endif
+
+#ifndef WGL_NV_copy_image
+#define WGL_NV_copy_image 1
+#ifdef WGL_WGLEXT_PROTOTYPES
+extern BOOL WINAPI wglCopyImageSubDataNV (HGLRC, GLuint, GLenum, GLint, GLint, GLint, GLint, HGLRC, GLuint, GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei);
+#endif /* WGL_WGLEXT_PROTOTYPES */
+typedef BOOL (WINAPI * PFNWGLCOPYIMAGESUBDATANVPROC) (HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
+#endif
+
 
 #ifdef __cplusplus
 }
diff --git a/progs/Makefile b/progs/Makefile
index c99f4ee..3700707 100644
--- a/progs/Makefile
+++ b/progs/Makefile
@@ -15,18 +15,22 @@ message:
 
 
 subdirs:
-	@for dir in $(SUBDIRS) ; do \
-		if [ -d $$dir ] ; then \
-			(cd $$dir && $(MAKE)) || exit 1 ; \
-		fi \
-	done
+	@if test -n "$(SUBDIRS)" ; then \
+		for dir in $(SUBDIRS) ; do \
+			if [ -d $$dir ] ; then \
+				(cd $$dir && $(MAKE)) || exit 1 ; \
+			fi \
+		done \
+	fi
 
 # Dummy install target
 install:
 
 clean:
-	-@for dir in $(SUBDIRS) tests ; do \
-		if [ -d $$dir ] ; then \
-			(cd $$dir && $(MAKE) clean) ; \
-		fi \
-	done
+	-@if test -n "$(SUBDIRS)" ; then \
+		for dir in $(SUBDIRS) tests ; do \
+			if [ -d $$dir ] ; then \
+				(cd $$dir && $(MAKE) clean) ; \
+			fi \
+		done \
+	fi
diff --git a/progs/glsl/skinning.c b/progs/glsl/skinning.c
index 65ba983..2b96f31 100644
--- a/progs/glsl/skinning.c
+++ b/progs/glsl/skinning.c
@@ -16,6 +16,9 @@
 #include <GL/glut.h>
 #include "shaderutil.h"
 
+#ifndef M_PI
+#define M_PI 3.1415926535
+#endif
 
 static char *FragProgFile = "skinning.frag";
 static char *VertProgFile = "skinning.vert";
diff --git a/progs/glsl/texaaline.c b/progs/glsl/texaaline.c
index 7a5ac40..2e4f932 100644
--- a/progs/glsl/texaaline.c
+++ b/progs/glsl/texaaline.c
@@ -14,6 +14,9 @@
 #include <GL/glew.h>
 #include <GL/glut.h>
 
+#ifndef M_PI
+#define M_PI 3.1415926535
+#endif
 
 static GLint WinWidth = 300, WinHeight = 300;
 static GLint win = 0;
diff --git a/progs/glsl/twoside.c b/progs/glsl/twoside.c
index a57484f..ce155d6 100644
--- a/progs/glsl/twoside.c
+++ b/progs/glsl/twoside.c
@@ -16,6 +16,9 @@
 #include <GL/glut.h>
 #include "shaderutil.h"
 
+#ifndef M_PI
+#define M_PI 3.1415926535
+#endif
 
 static GLint WinWidth = 300, WinHeight = 300;
 static char *FragProgFile = NULL;
diff --git a/progs/tests/blitfb.c b/progs/tests/blitfb.c
new file mode 100644
index 0000000..18c8380
--- /dev/null
+++ b/progs/tests/blitfb.c
@@ -0,0 +1,259 @@
+/**
+ * Test glFramebufferBlit()
+ * Brian Paul
+ * 27 Oct 2009
+ */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <GL/glew.h>
+#include <GL/glut.h>
+
+
+static int Win;
+static int WinWidth = 1100, WinHeight = 600;
+
+static int SrcWidth = 512, SrcHeight = 512;
+static int DstWidth = 512, DstHeight = 512;
+
+static GLuint SrcFB, DstFB;
+static GLuint SrcTex, DstTex;
+
+#if 0
+static GLenum SrcTexTarget = GL_TEXTURE_2D, SrcTexFace = GL_TEXTURE_2D;
+#else
+static GLenum SrcTexTarget = GL_TEXTURE_CUBE_MAP, SrcTexFace = GL_TEXTURE_CUBE_MAP_POSITIVE_X;
+#endif
+
+static GLenum DstTexTarget = GL_TEXTURE_2D, DstTexFace = GL_TEXTURE_2D;
+
+static GLuint SrcTexLevel = 01, DstTexLevel = 0;
+
+
+static void
+Draw(void)
+{
+   GLboolean rp = GL_FALSE;
+   GLubyte *buf;
+   GLint srcWidth = SrcWidth >> SrcTexLevel;
+   GLint srcHeight = SrcHeight >> SrcTexLevel;
+   GLint dstWidth = DstWidth >> DstTexLevel;
+   GLint dstHeight = DstHeight >> DstTexLevel;
+   GLenum status;
+
+   /* clear window */
+   glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
+   glClearColor(0.5, 0.5, 0.5, 1.0);
+   glClear(GL_COLOR_BUFFER_BIT);
+
+
+   /* clear src buf */
+   glBindFramebufferEXT(GL_FRAMEBUFFER, SrcFB);
+   status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+   assert(status == GL_FRAMEBUFFER_COMPLETE_EXT);
+   glClearColor(0, 1, 0, 0);
+   glClear(GL_COLOR_BUFFER_BIT);
+
+   /* clear dst buf */
+   glBindFramebufferEXT(GL_FRAMEBUFFER, DstFB);
+   status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+   assert(status == GL_FRAMEBUFFER_COMPLETE_EXT);
+   glClearColor(1, 0, 0, 0);
+   glClear(GL_COLOR_BUFFER_BIT);
+
+   /* blit src -> dst */
+   glBindFramebufferEXT(GL_READ_FRAMEBUFFER, SrcFB);
+   glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER, DstFB);
+   glBlitFramebufferEXT(0, 0, srcWidth, srcHeight,
+                        0, 0, dstWidth, dstHeight,
+                        GL_COLOR_BUFFER_BIT, GL_NEAREST);
+
+#if 01
+   /* read src results */
+   buf = malloc(4 * srcWidth * srcHeight);
+   memset(buf, 0x88, 4 * srcWidth * srcHeight);
+   glBindFramebufferEXT(GL_FRAMEBUFFER, SrcFB);
+   if (rp)
+      glReadPixels(0, 0, srcWidth, srcHeight, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+   else {
+      glBindTexture(SrcTexTarget, SrcTex);
+      glGetTexImage(SrcTexFace, SrcTexLevel, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+   }
+
+   /* draw dst in window */
+   glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
+   glWindowPos2i(0, 0);
+   glDrawPixels(srcWidth, srcHeight, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+
+   printf("Src Pix[0] = %d %d %d %d\n", buf[0], buf[1], buf[2], buf[3]);
+   free(buf);
+#endif
+
+   glFinish();
+
+   /* read dst results */
+   buf = malloc(4 * dstWidth * dstHeight);
+   memset(buf, 0x88, 4 * dstWidth * dstHeight);
+   glBindFramebufferEXT(GL_FRAMEBUFFER, DstFB);
+   if (rp)
+      glReadPixels(0, 0, dstWidth, dstHeight, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+   else {
+      glBindTexture(DstTexTarget, DstTex);
+      glGetTexImage(DstTexFace, DstTexLevel, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+   }
+
+   /* draw dst in window */
+   glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
+   glWindowPos2i(srcWidth + 2, 0);
+   glDrawPixels(dstWidth, dstHeight, GL_RGBA, GL_UNSIGNED_BYTE, buf);
+
+   printf("Dst Pix[0] = %d %d %d %d\n", buf[0], buf[1], buf[2], buf[3]);
+   free(buf);
+
+   glFinish();
+
+   glutSwapBuffers();
+}
+
+
+static void
+Reshape(int width, int height)
+{
+   WinWidth = width;
+   WinHeight = height;
+   glViewport(0, 0, width, height);
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+   glFrustum(-1.0, 1.0, -1.0, 1.0, 5.0, 25.0);
+   glMatrixMode(GL_MODELVIEW);
+   glLoadIdentity();
+   glTranslatef(0.0, 0.0, -15.0);
+}
+
+
+static void
+Key(unsigned char key, int x, int y)
+{
+   (void) x;
+   (void) y;
+   switch (key) {
+   case 27:
+      glutDestroyWindow(Win);
+      exit(0);
+      break;
+   }
+   glutPostRedisplay();
+}
+
+
+static void
+SpecialKey(int key, int x, int y)
+{
+   (void) x;
+   (void) y;
+   switch (key) {
+   }
+   glutPostRedisplay();
+}
+
+
+static void
+InitFBOs(void)
+{
+   GLuint w, h, lvl;
+
+   /* Src */
+   glGenTextures(1, &SrcTex);
+   glBindTexture(SrcTexTarget, SrcTex);
+   w = SrcWidth;
+   h = SrcHeight;
+   lvl = 0;
+   for (lvl = 0; ; lvl++) {
+      if (SrcTexTarget == GL_TEXTURE_CUBE_MAP) {
+         GLuint f;
+         for (f = 0; f < 6; f++) {
+            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, lvl, GL_RGBA8,
+                         w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+         }
+      }
+      else {
+         /* single face */
+         glTexImage2D(SrcTexFace, lvl, GL_RGBA8, w, h, 0,
+                      GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+      }
+      if (w == 1 && h == 1)
+         break;
+      if (w > 1)
+         w /= 2;
+      if (h > 1)
+         h /= 2;
+   }
+
+   glGenFramebuffersEXT(1, &SrcFB);
+   glBindFramebufferEXT(GL_FRAMEBUFFER, SrcFB);
+   glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
+                             SrcTexFace, SrcTex, SrcTexLevel);
+
+   /* Dst */
+   glGenTextures(1, &DstTex);
+   glBindTexture(DstTexTarget, DstTex);
+   w = DstWidth;
+   h = DstHeight;
+   lvl = 0;
+   for (lvl = 0; ; lvl++) {
+      glTexImage2D(DstTexFace, lvl, GL_RGBA8, w, h, 0,
+                   GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+      if (w == 1 && h == 1)
+         break;
+      if (w > 1)
+         w /= 2;
+      if (h > 1)
+         h /= 2;
+   }
+
+   glGenFramebuffersEXT(1, &DstFB);
+   glBindFramebufferEXT(GL_FRAMEBUFFER, DstFB);
+   glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
+                             DstTexFace, DstTex, DstTexLevel);
+}
+
+
+static void
+Init(void)
+{
+   if (!glutExtensionSupported("GL_EXT_framebuffer_object")) {
+      fprintf(stderr, "This test requires GL_EXT_framebuffer_object\n");
+      exit(1);
+   }
+
+   if (!glutExtensionSupported("GL_EXT_framebuffer_blit")) {
+      fprintf(stderr, "This test requires GL_EXT_framebuffer_blit,\n");
+      exit(1);
+   }
+
+   InitFBOs();
+
+   printf("Left rect = src FBO, Right rect = dst FBO.\n");
+   printf("Both should be green.\n");
+}
+
+
+int
+main(int argc, char *argv[])
+{
+   glutInit(&argc, argv);
+   glutInitWindowSize(WinWidth, WinHeight);
+   glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
+   Win = glutCreateWindow(argv[0]);
+   glewInit();
+   glutReshapeFunc(Reshape);
+   glutKeyboardFunc(Key);
+   glutSpecialFunc(SpecialKey);
+   glutDisplayFunc(Draw);
+   Init();
+   glutMainLoop();
+   return 0;
+}
diff --git a/progs/xdemos/glsync.c b/progs/xdemos/glsync.c
index 34167d3..da87306 100644
--- a/progs/xdemos/glsync.c
+++ b/progs/xdemos/glsync.c
@@ -95,7 +95,7 @@ enum sync_type {
 static void usage(char *name)
 {
 	printf("usage: %s [-w <width>] [-h <height>] [-s<sync method>] "
-	       "[-vc]\n", name);
+	       "[-v]\n", name);
 	printf("\t-s<sync method>:\n");
 	printf("\t\tn: none\n");
 	printf("\t\ts: SGI video sync extension\n");
diff --git a/progs/xdemos/pbdemo.c b/progs/xdemos/pbdemo.c
index 7db0017..2573209 100644
--- a/progs/xdemos/pbdemo.c
+++ b/progs/xdemos/pbdemo.c
@@ -143,7 +143,7 @@ MakePbuffer( Display *dpy, int screen, int width, int height )
 
       /* Create the pbuffer using first fbConfig in the list that works. */
       for (i=0;i<nConfigs;i++) {
-         pBuffer = CreatePbuffer(dpy, screen, fbConfigs[i], width, height, preserve, largest);
+         pBuffer = CreatePbuffer(dpy, screen, fbConfigs[i], width, height, largest, preserve);
          if (pBuffer) {
             gFBconfig = fbConfigs[i];
             gWidth = width;
@@ -210,6 +210,21 @@ Setup(int width, int height)
       return 0;
    }
 
+   /* Test drawable queries */
+   {
+      unsigned int v;
+      glXQueryDrawable( gDpy, gPBuffer, GLX_WIDTH, &v);
+      printf("GLX_WIDTH = %u\n", v);
+      glXQueryDrawable( gDpy, gPBuffer, GLX_HEIGHT, &v);
+      printf("GLX_HEIGHT = %u\n", v);
+      glXQueryDrawable( gDpy, gPBuffer, GLX_PRESERVED_CONTENTS, &v);
+      printf("GLX_PRESERVED_CONTENTS = %u\n", v);
+      glXQueryDrawable( gDpy, gPBuffer, GLX_LARGEST_PBUFFER, &v);
+      printf("GLX_LARGEST_PBUFFER = %u\n", v);
+      glXQueryDrawable( gDpy, gPBuffer, GLX_FBCONFIG_ID, &v);
+      printf("GLX_FBCONFIG_ID = %u\n", v);
+   }
+
    /* Get corresponding XVisualInfo */
    visInfo = GetVisualFromFBConfig(gDpy, gScreen, gFBconfig);
    if (!visInfo) {
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 36c882a..4f13b3e 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -268,7 +268,7 @@ void cso_release_all( struct cso_context *ctx )
 void cso_destroy_context( struct cso_context *ctx )
 {
    if (ctx) {
-      //cso_release_all( ctx );
+      /*cso_release_all( ctx );*/
       FREE( ctx );
    }
 }
diff --git a/src/gallium/auxiliary/draw/draw_pt_fetch_shade_emit.c b/src/gallium/auxiliary/draw/draw_pt_fetch_shade_emit.c
index 44147ae..734c05f 100644
--- a/src/gallium/auxiliary/draw/draw_pt_fetch_shade_emit.c
+++ b/src/gallium/auxiliary/draw/draw_pt_fetch_shade_emit.c
@@ -212,17 +212,10 @@ static void fse_prepare( struct draw_pt_middle_end *middle,
       struct draw_vertex_shader *vs = draw->vs.vertex_shader;
       vs->prepare(vs, draw);
    }
-   
-
-   //return TRUE;
 }
 
 
 
-
-
-
-
 static void fse_run_linear( struct draw_pt_middle_end *middle, 
                             unsigned start, 
                             unsigned count )
diff --git a/src/gallium/auxiliary/draw/draw_pt_post_vs.c b/src/gallium/auxiliary/draw/draw_pt_post_vs.c
index 00d7197..78953bc 100644
--- a/src/gallium/auxiliary/draw/draw_pt_post_vs.c
+++ b/src/gallium/auxiliary/draw/draw_pt_post_vs.c
@@ -210,7 +210,7 @@ void draw_pt_post_vs_prepare( struct pt_post_vs *pvs,
 	 pvs->run = post_vs_viewport;
    }
    else {
-      //if (opengl) 
+      /* if (opengl) */
       pvs->run = post_vs_cliptest_viewport_gl;
    }
 }
diff --git a/src/gallium/auxiliary/draw/draw_pt_vcache.c b/src/gallium/auxiliary/draw/draw_pt_vcache.c
index 1a0527b..d3f179c 100644
--- a/src/gallium/auxiliary/draw/draw_pt_vcache.c
+++ b/src/gallium/auxiliary/draw/draw_pt_vcache.c
@@ -394,6 +394,7 @@ vcache_check_run( struct draw_pt_front_end *frontend,
 
          default:
             assert(0);
+            FREE(storage);
             return;
          }
       }
@@ -422,6 +423,7 @@ vcache_check_run( struct draw_pt_front_end *frontend,
 
          default:
             assert(0);
+            FREE(storage);
             return;
          }
       }
diff --git a/src/gallium/auxiliary/draw/draw_vs_aos.c b/src/gallium/auxiliary/draw/draw_vs_aos.c
index 62e04a6..645d7cc 100644
--- a/src/gallium/auxiliary/draw/draw_vs_aos.c
+++ b/src/gallium/auxiliary/draw/draw_vs_aos.c
@@ -891,7 +891,7 @@ static void x87_emit_ex2( struct aos_compilation *cp )
    struct x86_reg st1 = x86_make_reg(file_x87, 1);
    int stack = cp->func->x87_stack;
 
-//   set_fpu_round_neg_inf( cp );
+   /* set_fpu_round_neg_inf( cp ); */
 
    x87_fld(cp->func, st0);      /* a a */
    x87_fprndint( cp->func );	/* int(a) a*/
@@ -1759,14 +1759,14 @@ emit_instruction( struct aos_compilation *cp,
       return emit_SUB(cp, inst);
  
    case TGSI_OPCODE_LRP:
-//      return emit_LERP(cp, inst);
+      /*return emit_LERP(cp, inst);*/
       return FALSE;
 
    case TGSI_OPCODE_FRC:
       return emit_FRC(cp, inst);
 
    case TGSI_OPCODE_CLAMP:
-//      return emit_CLAMP(cp, inst);
+      /*return emit_CLAMP(cp, inst);*/
       return FALSE;
 
    case TGSI_OPCODE_FLR:
diff --git a/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c b/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
index 109ac7c..0d30363 100644
--- a/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
+++ b/src/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
@@ -584,7 +584,7 @@ fenced_buffer_list_destroy(struct fenced_buffer_list *fenced_list)
    }
 
 #ifdef DEBUG
-   //assert(!fenced_list->numUnfenced);
+   /*assert(!fenced_list->numUnfenced);*/
 #endif
       
    pipe_mutex_unlock(fenced_list->mutex);
diff --git a/src/gallium/auxiliary/translate/translate_generic.c b/src/gallium/auxiliary/translate/translate_generic.c
index 8d39b64..266e7ee 100644
--- a/src/gallium/auxiliary/translate/translate_generic.c
+++ b/src/gallium/auxiliary/translate/translate_generic.c
@@ -217,7 +217,7 @@ ATTRIB( R8G8_SNORM,      2, char, FROM_8_SNORM, TO_8_SNORM )
 ATTRIB( R8_SNORM,        1, char, FROM_8_SNORM, TO_8_SNORM )
 
 ATTRIB( A8R8G8B8_UNORM,       4, ubyte, FROM_8_UNORM, TO_8_UNORM )
-//ATTRIB( R8G8B8A8_UNORM,       4, ubyte, FROM_8_UNORM, TO_8_UNORM )
+/*ATTRIB( R8G8B8A8_UNORM,       4, ubyte, FROM_8_UNORM, TO_8_UNORM )*/
 
 ATTRIB( R32G32B32A32_FIXED,   4, int, FROM_32_FIXED, TO_32_FIXED )
 ATTRIB( R32G32B32_FIXED,      3, int, FROM_32_FIXED, TO_32_FIXED )
diff --git a/src/gallium/auxiliary/util/u_cpu_detect.c b/src/gallium/auxiliary/util/u_cpu_detect.c
index d9f2f8f..f78706f 100644
--- a/src/gallium/auxiliary/util/u_cpu_detect.c
+++ b/src/gallium/auxiliary/util/u_cpu_detect.c
@@ -268,7 +268,7 @@ static void check_os_katmai_support(void)
 	 * and therefore to be safe I'm going to leave this test in here.
 	 */
 	if (__cpu_detect_caps.hasSSE) {
-		//      test_os_katmai_exception_support();
+           /* test_os_katmai_exception_support(); */
 	}
 
 	/* Restore the original signal handlers.
diff --git a/src/gallium/auxiliary/util/u_debug_profile.c b/src/gallium/auxiliary/util/u_debug_profile.c
index 6d8b244..d765b50 100644
--- a/src/gallium/auxiliary/util/u_debug_profile.c
+++ b/src/gallium/auxiliary/util/u_debug_profile.c
@@ -254,7 +254,7 @@ debug_profile_start(void)
 {
    WCHAR *p;
 
-   // increment starting from the less significant digit
+   /* increment starting from the less significant digit */
    p = &wFileName[14];
    while(1) {
       if(*p == '9') {
diff --git a/src/gallium/auxiliary/util/u_debug_symbol.c b/src/gallium/auxiliary/util/u_debug_symbol.c
index 811931f..417d0cf 100644
--- a/src/gallium/auxiliary/util/u_debug_symbol.c
+++ b/src/gallium/auxiliary/util/u_debug_symbol.c
@@ -214,7 +214,7 @@ debug_symbol_print_imagehlp(const void *addr)
    HANDLE hProcess;
    BYTE symbolBuffer[1024];
    PIMAGEHLP_SYMBOL pSymbol = (PIMAGEHLP_SYMBOL) symbolBuffer;
-   DWORD dwDisplacement = 0;  // Displacement of the input address, relative to the start of the symbol
+   DWORD dwDisplacement = 0;  /* Displacement of the input address, relative to the start of the symbol */
 
    hProcess = GetCurrentProcess();
 
diff --git a/src/gallium/auxiliary/util/u_gen_mipmap.c b/src/gallium/auxiliary/util/u_gen_mipmap.c
index 4e3d35f..aa823aa 100644
--- a/src/gallium/auxiliary/util/u_gen_mipmap.c
+++ b/src/gallium/auxiliary/util/u_gen_mipmap.c
@@ -1427,6 +1427,7 @@ set_vertex_data(struct gen_mipmap_state *ctx,
             rz = -1.0f;
             break;
          default:
+            rx = ry = rz = 0.0f;
             assert(0);
          }
 
diff --git a/src/gallium/drivers/cell/ppu/cell_gen_fp.c b/src/gallium/drivers/cell/ppu/cell_gen_fp.c
index 312621f..b6b2f88 100644
--- a/src/gallium/drivers/cell/ppu/cell_gen_fp.c
+++ b/src/gallium/drivers/cell/ppu/cell_gen_fp.c
@@ -674,7 +674,7 @@ emit_MAD(struct codegen *gen, const struct tgsi_full_instruction *inst)
  * Emit linear interpolate.  See emit_ADD for comments.
  */
 static boolean
-emit_LERP(struct codegen *gen, const struct tgsi_full_instruction *inst)
+emit_LRP(struct codegen *gen, const struct tgsi_full_instruction *inst)
 {
    int ch, s1_reg[4], s2_reg[4], s3_reg[4], d_reg[4], tmp_reg[4];
 
@@ -1766,7 +1766,7 @@ emit_instruction(struct codegen *gen,
       return emit_binop(gen, inst);
    case TGSI_OPCODE_MAD:
       return emit_MAD(gen, inst);
-   case TGSI_OPCODE_LERP:
+   case TGSI_OPCODE_LRP:
       return emit_LRP(gen, inst);
    case TGSI_OPCODE_DP3:
       return emit_DP3(gen, inst);
diff --git a/src/gallium/drivers/softpipe/sp_context.c b/src/gallium/drivers/softpipe/sp_context.c
index 86df320..b4650c0 100644
--- a/src/gallium/drivers/softpipe/sp_context.c
+++ b/src/gallium/drivers/softpipe/sp_context.c
@@ -105,12 +105,17 @@ static void softpipe_destroy( struct pipe_context *pipe )
       softpipe->quad[i].output->destroy( softpipe->quad[i].output );
    }
 
-   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++)
+   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
       sp_destroy_tile_cache(softpipe->cbuf_cache[i]);
+      pipe_surface_reference(&softpipe->framebuffer.cbufs[i], NULL);
+   }
    sp_destroy_tile_cache(softpipe->zsbuf_cache);
+   pipe_surface_reference(&softpipe->framebuffer.zsbuf, NULL);
 
-   for (i = 0; i < PIPE_MAX_SAMPLERS; i++)
+   for (i = 0; i < PIPE_MAX_SAMPLERS; i++) {
       sp_destroy_tile_cache(softpipe->tex_cache[i]);
+      pipe_texture_reference(&softpipe->texture[i], NULL);
+   }
 
    for (i = 0; i < Elements(softpipe->constants); i++) {
       if (softpipe->constants[i].buffer) {
diff --git a/src/gallium/drivers/softpipe/sp_fs_sse.c b/src/gallium/drivers/softpipe/sp_fs_sse.c
index f4fa090..31ccc3b 100644
--- a/src/gallium/drivers/softpipe/sp_fs_sse.c
+++ b/src/gallium/drivers/softpipe/sp_fs_sse.c
@@ -101,7 +101,7 @@ fs_sse_run( const struct sp_fragment_shader *base,
 		 machine->Consts,
                  (const float (*)[4])shader->immediates,
 		 machine->InterpCoefs
-		 //	 , &machine->QuadPos
+		 /*, &machine->QuadPos*/
       );
 
    return ~(machine->Temps[TGSI_EXEC_TEMP_KILMASK_I].xyzw[TGSI_EXEC_TEMP_KILMASK_C].u[0]);
diff --git a/src/gallium/drivers/softpipe/sp_state_surface.c b/src/gallium/drivers/softpipe/sp_state_surface.c
index 7c06d86..181bff8 100644
--- a/src/gallium/drivers/softpipe/sp_state_surface.c
+++ b/src/gallium/drivers/softpipe/sp_state_surface.c
@@ -56,7 +56,7 @@ softpipe_set_framebuffer_state(struct pipe_context *pipe,
          sp_flush_tile_cache(sp, sp->cbuf_cache[i]);
 
          /* assign new */
-         sp->framebuffer.cbufs[i] = fb->cbufs[i];
+         pipe_surface_reference(&sp->framebuffer.cbufs[i], fb->cbufs[i]);
 
          /* update cache */
          sp_tile_cache_set_surface(sp->cbuf_cache[i], fb->cbufs[i]);
@@ -71,7 +71,7 @@ softpipe_set_framebuffer_state(struct pipe_context *pipe,
       sp_flush_tile_cache(sp, sp->zsbuf_cache);
 
       /* assign new */
-      sp->framebuffer.zsbuf = fb->zsbuf;
+      pipe_surface_reference(&sp->framebuffer.zsbuf, fb->zsbuf);
 
       /* update cache */
       sp_tile_cache_set_surface(sp->zsbuf_cache, fb->zsbuf);
diff --git a/src/gallium/drivers/softpipe/sp_tile_cache.c b/src/gallium/drivers/softpipe/sp_tile_cache.c
index 461cbb9..b2195ec 100644
--- a/src/gallium/drivers/softpipe/sp_tile_cache.c
+++ b/src/gallium/drivers/softpipe/sp_tile_cache.c
@@ -130,6 +130,16 @@ sp_create_tile_cache( struct pipe_screen *screen )
          tc->entries[pos].x =
          tc->entries[pos].y = -1;
       }
+
+      /* XXX this code prevents valgrind warnings about use of uninitialized
+       * memory in programs that don't clear the surface before rendering.
+       * However, it breaks clearing in other situations (such as in
+       * progs/tests/drawbuffers, see bug 24402).
+       */
+#if 0 && TILE_CLEAR_OPTIMIZATION
+      /* set flags to indicate all the tiles are cleared */
+      memset(tc->clear_flags, 255, sizeof(tc->clear_flags));
+#endif
    }
    return tc;
 }
diff --git a/src/gallium/state_trackers/glx/xlib/glx_api.c b/src/gallium/state_trackers/glx/xlib/glx_api.c
index d1a98f8..f2881b9 100644
--- a/src/gallium/state_trackers/glx/xlib/glx_api.c
+++ b/src/gallium/state_trackers/glx/xlib/glx_api.c
@@ -850,10 +850,10 @@ choose_visual( Display *dpy, int screen, const int *list, GLboolean fbConfig )
             if (!fbConfig)
                return NULL;
             parselist++;
-            if (*parselist == GLX_RGBA_BIT) {
+            if (*parselist & GLX_RGBA_BIT) {
                rgb_flag = GL_TRUE;
             }
-            else if (*parselist == GLX_COLOR_INDEX_BIT) {
+            else if (*parselist & GLX_COLOR_INDEX_BIT) {
                rgb_flag = GL_FALSE;
             }
             else if (*parselist == 0) {
@@ -1309,13 +1309,17 @@ glXCopyContext( Display *dpy, GLXContext src, GLXContext dst,
 
 
 Bool
-glXQueryExtension( Display *dpy, int *errorb, int *event )
+glXQueryExtension( Display *dpy, int *errorBase, int *eventBase )
 {
+   int op, ev, err;
    /* Mesa's GLX isn't really an X extension but we try to act like one. */
-   (void) dpy;
-   (void) errorb;
-   (void) event;
-   return True;
+   if (!XQueryExtension(dpy, GLX_EXTENSION_NAME, &op, &ev, &err))
+      ev = err = 0;
+   if (errorBase)
+      *errorBase = err;
+   if (eventBase)
+      *eventBase = ev;
+   return True; /* we're faking GLX so always return success */
 }
 
 
@@ -1990,32 +1994,42 @@ glXCreatePbuffer( Display *dpy, GLXFBConfig config,
             break;
          case GLX_PRESERVED_CONTENTS:
             attrib++;
-            preserveContents = *attrib; /* ignored */
+            preserveContents = *attrib;
             break;
          case GLX_LARGEST_PBUFFER:
             attrib++;
-            useLargest = *attrib; /* ignored */
+            useLargest = *attrib;
             break;
          default:
             return 0;
       }
    }
 
-   /* not used at this time */
-   (void) useLargest;
-   (void) preserveContents;
-
    if (width == 0 || height == 0)
       return 0;
 
+   if (width > MAX_WIDTH || height > MAX_HEIGHT) {
+      /* If allocation would have failed and GLX_LARGEST_PBUFFER is set,
+       * allocate the largest possible buffer.
+       */
+      if (useLargest) {
+         width = MAX_WIDTH;
+         height = MAX_HEIGHT;
+      }
+   }
+
    xmbuf = XMesaCreatePBuffer( xmvis, 0, width, height);
    /* A GLXPbuffer handle must be an X Drawable because that's what
     * glXMakeCurrent takes.
     */
-   if (xmbuf)
+   if (xmbuf) {
+      xmbuf->largestPbuffer = useLargest;
+      xmbuf->preservedContents = preserveContents;
       return (GLXPbuffer) xmbuf->drawable;
-   else
+   }
+   else {
       return 0;
+   }
 }
 
 
@@ -2033,22 +2047,26 @@ void
 glXQueryDrawable( Display *dpy, GLXDrawable draw, int attribute,
                        unsigned int *value )
 {
+   GLuint width, height;
    XMesaBuffer xmbuf = XMesaFindBuffer(dpy, draw);
    if (!xmbuf)
       return;
 
+   /* make sure buffer's dimensions are up to date */
+   xmesa_get_window_size(dpy, xmbuf, &width, &height);
+
    switch (attribute) {
       case GLX_WIDTH:
-         *value = xmesa_buffer_width(xmbuf);
+         *value = width;
          break;
       case GLX_HEIGHT:
-         *value = xmesa_buffer_width(xmbuf);
+         *value = height;
          break;
       case GLX_PRESERVED_CONTENTS:
-         *value = True;
+         *value = xmbuf->preservedContents;
          break;
       case GLX_LARGEST_PBUFFER:
-         *value = xmesa_buffer_width(xmbuf) * xmesa_buffer_height(xmbuf);
+         *value = xmbuf->largestPbuffer;
          break;
       case GLX_FBCONFIG_ID:
          *value = xmbuf->xm_visual->visinfo->visualid;
@@ -2120,9 +2138,9 @@ glXQueryContext( Display *dpy, GLXContext ctx, int attribute, int *value )
       break;
    case GLX_RENDER_TYPE:
       if (xmctx->xm_visual->mesa_visual.rgbMode)
-         *value = GLX_RGBA_BIT;
+         *value = GLX_RGBA_TYPE;
       else
-         *value = GLX_COLOR_INDEX_BIT;
+         *value = GLX_COLOR_INDEX_TYPE;
       break;
    case GLX_SCREEN:
       *value = 0;
diff --git a/src/gallium/state_trackers/glx/xlib/xm_api.c b/src/gallium/state_trackers/glx/xlib/xm_api.c
index 957002d..c76dfb3 100644
--- a/src/gallium/state_trackers/glx/xlib/xm_api.c
+++ b/src/gallium/state_trackers/glx/xlib/xm_api.c
@@ -228,7 +228,7 @@ get_drawable_size( Display *dpy, Drawable d, uint *width, uint *height )
  * \param width  returns width in pixels
  * \param height  returns height in pixels
  */
-static void
+void
 xmesa_get_window_size(Display *dpy, XMesaBuffer b,
                       GLuint *width, GLuint *height)
 {
diff --git a/src/gallium/state_trackers/glx/xlib/xm_api.h b/src/gallium/state_trackers/glx/xlib/xm_api.h
index ce97a3e..d24971c 100644
--- a/src/gallium/state_trackers/glx/xlib/xm_api.h
+++ b/src/gallium/state_trackers/glx/xlib/xm_api.h
@@ -323,6 +323,9 @@ struct xmesa_buffer {
    Colormap cmap;		/* the X colormap */
    BufferType type;             /* window, pixmap, pbuffer or glxwindow */
 
+   GLboolean largestPbuffer;    /**< for pbuffers */
+   GLboolean preservedContents; /**< for pbuffers */
+
    XImage *tempImage;
    unsigned long selectedEvents;/* for pbuffers only */
 
@@ -370,6 +373,10 @@ extern XMesaBuffer
 xmesa_find_buffer(Display *dpy, Colormap cmap, XMesaBuffer notThis);
 
 extern void
+xmesa_get_window_size(Display *dpy, XMesaBuffer b,
+                      GLuint *width, GLuint *height);
+
+extern void
 xmesa_check_and_update_buffer_size(XMesaContext xmctx, XMesaBuffer drawBuffer);
 
 extern void
diff --git a/src/glx/x11/dri_glx.c b/src/glx/x11/dri_glx.c
index ab24bd8..4f7acb6 100644
--- a/src/glx/x11/dri_glx.c
+++ b/src/glx/x11/dri_glx.c
@@ -596,8 +596,10 @@ driCreateDrawable(__GLXscreenConfigs * psc,
    pdraw->drawable = drawable;
    pdraw->psc = psc;
 
-   if (!XF86DRICreateDrawable(psc->dpy, psc->scr, drawable, &hwDrawable))
+   if (!XF86DRICreateDrawable(psc->dpy, psc->scr, drawable, &hwDrawable)) {
+      Xfree(pdraw);
       return NULL;
+   }
 
    /* Create a new drawable */
    pdraw->driDrawable =
diff --git a/src/glx/x11/glxcmds.c b/src/glx/x11/glxcmds.c
index ea55cc4..c63116b 100644
--- a/src/glx/x11/glxcmds.c
+++ b/src/glx/x11/glxcmds.c
@@ -398,6 +398,10 @@ CreateContext(Display * dpy, XVisualInfo * vis,
                _XError(dpy, &error);
                return None;
             }
+            if (renderType == 0) {
+               /* Initialize renderType now */
+               renderType = mode->rgbMode ? GLX_RGBA_TYPE : GLX_COLOR_INDEX_TYPE;
+            }
          }
          else {
             mode = fbconfig;
@@ -484,6 +488,8 @@ CreateContext(Display * dpy, XVisualInfo * vis,
       gc->imported = GL_TRUE;
    }
 
+   gc->renderType = renderType;
+
    return gc;
 }
 
@@ -534,6 +540,16 @@ DestroyContext(Display * dpy, GLXContext gc)
    imported = gc->imported;
    gc->xid = None;
 
+   if (gc->currentDpy) {
+      /* This context is bound to some thread.  According to the man page,
+       * we should not actually delete the context until it's unbound.
+       * Note that we set gc->xid = None above.  In MakeContextCurrent()
+       * we check for that and delete the context there.
+       */
+      __glXUnlock();
+      return;
+   }
+
 #ifdef GLX_DIRECT_RENDERING
    /* Destroy the direct rendering context */
    if (gc->driContext) {
@@ -1575,7 +1591,7 @@ GLX_ALIAS(Display *, glXGetCurrentDisplayEXT, (void), (),
  * This function dynamically determines whether to use the EXT_import_context
  * version of the protocol or the GLX 1.3 version of the protocol.
  */
-     static int __glXQueryContextInfo(Display * dpy, GLXContext ctx)
+static int __glXQueryContextInfo(Display * dpy, GLXContext ctx)
 {
    __GLXdisplayPrivate *priv = __glXInitialize(dpy);
    xGLXQueryContextReply reply;
@@ -1713,7 +1729,7 @@ GLX_ALIAS(int, glXQueryContextInfoEXT,
           (Display * dpy, GLXContext ctx, int attribute, int *value),
           (dpy, ctx, attribute, value), glXQueryContext)
 
-     PUBLIC GLXContextID glXGetContextIDEXT(const GLXContext ctx)
+PUBLIC GLXContextID glXGetContextIDEXT(const GLXContext ctx)
 {
    return ctx->xid;
 }
@@ -2159,18 +2175,19 @@ GLX_ALIAS(int, glXGetFBConfigAttribSGIX,
           (Display * dpy, GLXFBConfigSGIX config, int attribute, int *value),
           (dpy, config, attribute, value), glXGetFBConfigAttrib)
 
-     PUBLIC GLX_ALIAS(GLXFBConfigSGIX *, glXChooseFBConfigSGIX,
-                      (Display * dpy, int screen, int *attrib_list,
-                       int *nelements), (dpy, screen, attrib_list, nelements),
-                      glXChooseFBConfig)
+PUBLIC GLX_ALIAS(GLXFBConfigSGIX *, glXChooseFBConfigSGIX,
+                 (Display * dpy, int screen, int *attrib_list,
+                  int *nelements), (dpy, screen, attrib_list, nelements),
+                 glXChooseFBConfig)
 
-     PUBLIC GLX_ALIAS(XVisualInfo *, glXGetVisualFromFBConfigSGIX,
-                      (Display * dpy, GLXFBConfigSGIX config),
-                      (dpy, config), glXGetVisualFromFBConfig)
+PUBLIC GLX_ALIAS(XVisualInfo *, glXGetVisualFromFBConfigSGIX,
+                 (Display * dpy, GLXFBConfigSGIX config),
+                 (dpy, config), glXGetVisualFromFBConfig)
 
-     PUBLIC GLXPixmap glXCreateGLXPixmapWithConfigSGIX(Display * dpy,
-                                                       GLXFBConfigSGIX config,
-                                                       Pixmap pixmap)
+PUBLIC GLXPixmap
+glXCreateGLXPixmapWithConfigSGIX(Display * dpy,
+                                 GLXFBConfigSGIX config,
+                                 Pixmap pixmap)
 {
    xGLXVendorPrivateWithReplyReq *vpreq;
    xGLXCreateGLXPixmapWithConfigSGIXReq *req;
diff --git a/src/mesa/drivers/common/meta.c b/src/mesa/drivers/common/meta.c
index 2741a41..b6c6ef7 100644
--- a/src/mesa/drivers/common/meta.c
+++ b/src/mesa/drivers/common/meta.c
@@ -238,34 +238,10 @@ _mesa_meta_init(GLcontext *ctx)
 void
 _mesa_meta_free(GLcontext *ctx)
 {
-   struct gl_meta_state *meta = ctx->Meta;
-
-   if (_mesa_get_current_context()) {
-      /* if there's no current context, these textures, buffers, etc should
-       * still get freed by _mesa_free_context_data().
-       */
-
-      _mesa_DeleteTextures(1, &meta->TempTex.TexObj);
-
-      /* glBlitFramebuffer */
-      _mesa_DeleteBuffersARB(1, & meta->Blit.VBO);
-      _mesa_DeleteVertexArraysAPPLE(1, &meta->Blit.ArrayObj);
-      _mesa_DeletePrograms(1, &meta->Blit.DepthFP);
-
-      /* glClear */
-      _mesa_DeleteBuffersARB(1, & meta->Clear.VBO);
-      _mesa_DeleteVertexArraysAPPLE(1, &meta->Clear.ArrayObj);
-
-      /* glCopyPixels */
-      _mesa_DeleteBuffersARB(1, & meta->CopyPix.VBO);
-      _mesa_DeleteVertexArraysAPPLE(1, &meta->CopyPix.ArrayObj);
-
-      /* glDrawPixels */
-      _mesa_DeleteVertexArraysAPPLE(1, &meta->DrawPix.ArrayObj);
-      _mesa_DeletePrograms(1, &meta->DrawPix.DepthFP);
-      _mesa_DeletePrograms(1, &meta->DrawPix.StencilFP);
-   }
-
+   /* Note: Any textures, VBOs, etc, that we allocate should get
+    * freed by the normal context destruction code.  But this would be
+    * the place to free other meta data someday.
+    */
    _mesa_free(ctx->Meta);
    ctx->Meta = NULL;
 }
diff --git a/src/mesa/drivers/dri/Makefile b/src/mesa/drivers/dri/Makefile
index 32db097..264648c 100644
--- a/src/mesa/drivers/dri/Makefile
+++ b/src/mesa/drivers/dri/Makefile
@@ -25,7 +25,7 @@ pcedit = sed \
 	-e 's,@INSTALL_LIB_DIR@,$(INSTALL_LIB_DIR),' \
 	-e 's,@INSTALL_INC_DIR@,$(INSTALL_INC_DIR),' \
 	-e 's,@VERSION@,$(MESA_MAJOR).$(MESA_MINOR).$(MESA_TINY),' \
-	-e 's,@DRI_DRIVER_DIR@,$(DRI_DRIVER_SEARCH_DIR),' \
+	-e 's,@DRI_DRIVER_DIR@,$(DRI_DRIVER_INSTALL_DIR),' \
 	-e 's,@DRI_PC_REQ_PRIV@,$(DRI_PC_REQ_PRIV),'
 
 dri.pc: dri.pc.in
diff --git a/src/mesa/drivers/dri/i915/i830_texstate.c b/src/mesa/drivers/dri/i915/i830_texstate.c
index 6f998fa..20ff46b 100644
--- a/src/mesa/drivers/dri/i915/i830_texstate.c
+++ b/src/mesa/drivers/dri/i915/i830_texstate.c
@@ -160,11 +160,18 @@ i830_update_tex_unit(struct intel_context *intel, GLuint unit, GLuint ss3)
 
       pitch = intelObj->pitchOverride;
    } else {
+      GLuint dst_x, dst_y;
+
+      intel_miptree_get_image_offset(intelObj->mt, intelObj->firstLevel, 0, 0,
+				     &dst_x, &dst_y);
+
       dri_bo_reference(intelObj->mt->region->buffer);
       i830->state.tex_buffer[unit] = intelObj->mt->region->buffer;
-      i830->state.tex_offset[unit] = intel_miptree_image_offset(intelObj->mt,
-								0, intelObj->
-								firstLevel);
+      /* XXX: This calculation is probably broken for tiled images with
+       * a non-page-aligned offset.
+       */
+      i830->state.tex_offset[unit] = (dst_x + dst_y * intelObj->mt->pitch) *
+	 intelObj->mt->cpp;
 
       format = translate_texture_format(firstImage->TexFormat->MesaFormat,
 					firstImage->InternalFormat);
diff --git a/src/mesa/drivers/dri/i915/i915_texstate.c b/src/mesa/drivers/dri/i915/i915_texstate.c
index 32d4b30..998a04f 100644
--- a/src/mesa/drivers/dri/i915/i915_texstate.c
+++ b/src/mesa/drivers/dri/i915/i915_texstate.c
@@ -171,11 +171,18 @@ i915_update_tex_unit(struct intel_context *intel, GLuint unit, GLuint ss3)
 
       pitch = intelObj->pitchOverride;
    } else {
+      GLuint dst_x, dst_y;
+
+      intel_miptree_get_image_offset(intelObj->mt, intelObj->firstLevel, 0, 0,
+				     &dst_x, &dst_y);
+
       dri_bo_reference(intelObj->mt->region->buffer);
       i915->state.tex_buffer[unit] = intelObj->mt->region->buffer;
-      i915->state.tex_offset[unit] =  intel_miptree_image_offset(intelObj->mt,
-								 0, intelObj->
-								 firstLevel);
+      /* XXX: This calculation is probably broken for tiled images with
+       * a non-page-aligned offset.
+       */
+      i915->state.tex_offset[unit] = (dst_x + dst_y * intelObj->mt->pitch) *
+	 intelObj->mt->cpp;
 
       format = translate_texture_format(firstImage->TexFormat->MesaFormat, 
 					firstImage->InternalFormat,
diff --git a/src/mesa/drivers/dri/i915/intel_tris.c b/src/mesa/drivers/dri/i915/intel_tris.c
index a905455..bc6b292 100644
--- a/src/mesa/drivers/dri/i915/intel_tris.c
+++ b/src/mesa/drivers/dri/i915/intel_tris.c
@@ -1194,12 +1194,16 @@ getFallbackString(GLuint bit)
 
 
 
+/**
+ * Enable/disable a fallback flag.
+ * \param bit  one of INTEL_FALLBACK_x flags.
+ */
 void
-intelFallback(struct intel_context *intel, GLuint bit, GLboolean mode)
+intelFallback(struct intel_context *intel, GLbitfield bit, GLboolean mode)
 {
    GLcontext *ctx = &intel->ctx;
    TNLcontext *tnl = TNL_CONTEXT(ctx);
-   GLuint oldfallback = intel->Fallback;
+   const GLbitfield oldfallback = intel->Fallback;
 
    if (mode) {
       intel->Fallback |= bit;
diff --git a/src/mesa/drivers/dri/i965/brw_context.h b/src/mesa/drivers/dri/i965/brw_context.h
index a5209ac..da0e091 100644
--- a/src/mesa/drivers/dri/i965/brw_context.h
+++ b/src/mesa/drivers/dri/i965/brw_context.h
@@ -115,7 +115,7 @@
  * Handles blending and (presumably) depth and stencil testing.
  */
 
-#define BRW_FALLBACK_TEXTURE		 0x1
+
 #define BRW_MAX_CURBE                    (32*16)
 
 struct brw_context;
@@ -454,7 +454,6 @@ struct brw_context
    GLuint primitive;
 
    GLboolean emit_state_always;
-   GLboolean tmp_fallback;
    GLboolean no_batch_wrap;
 
    struct {
diff --git a/src/mesa/drivers/dri/i965/brw_draw_upload.c b/src/mesa/drivers/dri/i965/brw_draw_upload.c
index 4aa17fa..348c661 100644
--- a/src/mesa/drivers/dri/i965/brw_draw_upload.c
+++ b/src/mesa/drivers/dri/i965/brw_draw_upload.c
@@ -375,7 +375,7 @@ static void brw_prepare_vertices(struct brw_context *brw)
     * isn't an issue at this point.
     */
    if (brw->vb.nr_enabled >= BRW_VEP_MAX) {
-      intel->Fallback = 1;
+      intel->Fallback = GL_TRUE; /* boolean, not bitfield */
       return;
    }
 
@@ -427,7 +427,7 @@ static void brw_prepare_vertices(struct brw_context *brw)
 	    /* Position array not properly enabled:
 	     */
             if (input->glarray->StrideB == 0) {
-               intel->Fallback = 1;
+               intel->Fallback = GL_TRUE; /* boolean, not bitfield */
                return;
             }
 
@@ -539,12 +539,12 @@ static void brw_emit_vertices(struct brw_context *brw)
           if (input->stride) {
               OUT_RELOC(input->bo,
                         I915_GEM_DOMAIN_VERTEX, 0,
-                        input->offset + input->stride * input->count);
+                        input->offset + input->stride * input->count - 1);
           } else {
               assert(input->count == 1);
               OUT_RELOC(input->bo,
                         I915_GEM_DOMAIN_VERTEX, 0,
-                        input->offset + input->element_size);
+                        input->offset + input->element_size - 1);
           }
       } else
           OUT_BATCH(input->stride ? input->count : 0);
@@ -726,7 +726,7 @@ static void brw_emit_index_buffer(struct brw_context *brw)
 		brw->ib.offset);
       OUT_RELOC(brw->ib.bo,
 		I915_GEM_DOMAIN_VERTEX, 0,
-		brw->ib.offset + brw->ib.size);
+		brw->ib.offset + brw->ib.size - 1);
       OUT_BATCH( 0 );
       ADVANCE_BATCH();
    }
diff --git a/src/mesa/drivers/dri/i965/brw_fallback.c b/src/mesa/drivers/dri/i965/brw_fallback.c
index d27c6c2..562a178 100644
--- a/src/mesa/drivers/dri/i965/brw_fallback.c
+++ b/src/mesa/drivers/dri/i965/brw_fallback.c
@@ -133,7 +133,11 @@ const struct brw_tracked_state brw_check_fallback = {
 
 
 
-/* Not used:
+/**
+ * Called by the INTEL_FALLBACK() macro.
+ * NOTE: this is a no-op for the i965 driver.  The brw->intel.Fallback
+ * field is treated as a boolean, not a bitmask.  It's only set in a
+ * couple of places.
  */
 void intelFallback( struct intel_context *intel, GLuint bit, GLboolean mode )
 {
diff --git a/src/mesa/drivers/dri/i965/brw_state.h b/src/mesa/drivers/dri/i965/brw_state.h
index 5335eac..d639656 100644
--- a/src/mesa/drivers/dri/i965/brw_state.h
+++ b/src/mesa/drivers/dri/i965/brw_state.h
@@ -151,6 +151,7 @@ void brw_state_cache_check_size( struct brw_context *brw );
 
 void brw_init_caches( struct brw_context *brw );
 void brw_destroy_caches( struct brw_context *brw );
+void brw_state_cache_bo_delete(struct brw_cache *cache, dri_bo *bo);
 
 /***********************************************************************
  * brw_state_batch.c
diff --git a/src/mesa/drivers/dri/i965/brw_state_cache.c b/src/mesa/drivers/dri/i965/brw_state_cache.c
index e40d7a0..f8e46aa 100644
--- a/src/mesa/drivers/dri/i965/brw_state_cache.c
+++ b/src/mesa/drivers/dri/i965/brw_state_cache.c
@@ -517,6 +517,55 @@ brw_clear_cache(struct brw_context *brw, struct brw_cache *cache)
    brw->state.dirty.cache |= ~0;
 }
 
+/* Clear all entries from the cache that point to the given bo.
+ *
+ * This lets us release memory for reuse earlier for known-dead buffers,
+ * at the cost of walking the entire hash table.
+ */
+void
+brw_state_cache_bo_delete(struct brw_cache *cache, dri_bo *bo)
+{
+   struct brw_cache_item **prev;
+   GLuint i;
+
+   if (INTEL_DEBUG & DEBUG_STATE)
+      _mesa_printf("%s\n", __FUNCTION__);
+
+   for (i = 0; i < cache->size; i++) {
+      for (prev = &cache->items[i]; *prev;) {
+	 struct brw_cache_item *c = *prev;
+	 int j;
+
+	 for (j = 0; j < c->nr_reloc_bufs; j++) {
+	    if (c->reloc_bufs[j] == bo)
+	       break;
+	 }
+
+	 if (j != c->nr_reloc_bufs) {
+
+	    *prev = c->next;
+
+	    for (j = 0; j < c->nr_reloc_bufs; j++)
+	       dri_bo_unreference(c->reloc_bufs[j]);
+	    dri_bo_unreference(c->bo);
+	    free((void *)c->key);
+	    free(c);
+	    cache->n_items--;
+
+	    /* Delete up the tree.  Notably we're trying to get from
+	     * a request to delete the surface, to deleting the surface state
+	     * object, to deleting the binding table.  We're slack and restart
+	     * the deletion process when we do this because the other delete
+	     * may kill our *prev.
+	     */
+	    brw_state_cache_bo_delete(cache, c->bo);
+	    prev = &cache->items[i];
+	 } else {
+	    prev = &(*prev)->next;
+	 }
+      }
+   }
+}
 
 void
 brw_state_cache_check_size(struct brw_context *brw)
diff --git a/src/mesa/drivers/dri/i965/brw_state_upload.c b/src/mesa/drivers/dri/i965/brw_state_upload.c
index b817b74..ee447af 100644
--- a/src/mesa/drivers/dri/i965/brw_state_upload.c
+++ b/src/mesa/drivers/dri/i965/brw_state_upload.c
@@ -308,7 +308,7 @@ void brw_validate_state( struct brw_context *brw )
    if (brw->state.dirty.brw & BRW_NEW_CONTEXT)
       brw_clear_batch_cache(brw);
 
-   brw->intel.Fallback = 0;
+   brw->intel.Fallback = GL_FALSE; /* boolean, not bitfield */
 
    /* do prepare stage for all atoms */
    for (i = 0; i < Elements(atoms); i++) {
diff --git a/src/mesa/drivers/dri/i965/brw_tex_layout.c b/src/mesa/drivers/dri/i965/brw_tex_layout.c
index 5986cbf..e59e52e 100644
--- a/src/mesa/drivers/dri/i965/brw_tex_layout.c
+++ b/src/mesa/drivers/dri/i965/brw_tex_layout.c
@@ -86,10 +86,10 @@ GLboolean brw_miptree_layout(struct intel_context *intel,
           mt->pitch = intel_miptree_pitch_align(intel, mt, tiling, mt->pitch);
 
           if (mt->compressed) {
-              qpitch = (y_pitch + ALIGN(minify(y_pitch), align_h) + 11 * align_h) / 4 * mt->pitch * mt->cpp;
+              qpitch = (y_pitch + ALIGN(minify(y_pitch), align_h) + 11 * align_h) / 4;
               mt->total_height = (y_pitch + ALIGN(minify(y_pitch), align_h) + 11 * align_h) / 4 * 6;
           } else {
-              qpitch = (y_pitch + ALIGN(minify(y_pitch), align_h) + 11 * align_h) * mt->pitch * mt->cpp;
+              qpitch = (y_pitch + ALIGN(minify(y_pitch), align_h) + 11 * align_h);
               mt->total_height = (y_pitch + ALIGN(minify(y_pitch), align_h) + 11 * align_h) * 6;
           }
 
@@ -102,7 +102,8 @@ GLboolean brw_miptree_layout(struct intel_context *intel,
                                            height, 1);
 
               for (q = 0; q < nr_images; q++)
-                  intel_miptree_set_image_offset_ex(mt, level, q, x, y, q * qpitch);
+                  intel_miptree_set_image_offset(mt, level, q,
+						 x, y + q * qpitch);
 
               if (mt->compressed)
                   img_height = MAX2(1, height/4);
diff --git a/src/mesa/drivers/dri/intel/intel_blit.c b/src/mesa/drivers/dri/intel/intel_blit.c
index 0c5be4c..ec4a5b4 100644
--- a/src/mesa/drivers/dri/intel/intel_blit.c
+++ b/src/mesa/drivers/dri/intel/intel_blit.c
@@ -441,6 +441,10 @@ intelClearWithBlit(GLcontext *ctx, GLbitfield mask)
                   intel_region_buffer(intel, irb->region,
                                       all ? INTEL_WRITE_FULL :
                                       INTEL_WRITE_PART);
+	       int x1 = b.x1 + irb->region->draw_x;
+	       int y1 = b.y1 + irb->region->draw_y;
+	       int x2 = b.x2 + irb->region->draw_x;
+	       int y2 = b.y2 + irb->region->draw_y;
 
                GLuint clearVal;
                GLint pitch, cpp;
@@ -449,11 +453,10 @@ intelClearWithBlit(GLcontext *ctx, GLbitfield mask)
                pitch = irb->region->pitch;
                cpp = irb->region->cpp;
 
-               DBG("%s dst:buf(%p)/%d+%d %d,%d sz:%dx%d\n",
+               DBG("%s dst:buf(%p)/%d %d,%d sz:%dx%d\n",
                    __FUNCTION__,
                    irb->region->buffer, (pitch * cpp),
-                   irb->region->draw_offset,
-                   b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1);
+                   x1, y1, x2 - x1, y2 - y1);
 
 	       BR13 = 0xf0 << 16;
 	       CMD = XY_COLOR_BLT_CMD;
@@ -526,17 +529,17 @@ intelClearWithBlit(GLcontext *ctx, GLbitfield mask)
                   buf, irb->Base.Name);
                 */
 
-               assert(b.x1 < b.x2);
-               assert(b.y1 < b.y2);
+               assert(x1 < x2);
+               assert(y1 < y2);
 
                BEGIN_BATCH(6, REFERENCES_CLIPRECTS);
                OUT_BATCH(CMD);
                OUT_BATCH(BR13);
-               OUT_BATCH((b.y1 << 16) | b.x1);
-               OUT_BATCH((b.y2 << 16) | b.x2);
+               OUT_BATCH((y1 << 16) | x1);
+               OUT_BATCH((y2 << 16) | x2);
                OUT_RELOC(write_buffer,
 			 I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER,
-                         irb->region->draw_offset);
+                         0);
                OUT_BATCH(clearVal);
                ADVANCE_BATCH();
                clearMask &= ~bufBit;    /* turn off bit, for faster loop exit */
diff --git a/src/mesa/drivers/dri/intel/intel_context.c b/src/mesa/drivers/dri/intel/intel_context.c
index fce42e9..ddb0550 100644
--- a/src/mesa/drivers/dri/intel/intel_context.c
+++ b/src/mesa/drivers/dri/intel/intel_context.c
@@ -839,7 +839,7 @@ intelDestroyContext(__DRIcontextPrivate * driContextPriv)
       _vbo_DestroyContext(&intel->ctx);
 
       _swrast_DestroyContext(&intel->ctx);
-      intel->Fallback = 0;      /* don't call _swrast_Flush later */
+      intel->Fallback = 0x0;      /* don't call _swrast_Flush later */
 
       intel_batchbuffer_free(intel->batch);
       intel->batch = NULL;
@@ -944,10 +944,23 @@ intelMakeCurrent(__DRIcontextPrivate * driContextPriv,
                  __DRIdrawablePrivate * driReadPriv)
 {
    __DRIscreenPrivate *psp = driDrawPriv->driScreenPriv;
+   struct intel_context *intel;
+   GET_CURRENT_CONTEXT(curCtx);
+
+   if (driContextPriv)
+      intel = (struct intel_context *) driContextPriv->driverPrivate;
+   else
+      intel = NULL;
+
+   /* According to the glXMakeCurrent() man page: "Pending commands to
+    * the previous context, if any, are flushed before it is released."
+    * But only flush if we're actually changing contexts.
+    */
+   if (intel_context(curCtx) && intel_context(curCtx) != intel) {
+      _mesa_flush(curCtx);
+   }
 
    if (driContextPriv) {
-      struct intel_context *intel =
-         (struct intel_context *) driContextPriv->driverPrivate;
       struct intel_framebuffer *intel_fb =
 	 (struct intel_framebuffer *) driDrawPriv->driverPrivate;
       GLframebuffer *readFb = (GLframebuffer *) driReadPriv->driverPrivate;
@@ -993,41 +1006,35 @@ intelMakeCurrent(__DRIcontextPrivate * driContextPriv,
 
       _mesa_make_current(&intel->ctx, &intel_fb->Base, readFb);
 
-      /* The drawbuffer won't always be updated by _mesa_make_current: 
-       */
-      if (intel->ctx.DrawBuffer == &intel_fb->Base) {
-
-	 if (intel->driReadDrawable != driReadPriv)
-	    intel->driReadDrawable = driReadPriv;
-
-	 if (intel->driDrawable != driDrawPriv) {
-	    if (driDrawPriv->swap_interval == (unsigned)-1) {
-	       int i;
-
-	       driDrawPriv->vblFlags = (intel->intelScreen->irq_active != 0)
-		  ? driGetDefaultVBlankFlags(&intel->optionCache)
-		 : VBLANK_FLAG_NO_IRQ;
-
-	       /* Prevent error printf if one crtc is disabled, this will
-		* be properly calculated in intelWindowMoved() next.
-		*/
-		driDrawPriv->vblFlags = intelFixupVblank(intel, driDrawPriv);
-
-	       (*psp->systemTime->getUST) (&intel_fb->swap_ust);
-	       driDrawableInitVBlank(driDrawPriv);
-	       intel_fb->vbl_waited = driDrawPriv->vblSeq;
-
-	       for (i = 0; i < 2; i++) {
-		  if (intel_fb->color_rb[i])
-		     intel_fb->color_rb[i]->vbl_pending = driDrawPriv->vblSeq;
-	       }
-	    }
-	    intel->driDrawable = driDrawPriv;
-	    intelWindowMoved(intel);
-	 }
+      intel->driReadDrawable = driReadPriv;
 
-	 intel_draw_buffer(&intel->ctx, &intel_fb->Base);
+      if (intel->driDrawable != driDrawPriv) {
+         if (driDrawPriv->swap_interval == (unsigned)-1) {
+            int i;
+
+            driDrawPriv->vblFlags = (intel->intelScreen->irq_active != 0)
+               ? driGetDefaultVBlankFlags(&intel->optionCache)
+               : VBLANK_FLAG_NO_IRQ;
+
+            /* Prevent error printf if one crtc is disabled, this will
+             * be properly calculated in intelWindowMoved() next.
+             */
+            driDrawPriv->vblFlags = intelFixupVblank(intel, driDrawPriv);
+
+            (*psp->systemTime->getUST) (&intel_fb->swap_ust);
+            driDrawableInitVBlank(driDrawPriv);
+            intel_fb->vbl_waited = driDrawPriv->vblSeq;
+
+            for (i = 0; i < 2; i++) {
+               if (intel_fb->color_rb[i])
+                  intel_fb->color_rb[i]->vbl_pending = driDrawPriv->vblSeq;
+            }
+         }
+         intel->driDrawable = driDrawPriv;
+         intelWindowMoved(intel);
       }
+
+      intel_draw_buffer(&intel->ctx, &intel_fb->Base);
    }
    else {
       _mesa_make_current(NULL, NULL, NULL);
diff --git a/src/mesa/drivers/dri/intel/intel_context.h b/src/mesa/drivers/dri/intel/intel_context.h
index 03e7cf3..d3acf6e 100644
--- a/src/mesa/drivers/dri/intel/intel_context.h
+++ b/src/mesa/drivers/dri/intel/intel_context.h
@@ -61,6 +61,10 @@ typedef void (*intel_line_func) (struct intel_context *, intelVertex *,
                                  intelVertex *);
 typedef void (*intel_point_func) (struct intel_context *, intelVertex *);
 
+/**
+ * Bits for intel->Fallback field
+ */
+/*@{*/
 #define INTEL_FALLBACK_DRAW_BUFFER	 0x1
 #define INTEL_FALLBACK_READ_BUFFER	 0x2
 #define INTEL_FALLBACK_DEPTH_BUFFER      0x4
@@ -68,8 +72,10 @@ typedef void (*intel_point_func) (struct intel_context *, intelVertex *);
 #define INTEL_FALLBACK_USER		 0x10
 #define INTEL_FALLBACK_RENDERMODE	 0x20
 #define INTEL_FALLBACK_TEXTURE   	 0x40
+#define INTEL_FALLBACK_DRIVER            0x1000  /**< first for drivers */
+/*@}*/
 
-extern void intelFallback(struct intel_context *intel, GLuint bit,
+extern void intelFallback(struct intel_context *intel, GLbitfield bit,
                           GLboolean mode);
 #define FALLBACK( intel, bit, mode ) intelFallback( intel, bit, mode )
 
@@ -171,7 +177,7 @@ struct intel_context
    struct dri_metaops meta;
 
    GLint refcount;
-   GLuint Fallback;
+   GLbitfield Fallback;  /**< mask of INTEL_FALLBACK_x bits */
    GLuint NewGLState;
 
    dri_bufmgr *bufmgr;
diff --git a/src/mesa/drivers/dri/intel/intel_fbo.c b/src/mesa/drivers/dri/intel/intel_fbo.c
index 804c034..a49868b 100644
--- a/src/mesa/drivers/dri/intel/intel_fbo.c
+++ b/src/mesa/drivers/dri/intel/intel_fbo.c
@@ -385,6 +385,7 @@ intel_create_renderbuffer(GLenum intFormat)
    default:
       _mesa_problem(NULL,
                     "Unexpected intFormat in intel_create_renderbuffer");
+      _mesa_free(irb);
       return NULL;
    }
 
@@ -571,7 +572,7 @@ intel_render_texture(GLcontext * ctx,
       = att->Texture->Image[att->CubeMapFace][att->TextureLevel];
    struct intel_renderbuffer *irb = intel_renderbuffer(att->Renderbuffer);
    struct intel_texture_image *intel_image;
-   GLuint imageOffset;
+   GLuint dst_x, dst_y;
 
    (void) fb;
 
@@ -618,18 +619,16 @@ intel_render_texture(GLcontext * ctx,
    }
 
    /* compute offset of the particular 2D image within the texture region */
-   imageOffset = intel_miptree_image_offset(intel_image->mt,
-                                            att->CubeMapFace,
-                                            att->TextureLevel);
-
-   if (att->Texture->Target == GL_TEXTURE_3D) {
-      const GLuint *offsets = intel_miptree_depth_offsets(intel_image->mt,
-                                                          att->TextureLevel);
-      imageOffset += offsets[att->Zoffset];
-   }
-
-   /* store that offset in the region */
-   intel_image->mt->region->draw_offset = imageOffset;
+   intel_miptree_get_image_offset(intel_image->mt,
+				  att->TextureLevel,
+				  att->CubeMapFace,
+				  att->Zoffset,
+				  &dst_x, &dst_y);
+
+   intel_image->mt->region->draw_offset = (dst_y * intel_image->mt->pitch +
+					   dst_x) * intel_image->mt->cpp;
+   intel_image->mt->region->draw_x = dst_x;
+   intel_image->mt->region->draw_y = dst_y;
 
    /* update drawing region, etc */
    intel_draw_buffer(ctx, fb);
diff --git a/src/mesa/drivers/dri/intel/intel_mipmap_tree.c b/src/mesa/drivers/dri/intel/intel_mipmap_tree.c
index c985da5..459e8fb 100644
--- a/src/mesa/drivers/dri/intel/intel_mipmap_tree.c
+++ b/src/mesa/drivers/dri/intel/intel_mipmap_tree.c
@@ -29,6 +29,9 @@
 #include "intel_mipmap_tree.h"
 #include "intel_regions.h"
 #include "intel_chipset.h"
+#ifndef I915
+#include "brw_state.h"
+#endif
 #include "main/enums.h"
 
 #define FILE_DEBUG_FLAG DEBUG_MIPTREE
@@ -131,8 +134,10 @@ intel_miptree_create(struct intel_context *intel,
    /*
     * pitch == 0 || height == 0  indicates the null texture
     */
-   if (!mt || !mt->pitch || !mt->total_height)
+   if (!mt || !mt->pitch || !mt->total_height) {
+      free(mt);
       return NULL;
+   }
 
    mt->region = intel_region_alloc(intel,
 				   tiling,
@@ -269,11 +274,25 @@ intel_miptree_release(struct intel_context *intel,
 
       DBG("%s deleting %p\n", __FUNCTION__, *mt);
 
+#ifndef I915
+      /* Free up cached binding tables holding a reference on our buffer, to
+       * avoid excessive memory consumption.
+       *
+       * This isn't as aggressive as we could be, as we'd like to do
+       * it from any time we free the last ref on a region.  But intel_region.c
+       * is context-agnostic.  Perhaps our constant state cache should be, as
+       * well.
+       */
+      brw_state_cache_bo_delete(&brw_context(&intel->ctx)->surface_cache,
+				(*mt)->region->buffer);
+#endif
+
       intel_region_release(&((*mt)->region));
 
-      for (i = 0; i < MAX_TEXTURE_LEVELS; i++)
-         if ((*mt)->level[i].image_offset)
-            free((*mt)->level[i].image_offset);
+      for (i = 0; i < MAX_TEXTURE_LEVELS; i++) {
+	 free((*mt)->level[i].x_offset);
+	 free((*mt)->level[i].y_offset);
+      }
 
       free(*mt);
    }
@@ -334,82 +353,58 @@ intel_miptree_set_level_info(struct intel_mipmap_tree *mt,
    mt->level[level].height = h;
    mt->level[level].depth = d;
    mt->level[level].level_offset = (x + y * mt->pitch) * mt->cpp;
+   mt->level[level].level_x = x;
+   mt->level[level].level_y = y;
    mt->level[level].nr_images = nr_images;
 
    DBG("%s level %d size: %d,%d,%d offset %d,%d (0x%x)\n", __FUNCTION__,
        level, w, h, d, x, y, mt->level[level].level_offset);
 
-   /* Not sure when this would happen, but anyway: 
-    */
-   if (mt->level[level].image_offset) {
-      free(mt->level[level].image_offset);
-      mt->level[level].image_offset = NULL;
-   }
-
    assert(nr_images);
+   assert(!mt->level[level].x_offset);
 
-   mt->level[level].image_offset = malloc(nr_images * sizeof(GLuint));
-   mt->level[level].image_offset[0] = 0;
+   mt->level[level].x_offset = malloc(nr_images * sizeof(GLuint));
+   mt->level[level].x_offset[0] = mt->level[level].level_x;
+   mt->level[level].y_offset = malloc(nr_images * sizeof(GLuint));
+   mt->level[level].y_offset[0] = mt->level[level].level_y;
 }
 
 
 void
-intel_miptree_set_image_offset_ex(struct intel_mipmap_tree *mt,
-                                  GLuint level, GLuint img,
-                                  GLuint x, GLuint y, 
-                                  GLuint offset)
+intel_miptree_set_image_offset(struct intel_mipmap_tree *mt,
+			       GLuint level, GLuint img,
+			       GLuint x, GLuint y)
 {
    if (img == 0 && level == 0)
       assert(x == 0 && y == 0);
 
    assert(img < mt->level[level].nr_images);
 
-   mt->level[level].image_offset[img] = (x + y * mt->pitch) * mt->cpp + offset;
+   mt->level[level].x_offset[img] = mt->level[level].level_x + x;
+   mt->level[level].y_offset[img] = mt->level[level].level_y + y;
 
-   DBG("%s level %d img %d pos %d,%d image_offset %x\n",
-       __FUNCTION__, level, img, x, y, mt->level[level].image_offset[img]);
+   DBG("%s level %d img %d pos %d,%d\n",
+       __FUNCTION__, level, img,
+       mt->level[level].x_offset[img], mt->level[level].y_offset[img]);
 }
 
 void
-intel_miptree_set_image_offset(struct intel_mipmap_tree *mt,
-			       GLuint level, GLuint img,
-			       GLuint x, GLuint y)
-{
-    intel_miptree_set_image_offset_ex(mt, level, img, x, y, 0);
-}
-
-
-/* Although we use the image_offset[] array to store relative offsets
- * to cube faces, Mesa doesn't know anything about this and expects
- * each cube face to be treated as a separate image.
- *
- * These functions present that view to mesa:
- */
-const GLuint *
-intel_miptree_depth_offsets(struct intel_mipmap_tree *mt, GLuint level)
-{
-   static const GLuint zero = 0;
-
-   if (mt->target != GL_TEXTURE_3D || mt->level[level].nr_images == 1)
-      return &zero;
-   else
-      return mt->level[level].image_offset;
-}
-
-
-GLuint
-intel_miptree_image_offset(struct intel_mipmap_tree *mt,
-			   GLuint face, GLuint level)
+intel_miptree_get_image_offset(struct intel_mipmap_tree *mt,
+			       GLuint level, GLuint face, GLuint depth,
+			       GLuint *x, GLuint *y)
 {
-   if (mt->target == GL_TEXTURE_CUBE_MAP_ARB)
-      return (mt->level[level].level_offset +
-	      mt->level[level].image_offset[face]);
-   else
-      return mt->level[level].level_offset;
+   if (mt->target == GL_TEXTURE_CUBE_MAP_ARB) {
+      *x = mt->level[level].x_offset[face];
+      *y = mt->level[level].y_offset[face];
+   } else if (mt->target == GL_TEXTURE_3D) {
+      *x = mt->level[level].x_offset[depth];
+      *y = mt->level[level].y_offset[depth];
+   } else {
+      *x = mt->level[level].x_offset[0];
+      *y = mt->level[level].y_offset[0];
+   }
 }
 
-
-
 /**
  * Map a teximage in a mipmap tree.
  * \param row_stride  returns row stride in bytes
@@ -425,6 +420,7 @@ intel_miptree_image_map(struct intel_context * intel,
                         GLuint level,
                         GLuint * row_stride, GLuint * image_offsets)
 {
+   GLuint x, y;
    DBG("%s \n", __FUNCTION__);
 
    if (row_stride)
@@ -433,17 +429,23 @@ intel_miptree_image_map(struct intel_context * intel,
    if (mt->target == GL_TEXTURE_3D) {
       int i;
 
-      for (i = 0; i < mt->level[level].depth; i++)
-	 image_offsets[i] = mt->level[level].image_offset[i] / mt->cpp;
+      for (i = 0; i < mt->level[level].depth; i++) {
+
+	 intel_miptree_get_image_offset(mt, level, face, i,
+					&x, &y);
+	 image_offsets[i] = x + y * mt->pitch;
+      }
+
+      return intel_region_map(intel, mt->region);
    } else {
       assert(mt->level[level].depth == 1);
-      assert(mt->target == GL_TEXTURE_CUBE_MAP ||
-	     mt->level[level].image_offset[0] == 0);
+      intel_miptree_get_image_offset(mt, level, face, 0,
+				     &x, &y);
       image_offsets[0] = 0;
-   }
 
-   return (intel_region_map(intel, mt->region) +
-           intel_miptree_image_offset(mt, face, level));
+      return intel_region_map(intel, mt->region) +
+	 (x + y * mt->pitch) * mt->cpp;
+   }
 }
 
 void
@@ -468,20 +470,19 @@ intel_miptree_image_data(struct intel_context *intel,
 			 GLuint src_image_pitch)
 {
    GLuint depth = dst->level[level].depth;
-   GLuint dst_offset = intel_miptree_image_offset(dst, face, level);
-   const GLuint *dst_depth_offset = intel_miptree_depth_offsets(dst, level);
    GLuint i;
-   GLuint height = 0;
 
    DBG("%s: %d/%d\n", __FUNCTION__, face, level);
    for (i = 0; i < depth; i++) {
+      GLuint dst_x, dst_y, height;
+
+      intel_miptree_get_image_offset(dst, level, face, i, &dst_x, &dst_y);
+
       height = dst->level[level].height;
       if(dst->compressed)
 	 height = (height + 3) / 4;
       intel_region_data(intel,
-			dst->region,
-			dst_offset + dst_depth_offset[i], /* dst_offset */
-			0, 0,                             /* dstx, dsty */
+			dst->region, 0, dst_x, dst_y,
 			src,
 			src_row_pitch,
 			0, 0,                             /* source x, y */
@@ -503,10 +504,7 @@ intel_miptree_image_copy(struct intel_context *intel,
    GLuint width = src->level[level].width;
    GLuint height = src->level[level].height;
    GLuint depth = src->level[level].depth;
-   GLuint dst_offset = intel_miptree_image_offset(dst, face, level);
-   GLuint src_offset = intel_miptree_image_offset(src, face, level);
-   const GLuint *dst_depth_offset = intel_miptree_depth_offsets(dst, level);
-   const GLuint *src_depth_offset = intel_miptree_depth_offsets(src, level);
+   GLuint src_x, src_y, dst_x, dst_y;
    GLuint i;
    GLboolean success;
 
@@ -519,22 +517,23 @@ intel_miptree_image_copy(struct intel_context *intel,
    }
 
    for (i = 0; i < depth; i++) {
+      intel_miptree_get_image_offset(src, level, face, i, &src_x, &src_y);
+      intel_miptree_get_image_offset(dst, level, face, i, &dst_x, &dst_y);
       success = intel_region_copy(intel,
-				  dst->region, dst_offset + dst_depth_offset[i],
-				  0, 0,
-				  src->region, src_offset + src_depth_offset[i],
-				  0, 0, width, height, GL_COPY);
+				  dst->region, 0, dst_x, dst_y,
+				  src->region, 0, src_x, src_y, width, height,
+				  GL_COPY);
       if (!success) {
 	 GLubyte *src_ptr, *dst_ptr;
 
 	 src_ptr = intel_region_map(intel, src->region);
 	 dst_ptr = intel_region_map(intel, dst->region);
 
-	 _mesa_copy_rect(dst_ptr + dst_offset + dst_depth_offset[i],
+	 _mesa_copy_rect(dst_ptr + dst->cpp * (dst_x + dst_y * dst->pitch),
 			 dst->cpp,
 			 dst->pitch,
 			 0, 0, width, height,
-			 src_ptr + src_offset + src_depth_offset[i],
+			 src_ptr + src->cpp * (src_x + src_y * src->pitch),
 			 src->pitch,
 			 0, 0);
 	 intel_region_unmap(intel, src->region);
diff --git a/src/mesa/drivers/dri/intel/intel_mipmap_tree.h b/src/mesa/drivers/dri/intel/intel_mipmap_tree.h
index c890b2a..3bce54d 100644
--- a/src/mesa/drivers/dri/intel/intel_mipmap_tree.h
+++ b/src/mesa/drivers/dri/intel/intel_mipmap_tree.h
@@ -70,6 +70,10 @@ struct intel_mipmap_level
     * always zero in that case.
     */
    GLuint level_offset;
+   /** Offset to this miptree level, used in computing x_offset. */
+   GLuint level_x;
+   /** Offset to this miptree level, used in computing y_offset. */
+   GLuint level_y;
    GLuint width;
    GLuint height;
    /** Depth of the mipmap at this level: 1 for 1D/2D/CUBE, n for 3D. */
@@ -86,7 +90,7 @@ struct intel_mipmap_level
     * compute the offsets of depth/cube images within a mipmap level,
     * so have to store them as a lookup table.
     */
-   GLuint *image_offset;
+   GLuint *x_offset, *y_offset;
 };
 
 struct intel_mipmap_tree
@@ -176,19 +180,10 @@ GLubyte *intel_miptree_image_map(struct intel_context *intel,
 void intel_miptree_image_unmap(struct intel_context *intel,
                                struct intel_mipmap_tree *mt);
 
-
-/* Return the linear offset of an image relative to the start of the
- * tree:
- */
-GLuint intel_miptree_image_offset(struct intel_mipmap_tree *mt,
-                                  GLuint face, GLuint level);
-
-/* Return pointers to each 2d slice within an image.  Indexed by depth
- * value.
- */
-const GLuint *intel_miptree_depth_offsets(struct intel_mipmap_tree *mt,
-                                          GLuint level);
-
+void
+intel_miptree_get_image_offset(struct intel_mipmap_tree *mt,
+			       GLuint level, GLuint face, GLuint depth,
+			       GLuint *x, GLuint *y);
 
 void intel_miptree_set_level_info(struct intel_mipmap_tree *mt,
                                   GLuint level,
@@ -196,16 +191,10 @@ void intel_miptree_set_level_info(struct intel_mipmap_tree *mt,
                                   GLuint x, GLuint y,
                                   GLuint w, GLuint h, GLuint d);
 
-void intel_miptree_set_image_offset_ex(struct intel_mipmap_tree *mt,
-                                       GLuint level,
-                                       GLuint img, GLuint x, GLuint y,
-                                       GLuint offset);
-
 void intel_miptree_set_image_offset(struct intel_mipmap_tree *mt,
                                     GLuint level,
                                     GLuint img, GLuint x, GLuint y);
 
-
 /* Upload an image into a tree
  */
 void intel_miptree_image_data(struct intel_context *intel,
diff --git a/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c b/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
index b543a0b..18e6ebd 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel_bitmap.c
@@ -435,13 +435,14 @@ intel_texture_bitmap(GLcontext * ctx,
    }
 
    /* Save GL state before we start setting up our drawing */
-   _mesa_PushAttrib(GL_ENABLE_BIT | GL_CURRENT_BIT |
-		    GL_VIEWPORT_BIT);
+   _mesa_PushAttrib(GL_ENABLE_BIT | GL_CURRENT_BIT | GL_POLYGON_BIT |
+                    GL_TEXTURE_BIT | GL_VIEWPORT_BIT);
    _mesa_PushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT |
 			  GL_CLIENT_PIXEL_STORE_BIT);
    old_active_texture = ctx->Texture.CurrentUnit;
 
    _mesa_Disable(GL_POLYGON_STIPPLE);
+   _mesa_PolygonMode(GL_FRONT_AND_BACK, GL_FILL);
 
    /* Upload our bitmap data to an alpha texture */
    _mesa_ActiveTextureARB(GL_TEXTURE0_ARB);
@@ -501,8 +502,6 @@ intel_texture_bitmap(GLcontext * ctx,
    meta_restore_vertex_program(&intel->meta);
 
    _mesa_PopClientAttrib();
-   _mesa_Disable(GL_TEXTURE_2D); /* asserted that it was disabled at entry */
-   _mesa_ActiveTextureARB(GL_TEXTURE0_ARB + old_active_texture);
    _mesa_PopAttrib();
 
    _mesa_DeleteTextures(1, &texname);
diff --git a/src/mesa/drivers/dri/intel/intel_pixel_read.c b/src/mesa/drivers/dri/intel/intel_pixel_read.c
index 8713463..e036736 100644
--- a/src/mesa/drivers/dri/intel/intel_pixel_read.c
+++ b/src/mesa/drivers/dri/intel/intel_pixel_read.c
@@ -236,14 +236,14 @@ do_blit_readpixels(GLcontext * ctx,
    intelFlush(&intel->ctx);
    LOCK_HARDWARE(intel);
 
-   if (intel->driDrawable->numClipRects) {
+   if (intel->driReadDrawable->numClipRects) {
       GLboolean all = (width * height * src->cpp == dst->Base.Size &&
                        x == 0 && dst_offset == 0);
 
       dri_bo *dst_buffer = intel_bufferobj_buffer(intel, dst,
 						  all ? INTEL_WRITE_FULL :
 						  INTEL_WRITE_PART);
-      __DRIdrawablePrivate *dPriv = intel->driDrawable;
+      __DRIdrawablePrivate *dPriv = intel->driReadDrawable;
       int nbox = dPriv->numClipRects;
       drm_clip_rect_t *box = dPriv->pClipRects;
       drm_clip_rect_t rect;
diff --git a/src/mesa/drivers/dri/intel/intel_regions.h b/src/mesa/drivers/dri/intel/intel_regions.h
index 0d379bd..535fcd7 100644
--- a/src/mesa/drivers/dri/intel/intel_regions.h
+++ b/src/mesa/drivers/dri/intel/intel_regions.h
@@ -62,6 +62,8 @@ struct intel_region
    GLuint map_refcount;  /**< Reference count for mapping */
 
    GLuint draw_offset; /**< Offset of drawing address within the region */
+   GLuint draw_x, draw_y; /**< Offset of drawing within the region */
+
    uint32_t tiling; /**< Which tiling mode the region is in */
    uint32_t bit_6_swizzle; /**< GEM flag for address swizzling requirement */
    drmAddress classic_map; /**< drmMap of the region when not in GEM mode */
diff --git a/src/mesa/drivers/dri/intel/intel_span.c b/src/mesa/drivers/dri/intel/intel_span.c
index 8df4990..e71366a 100644
--- a/src/mesa/drivers/dri/intel/intel_span.c
+++ b/src/mesa/drivers/dri/intel/intel_span.c
@@ -163,6 +163,9 @@ static uint32_t x_tile_swizzle(struct intel_renderbuffer *irb,
 	int	x_tile_number, y_tile_number;
 	int	tile_off, tile_base;
 	
+        x += irb->region->draw_x;
+        y += irb->region->draw_y;
+
 	tile_stride = (irb->region->pitch * irb->region->cpp) << 3;
 
 	xbyte = x * irb->region->cpp;
@@ -218,6 +221,9 @@ static uint32_t y_tile_swizzle(struct intel_renderbuffer *irb,
 	int	x_tile_number, y_tile_number;
 	int	tile_off, tile_base;
 	
+        x += irb->region->draw_x;
+        y += irb->region->draw_y;
+
 	tile_stride = (irb->region->pitch * irb->region->cpp) << 5;
 
 	xbyte = x * irb->region->cpp;
diff --git a/src/mesa/drivers/dri/intel/intel_syncobj.c b/src/mesa/drivers/dri/intel/intel_syncobj.c
index 1286fe9..0d7889d 100644
--- a/src/mesa/drivers/dri/intel/intel_syncobj.c
+++ b/src/mesa/drivers/dri/intel/intel_syncobj.c
@@ -114,7 +114,7 @@ static void intel_check_sync(GLcontext *ctx, struct gl_sync_object *s)
 {
    struct intel_sync_object *sync = (struct intel_sync_object *)s;
 
-   if (sync->bo && drm_intel_bo_busy(sync->bo)) {
+   if (sync->bo && !drm_intel_bo_busy(sync->bo)) {
       drm_intel_bo_unreference(sync->bo);
       sync->bo = NULL;
       s->StatusFlag = 1;
diff --git a/src/mesa/drivers/dri/intel/intel_tex_copy.c b/src/mesa/drivers/dri/intel/intel_tex_copy.c
index 74f7f58..95dee60 100644
--- a/src/mesa/drivers/dri/intel/intel_tex_copy.c
+++ b/src/mesa/drivers/dri/intel/intel_tex_copy.c
@@ -115,27 +115,29 @@ do_copy_texsubimage(struct intel_context *intel,
       drm_intel_bo *dst_bo = intel_region_buffer(intel,
 						 intelImage->mt->region,
 						 INTEL_WRITE_PART);
-      GLuint image_offset = intel_miptree_image_offset(intelImage->mt,
-                                                       intelImage->face,
-                                                       intelImage->level);
       const GLint orig_x = x;
       const GLint orig_y = y;
+      GLuint image_x, image_y;
       GLshort src_pitch;
 
+      intel_miptree_get_image_offset(intelImage->mt,
+				     intelImage->level,
+				     intelImage->face,
+				     0,
+				     &image_x, &image_y);
       /* Update dst for clipped src.  Need to also clip the source rect. */
       dstx += x - orig_x;
       dsty += y - orig_y;
 
       /* Can't blit to tiled buffers with non-tile-aligned offset. */
-      if (intelImage->mt->region->tiling != I915_TILING_NONE &&
-	  (image_offset & 4095) != 0) {
+      if (intelImage->mt->region->tiling == I915_TILING_Y) {
 	 UNLOCK_HARDWARE(intel);
 	 return GL_FALSE;
       }
 
       if (ctx->ReadBuffer->Name == 0) {
 	 /* reading from a window, adjust x, y */
-	 __DRIdrawablePrivate *dPriv = intel->driDrawable;
+	 const __DRIdrawablePrivate *dPriv = intel->driReadDrawable;
 	 y = dPriv->y + (dPriv->h - (y + height));
 	 x += dPriv->x;
 
@@ -156,13 +158,14 @@ do_copy_texsubimage(struct intel_context *intel,
 			     intelImage->mt->cpp,
 			     src_pitch,
 			     src->buffer,
-			     0,
+			     src->draw_offset,
 			     src->tiling,
 			     intelImage->mt->pitch,
 			     dst_bo,
-			     image_offset,
+			     0,
 			     intelImage->mt->region->tiling,
-			     x, y, dstx, dsty, width, height,
+			     x, y, image_x + dstx, image_y + dsty,
+			     width, height,
 			     GL_COPY)) {
 	 UNLOCK_HARDWARE(intel);
 	 return GL_FALSE;
diff --git a/src/mesa/drivers/dri/intel/intel_tex_image.c b/src/mesa/drivers/dri/intel/intel_tex_image.c
index c5f5220..2e0945c 100644
--- a/src/mesa/drivers/dri/intel/intel_tex_image.c
+++ b/src/mesa/drivers/dri/intel/intel_tex_image.c
@@ -204,7 +204,7 @@ try_pbo_upload(struct intel_context *intel,
 {
    struct intel_buffer_object *pbo = intel_buffer_object(unpack->BufferObj);
    GLuint src_offset, src_stride;
-   GLuint dst_offset, dst_stride;
+   GLuint dst_x, dst_y, dst_stride;
 
    if (unpack->BufferObj->Name == 0 ||
        intel->ctx._ImageTransferState ||
@@ -221,9 +221,9 @@ try_pbo_upload(struct intel_context *intel,
    else
       src_stride = width;
 
-   dst_offset = intel_miptree_image_offset(intelImage->mt,
-                                           intelImage->face,
-                                           intelImage->level);
+   intel_miptree_get_image_offset(intelImage->mt, intelImage->level,
+				  intelImage->face, 0,
+				  &dst_x, &dst_y);
 
    dst_stride = intelImage->mt->pitch;
 
@@ -239,8 +239,8 @@ try_pbo_upload(struct intel_context *intel,
       if (!intelEmitCopyBlit(intel,
 			     intelImage->mt->cpp,
 			     src_stride, src_buffer, src_offset, GL_FALSE,
-			     dst_stride, dst_buffer, dst_offset, GL_FALSE,
-			     0, 0, 0, 0, width, height,
+			     dst_stride, dst_buffer, 0, GL_FALSE,
+			     0, 0, dst_x, dst_y, width, height,
 			     GL_COPY)) {
 	 UNLOCK_HARDWARE(intel);
 	 return GL_FALSE;
@@ -262,7 +262,7 @@ try_pbo_zcopy(struct intel_context *intel,
 {
    struct intel_buffer_object *pbo = intel_buffer_object(unpack->BufferObj);
    GLuint src_offset, src_stride;
-   GLuint dst_offset, dst_stride;
+   GLuint dst_x, dst_y, dst_stride;
 
    if (unpack->BufferObj->Name == 0 ||
        intel->ctx._ImageTransferState ||
@@ -279,13 +279,14 @@ try_pbo_zcopy(struct intel_context *intel,
    else
       src_stride = width;
 
-   dst_offset = intel_miptree_image_offset(intelImage->mt,
-                                           intelImage->face,
-                                           intelImage->level);
+   intel_miptree_get_image_offset(intelImage->mt, intelImage->level,
+				  intelImage->face, 0,
+				  &dst_x, &dst_y);
 
    dst_stride = intelImage->mt->pitch;
 
-   if (src_stride != dst_stride || dst_offset != 0 || src_offset != 0) {
+   if (src_stride != dst_stride || dst_x != 0 || dst_y != 0 ||
+       src_offset != 0) {
       DBG("%s: failure 2\n", __FUNCTION__);
       return GL_FALSE;
    }
diff --git a/src/mesa/drivers/dri/r200/r200_state.c b/src/mesa/drivers/dri/r200/r200_state.c
index 76852e3..d28e96d 100644
--- a/src/mesa/drivers/dri/r200/r200_state.c
+++ b/src/mesa/drivers/dri/r200/r200_state.c
@@ -1578,13 +1578,6 @@ static void r200ClearStencil( GLcontext *ctx, GLint s )
  * Window position and viewport transformation
  */
 
-/*
- * To correctly position primitives:
- */
-#define SUBPIXEL_X 0.125
-#define SUBPIXEL_Y 0.125
-
-
 /**
  * Called when window size or position changes or viewport or depth range
  * state is changed.  We update the hardware viewport state here.
@@ -1609,9 +1602,9 @@ void r200UpdateWindow( GLcontext *ctx )
    }
 
    float_ui32_type sx = { v[MAT_SX] };
-   float_ui32_type tx = { v[MAT_TX] + xoffset + SUBPIXEL_X };
+   float_ui32_type tx = { v[MAT_TX] + xoffset };
    float_ui32_type sy = { v[MAT_SY] * y_scale };
-   float_ui32_type ty = { (v[MAT_TY] * y_scale) + y_bias + SUBPIXEL_Y };
+   float_ui32_type ty = { (v[MAT_TY] * y_scale) + y_bias };
    float_ui32_type sz = { v[MAT_SZ] * depthScale };
    float_ui32_type tz = { v[MAT_TZ] * depthScale };
 
@@ -1680,8 +1673,8 @@ void r200UpdateViewportOffset( GLcontext *ctx )
    float_ui32_type tx;
    float_ui32_type ty;
 
-   tx.f = v[MAT_TX] + xoffset + SUBPIXEL_X;
-   ty.f = (- v[MAT_TY]) + yoffset + SUBPIXEL_Y;
+   tx.f = v[MAT_TX] + xoffset;
+   ty.f = (- v[MAT_TY]) + yoffset;
 
    if ( rmesa->hw.vpt.cmd[VPT_SE_VPORT_XOFFSET] != tx.ui32 ||
 	rmesa->hw.vpt.cmd[VPT_SE_VPORT_YOFFSET] != ty.ui32 )
diff --git a/src/mesa/drivers/dri/r300/r300_context.c b/src/mesa/drivers/dri/r300/r300_context.c
index 2ea1b82..9df3897 100644
--- a/src/mesa/drivers/dri/r300/r300_context.c
+++ b/src/mesa/drivers/dri/r300/r300_context.c
@@ -374,11 +374,21 @@ static void r300InitConstValues(GLcontext *ctx, radeonScreenPtr screen)
 	if (screen->chip_family >= CHIP_FAMILY_RV515) {
 		ctx->Const.FragmentProgram.MaxNativeTemps = R500_PFS_NUM_TEMP_REGS;
 		ctx->Const.FragmentProgram.MaxNativeAttribs = 11;	/* copy i915... */
-		ctx->Const.FragmentProgram.MaxNativeParameters = R500_PFS_NUM_CONST_REGS;
-		ctx->Const.FragmentProgram.MaxNativeAluInstructions = R500_PFS_MAX_INST;
-		ctx->Const.FragmentProgram.MaxNativeTexInstructions = R500_PFS_MAX_INST;
-		ctx->Const.FragmentProgram.MaxNativeInstructions = R500_PFS_MAX_INST;
-		ctx->Const.FragmentProgram.MaxNativeTexIndirections = R500_PFS_MAX_INST;
+
+		/* The hardware limits are higher than this,
+		 * but the non-KMS DRM interface artificially limits us
+		 * to this many instructions.
+		 *
+		 * We could of course work around it in the KMS path,
+		 * but it would be a mess, so it seems wiser
+		 * to leave it as is. Going forward, the Gallium driver
+		 * will not be subject to these limitations.
+		 */
+		ctx->Const.FragmentProgram.MaxNativeParameters = 255;
+		ctx->Const.FragmentProgram.MaxNativeAluInstructions = 255;
+		ctx->Const.FragmentProgram.MaxNativeTexInstructions = 255;
+		ctx->Const.FragmentProgram.MaxNativeInstructions = 255;
+		ctx->Const.FragmentProgram.MaxNativeTexIndirections = 255;
 		ctx->Const.FragmentProgram.MaxNativeAddressRegs = 0;
 	} else {
 		ctx->Const.FragmentProgram.MaxNativeTemps = R300_PFS_NUM_TEMP_REGS;
diff --git a/src/mesa/drivers/dri/r300/r300_fragprog_common.c b/src/mesa/drivers/dri/r300/r300_fragprog_common.c
index 0bdc90b..70c9252 100644
--- a/src/mesa/drivers/dri/r300/r300_fragprog_common.c
+++ b/src/mesa/drivers/dri/r300/r300_fragprog_common.c
@@ -239,6 +239,19 @@ static void translate_fragment_program(GLcontext *ctx, struct r300_fragment_prog
 	rewriteFog(&compiler, fp);
 
 	r3xx_compile_fragment_program(&compiler);
+
+	if (compiler.is_r500) {
+		/* We need to support the non-KMS DRM interface, which
+		 * artificially limits the number of instructions and
+		 * constants which are available to us.
+		 *
+		 * See also the comment in r300_context.c where we
+		 * set the MAX_NATIVE_xxx values.
+		 */
+		if (fp->code.code.r500.inst_end >= 255 || fp->code.constants.Count > 255)
+			rc_error(&compiler.Base, "Program is too big (upgrade to r300g to avoid this limitation).\n");
+	}
+
 	fp->error = compiler.Base.Error;
 
 	fp->InputsRead = compiler.Base.Program.InputsRead;
diff --git a/src/mesa/drivers/dri/r300/r300_texstate.c b/src/mesa/drivers/dri/r300/r300_texstate.c
index f030451..65cabcc 100644
--- a/src/mesa/drivers/dri/r300/r300_texstate.c
+++ b/src/mesa/drivers/dri/r300/r300_texstate.c
@@ -225,10 +225,10 @@ static void setup_hardware_state(r300ContextPtr rmesa, radeonTexObj *t)
 	if (t->image_override && t->bo)
 		return;
 
-	t->pp_txsize = (((firstImage->Width - 1) << R300_TX_WIDTHMASK_SHIFT)
-			| ((firstImage->Height - 1) << R300_TX_HEIGHTMASK_SHIFT)
-			| ((firstImage->DepthLog2) << R300_TX_DEPTHMASK_SHIFT)
-			| ((t->mt->lastLevel - t->mt->firstLevel) << R300_TX_MAX_MIP_LEVEL_SHIFT));
+	t->pp_txsize = (((R300_TX_WIDTHMASK_MASK & ((firstImage->Width - 1) << R300_TX_WIDTHMASK_SHIFT)))
+			| ((R300_TX_HEIGHTMASK_MASK & ((firstImage->Height - 1) << R300_TX_HEIGHTMASK_SHIFT)))
+			| ((R300_TX_DEPTHMASK_MASK & ((firstImage->DepthLog2) << R300_TX_DEPTHMASK_SHIFT)))
+			| ((R300_TX_MAX_MIP_LEVEL_MASK & ((t->mt->lastLevel - t->mt->firstLevel) << R300_TX_MAX_MIP_LEVEL_SHIFT))));
 
 	t->tile_bits = 0;
 
@@ -248,8 +248,12 @@ static void setup_hardware_state(r300ContextPtr rmesa, radeonTexObj *t)
 	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
 	    if (firstImage->Width > 2048)
 		t->pp_txpitch |= R500_TXWIDTH_BIT11;
+            else
+		t->pp_txpitch &= ~R500_TXWIDTH_BIT11;
 	    if (firstImage->Height > 2048)
 		t->pp_txpitch |= R500_TXHEIGHT_BIT11;
+            else
+		t->pp_txpitch &= ~R500_TXHEIGHT_BIT11;
 	}
 }
 
@@ -479,16 +483,20 @@ void r300SetTexBuffer2(__DRIcontext *pDRICtx, GLint target, GLint glx_texture_fo
 		break;
 	}
 	pitch_val--;
-	t->pp_txsize = ((rb->base.Width - 1) << R300_TX_WIDTHMASK_SHIFT) |
-              ((rb->base.Height - 1) << R300_TX_HEIGHTMASK_SHIFT);
+	t->pp_txsize = (((R300_TX_WIDTHMASK_MASK & ((rb->base.Width - 1) << R300_TX_WIDTHMASK_SHIFT)))
+			| ((R300_TX_HEIGHTMASK_MASK & ((rb->base.Height - 1) << R300_TX_HEIGHTMASK_SHIFT))));
 	t->pp_txsize |= R300_TX_SIZE_TXPITCH_EN;
 	t->pp_txpitch |= pitch_val;
 
 	if (rmesa->radeon.radeonScreen->chip_family >= CHIP_FAMILY_RV515) {
 	    if (rb->base.Width > 2048)
 		t->pp_txpitch |= R500_TXWIDTH_BIT11;
+            else
+		t->pp_txpitch &= ~R500_TXWIDTH_BIT11;
 	    if (rb->base.Height > 2048)
 		t->pp_txpitch |= R500_TXHEIGHT_BIT11;
+            else
+		t->pp_txpitch &= ~R500_TXHEIGHT_BIT11;
 	}
 	t->validated = GL_TRUE;
 	_mesa_unlock_texture(radeon->glCtx, texObj);
diff --git a/src/mesa/drivers/dri/r300/r300_vertprog.c b/src/mesa/drivers/dri/r300/r300_vertprog.c
index 2f7b67c..ed8b788 100644
--- a/src/mesa/drivers/dri/r300/r300_vertprog.c
+++ b/src/mesa/drivers/dri/r300/r300_vertprog.c
@@ -62,12 +62,6 @@ static int r300VertexProgUpdateParams(GLcontext * ctx, struct r300_vertex_progra
 		}
 	}
 
-	if (vp->code.constants.Count * 4 > VSF_MAX_FRAGMENT_LENGTH) {
-		/* Should have checked this earlier... */
-		fprintf(stderr, "%s:Params exhausted\n", __FUNCTION__);
-		_mesa_exit(-1);
-	}
-
 	for(i = 0; i < vp->code.constants.Count; ++i) {
 		const float * src = 0;
 		const struct rc_constant * constant = &vp->code.constants.Constants[i];
@@ -281,6 +275,11 @@ static struct r300_vertex_program *build_program(GLcontext *ctx,
 	}
 
 	r3xx_compile_vertex_program(&compiler);
+
+	if (vp->code.constants.Count > ctx->Const.VertexProgram.MaxParameters) {
+		rc_error(&compiler.Base, "Program exceeds constant buffer size limit\n");
+	}
+
 	vp->error = compiler.Base.Error;
 
 	vp->Base->Base.InputsRead = vp->code.InputsRead;
@@ -334,7 +333,6 @@ struct r300_vertex_program * r300SelectAndTranslateVertexShader(GLcontext *ctx)
 #define bump_vpu_count(ptr, new_count)   do { \
 		drm_r300_cmd_header_t* _p=((drm_r300_cmd_header_t*)(ptr)); \
 		int _nc=(new_count)/4; \
-		assert(_nc < 256); \
 		if(_nc>_p->vpu.count)_p->vpu.count=_nc; \
 	} while(0)
 
diff --git a/src/mesa/drivers/dri/r600/r600_cmdbuf.c b/src/mesa/drivers/dri/r600/r600_cmdbuf.c
index 3cfe03a..d27a324 100644
--- a/src/mesa/drivers/dri/r600/r600_cmdbuf.c
+++ b/src/mesa/drivers/dri/r600/r600_cmdbuf.c
@@ -254,7 +254,7 @@ static int r600_cs_process_relocs(struct radeon_cs *cs,
     relocs = (struct r600_cs_reloc_legacy *)cs->relocs;
 restart:
     for (i = 0; i < cs->crelocs; i++) {
-            uint32_t soffset, eoffset, asicoffset;
+            uint32_t soffset, eoffset;
 
             r = radeon_bo_legacy_validate(relocs[i].base.bo,
 					  &soffset, &eoffset);
@@ -262,24 +262,12 @@ restart:
 		    goto restart;
             }
             if (r) {
-		    fprintf(stderr, "validated %p [0x%08X, 0x%08X]\n",
+		    fprintf(stderr, "invalid bo(%p) [0x%08X, 0x%08X]\n",
 			    relocs[i].base.bo, soffset, eoffset);
 		    return r;
             }
-            asicoffset = soffset;
 
 	    for (j = 0; j < relocs[i].cindices; j++) {
-		    if (asicoffset >= eoffset) {
-			    /*                radeon_bo_debug(relocs[i].base.bo, 12); */
-			    fprintf(stderr, "validated %p [0x%08X, 0x%08X]\n",
-				    relocs[i].base.bo, soffset, eoffset);
-			    fprintf(stderr, "above end: %p 0x%08X 0x%08X\n",
-				    relocs[i].base.bo,
-				    cs->packets[relocs[i].indices[j]],
-				    eoffset);
-			    exit(0);
-			    return -EINVAL;
-		    }
 		    /* pkt3 nop header in ib chunk */
 		    cs->packets[relocs[i].reloc_indices[j]] = 0xC0001000;
 		    /* reloc index in ib chunk */
@@ -287,7 +275,7 @@ restart:
 	    }
 
 	    /* asic offset in reloc chunk */ /* see alex drm r600_nomm_relocate */
-	    reloc_chunk[offset_dw] = asicoffset;
+	    reloc_chunk[offset_dw] = soffset;
 	    reloc_chunk[offset_dw + 3] = 0;
 
 	    offset_dw += 4;
diff --git a/src/mesa/drivers/dri/r600/r600_texstate.c b/src/mesa/drivers/dri/r600/r600_texstate.c
index bcb8d7c..a30703e 100644
--- a/src/mesa/drivers/dri/r600/r600_texstate.c
+++ b/src/mesa/drivers/dri/r600/r600_texstate.c
@@ -721,7 +721,9 @@ void r600SetTexOffset(__DRIcontext * pDRICtx, GLint texname,
 	struct gl_texture_object *tObj =
 	    _mesa_lookup_texture(rmesa->radeon.glCtx, texname);
 	radeonTexObjPtr t = radeon_tex_obj(tObj);
-	uint32_t pitch_val, size;
+	int firstlevel = t->mt ? t->mt->firstLevel : 0;
+	const struct gl_texture_image *firstImage;
+	uint32_t pitch_val, size, row_align, bpp;
 
 	if (!tObj)
 		return;
@@ -731,7 +733,13 @@ void r600SetTexOffset(__DRIcontext * pDRICtx, GLint texname,
 	if (!offset)
 		return;
 
-	size = pitch;//h * w * (depth / 8);
+	bpp = depth / 8;
+	if (bpp == 3) 
+		bpp = 4;
+
+	firstImage = t->base.Image[0][firstlevel];
+	row_align = rmesa->radeon.texture_row_align - 1;
+	size = ((firstImage->Width * bpp + row_align) & ~row_align) * firstImage->Height;
 	if (t->bo) {
 		radeon_bo_unref(t->bo);
 		t->bo = NULL;
diff --git a/src/mesa/drivers/dri/r600/r700_assembler.c b/src/mesa/drivers/dri/r600/r700_assembler.c
index 00eda54..6ff08e1 100644
--- a/src/mesa/drivers/dri/r600/r700_assembler.c
+++ b/src/mesa/drivers/dri/r600/r700_assembler.c
@@ -336,7 +336,8 @@ unsigned int r700GetNumOperands(r700_AssemblerBase* pAsm)
 
     switch (pAsm->D.dst.opcode)
     {
-    case SQ_OP2_INST_ADD:                          
+    case SQ_OP2_INST_ADD:
+    case SQ_OP2_INST_KILLGT:
     case SQ_OP2_INST_MUL: 
     case SQ_OP2_INST_MAX:
     case SQ_OP2_INST_MIN:
@@ -354,9 +355,9 @@ unsigned int r700GetNumOperands(r700_AssemblerBase* pAsm)
         return 2;  
 
     case SQ_OP2_INST_MOV: 
+    case SQ_OP2_INST_MOVA_FLOOR:
     case SQ_OP2_INST_FRACT:
     case SQ_OP2_INST_FLOOR:
-    case SQ_OP2_INST_KILLGT:
     case SQ_OP2_INST_EXP_IEEE:
     case SQ_OP2_INST_LOG_CLAMPED:
     case SQ_OP2_INST_LOG_IEEE:
@@ -1180,8 +1181,10 @@ GLboolean tex_src(r700_AssemblerBase *pAsm)
         case PROGRAM_INPUT:
             switch (pILInst->SrcReg[0].Index)
             {
+                case FRAG_ATTRIB_WPOS:
                 case FRAG_ATTRIB_COL0:
                 case FRAG_ATTRIB_COL1:
+                case FRAG_ATTRIB_FOGC:
                 case FRAG_ATTRIB_TEX0:
                 case FRAG_ATTRIB_TEX1:
                 case FRAG_ATTRIB_TEX2:
@@ -1194,7 +1197,16 @@ GLboolean tex_src(r700_AssemblerBase *pAsm)
                     pAsm->S[0].src.reg   =
                         pAsm->uiFP_AttributeMap[pILInst->SrcReg[0].Index];
                     pAsm->S[0].src.rtype = SRC_REG_INPUT;
-                break;
+                    break;
+                case FRAG_ATTRIB_FACE:
+                    fprintf(stderr, "FRAG_ATTRIB_FACE unsupported\n");
+                    break;
+                case FRAG_ATTRIB_PNTC:
+                    fprintf(stderr, "FRAG_ATTRIB_PNTC unsupported\n");
+                    break;
+                case FRAG_ATTRIB_VAR0:
+                    fprintf(stderr, "FRAG_ATTRIB_VAR0 unsupported\n");
+                    break;
             }
         break;
         }
@@ -2053,7 +2065,7 @@ GLboolean assemble_alu_instruction(r700_AssemblerBase *pAsm)
         }
 
         //other bits
-        alu_instruction_ptr->m_Word0.f.index_mode = SQ_INDEX_LOOP;
+        alu_instruction_ptr->m_Word0.f.index_mode = SQ_INDEX_AR_X;
 
         if(   (is_single_scalar_operation == GL_TRUE) 
            || (GL_TRUE == bSplitInst) )
@@ -2387,6 +2399,35 @@ GLboolean assemble_ADD(r700_AssemblerBase *pAsm)
     return GL_TRUE;
 }
 
+GLboolean assemble_ARL(r700_AssemblerBase *pAsm)
+{ /* TODO: ar values dont' persist between clauses */
+    if( GL_FALSE == checkop1(pAsm) )
+    {
+        return GL_FALSE;
+    }
+
+    pAsm->D.dst.opcode = SQ_OP2_INST_MOVA_FLOOR;
+    setaddrmode_PVSDST(&(pAsm->D.dst), ADDR_ABSOLUTE);
+    pAsm->D.dst.rtype = DST_REG_TEMPORARY;
+    pAsm->D.dst.reg = 0;
+    pAsm->D.dst.writex = 0;
+    pAsm->D.dst.writey = 0;
+    pAsm->D.dst.writez = 0;
+    pAsm->D.dst.writew = 0;
+
+    if( GL_FALSE == assemble_src(pAsm, 0, -1) )
+    {
+        return GL_FALSE;
+    }
+
+    if( GL_FALSE == next_ins(pAsm) )
+    {
+        return GL_FALSE;
+    }
+
+    return GL_TRUE;
+}
+
 GLboolean assemble_BAD(char *opcode_str) 
 {
     radeon_error("Not yet implemented instruction (%s)\n", opcode_str);
@@ -2508,7 +2549,7 @@ GLboolean assemble_DOT(r700_AssemblerBase *pAsm)
     }
     else if(pAsm->pILInst[pAsm->uiCurInst].Opcode == OPCODE_DPH) 
     {
-        onecomp_PVSSRC(&(pAsm->S[1].src), 3);
+        onecomp_PVSSRC(&(pAsm->S[0].src), 3);
     } 
 
     if ( GL_FALSE == next_ins(pAsm) ) 
@@ -2617,15 +2658,15 @@ GLboolean assemble_FRC(r700_AssemblerBase *pAsm)
  
 GLboolean assemble_KIL(r700_AssemblerBase *pAsm)
 {
+    /* TODO: doc says KILL has to be last(end) ALU clause */
+    
     checkop1(pAsm);
 
     pAsm->D.dst.opcode = SQ_OP2_INST_KILLGT;  
-  
-    if ( GL_FALSE == assemble_dst(pAsm) )
-    {
-        return GL_FALSE;
-    }
 
+    setaddrmode_PVSDST(&(pAsm->D.dst), ADDR_ABSOLUTE);
+    pAsm->D.dst.rtype = DST_REG_TEMPORARY;
+    pAsm->D.dst.reg   = 0;
     pAsm->D.dst.writex = 0;
     pAsm->D.dst.writey = 0;
     pAsm->D.dst.writez = 0;
@@ -2638,20 +2679,11 @@ GLboolean assemble_KIL(r700_AssemblerBase *pAsm)
     setswizzle_PVSSRC(&(pAsm->S[0].src), SQ_SEL_0);
     noneg_PVSSRC(&(pAsm->S[0].src));
 
-    pAsm->S[1].src.rtype = SRC_REG_TEMPORARY;
-
-    if(PROGRAM_TEMPORARY == pAsm->pILInst[pAsm->uiCurInst].DstReg.File)
+    if ( GL_FALSE == assemble_src(pAsm, 0, 1) )
     {
-        pAsm->S[1].src.reg = pAsm->pILInst[pAsm->uiCurInst].DstReg.Index + pAsm->starting_temp_register_number;
-    }
-    else
-    {   //PROGRAM_OUTPUT
-        pAsm->S[1].src.reg = pAsm->uiFP_OutputMap[pAsm->pILInst[pAsm->uiCurInst].DstReg.Index];
+        return GL_FALSE;
     }
   
-    setaddrmode_PVSSRC(&(pAsm->S[1].src), ADDR_ABSOLUTE);
-    noswizzle_PVSSRC(&(pAsm->S[1].src));
-  
     if ( GL_FALSE == next_ins(pAsm) )
     {
         return GL_FALSE;
@@ -2908,6 +2940,7 @@ GLboolean assemble_LIT(r700_AssemblerBase *pAsm)
     pAsm->S[0].src.rtype = srcType;
     pAsm->S[0].src.reg   = srcReg;
     setaddrmode_PVSSRC(&(pAsm->S[0].src), ADDR_ABSOLUTE);
+    swizzleagain_PVSSRC(&(pAsm->S[0].src), SQ_SEL_X, SQ_SEL_X, SQ_SEL_X, SQ_SEL_X);
     pAsm->S[1].src.rtype = SRC_REG_TEMPORARY;
     pAsm->S[1].src.reg   = tmp;
     setaddrmode_PVSSRC(&(pAsm->S[1].src), ADDR_ABSOLUTE);
@@ -3809,8 +3842,7 @@ GLboolean AssembleInstr(GLuint uiNumberInsts,
             break;  
 
         case OPCODE_ARL: 
-            radeon_error("Not yet implemented instruction OPCODE_ARL \n");
-            //if ( GL_FALSE == assemble_BAD("ARL") ) 
+            if ( GL_FALSE == assemble_ARL(pR700AsmCode) ) 
                 return GL_FALSE;
             break;
         case OPCODE_ARR: 
@@ -4155,6 +4187,7 @@ GLboolean Process_Fragment_Exports(r700_AssemblerBase *pR700AsmCode,
                                    GLbitfield          OutputsWritten)  
 { 
     unsigned int unBit;
+    GLuint export_count = 0;
 
     if(pR700AsmCode->depth_export_register_number >= 0) 
     {
@@ -4176,6 +4209,7 @@ GLboolean Process_Fragment_Exports(r700_AssemblerBase *pR700AsmCode,
         {
             return GL_FALSE;
         }
+        export_count++;
 	}
 	unBit = 1 << FRAG_RESULT_DEPTH;
 	if(OutputsWritten & unBit)
@@ -4189,8 +4223,15 @@ GLboolean Process_Fragment_Exports(r700_AssemblerBase *pR700AsmCode,
         {
             return GL_FALSE;
         }
+        export_count++;
 	}
-
+    /* Need to export something, otherwise we'll hang
+     * results are undefined anyway */
+    if(export_count == 0)
+    {
+        Process_Export(pR700AsmCode, SQ_EXPORT_PIXEL, 0, 1, 0, GL_FALSE);
+    }
+    
     if(pR700AsmCode->cf_last_export_ptr != NULL) 
     {
         pR700AsmCode->cf_last_export_ptr->m_Word1.f.cf_inst        = SQ_CF_INST_EXPORT_DONE;
diff --git a/src/mesa/drivers/dri/r600/r700_assembler.h b/src/mesa/drivers/dri/r600/r700_assembler.h
index 73bb8ba..d639592 100644
--- a/src/mesa/drivers/dri/r600/r700_assembler.h
+++ b/src/mesa/drivers/dri/r600/r700_assembler.h
@@ -461,6 +461,7 @@ GLboolean next_ins(r700_AssemblerBase *pAsm);
 GLboolean assemble_math_function(r700_AssemblerBase* pAsm, BITS opcode);
 GLboolean assemble_ABS(r700_AssemblerBase *pAsm);
 GLboolean assemble_ADD(r700_AssemblerBase *pAsm);
+GLboolean assemble_ARL(r700_AssemblerBase *pAsm);
 GLboolean assemble_BAD(char *opcode_str);
 GLboolean assemble_CMP(r700_AssemblerBase *pAsm);
 GLboolean assemble_COS(r700_AssemblerBase *pAsm);
diff --git a/src/mesa/drivers/dri/r600/r700_fragprog.c b/src/mesa/drivers/dri/r600/r700_fragprog.c
index 78ce3ae..0f549ea 100644
--- a/src/mesa/drivers/dri/r600/r700_fragprog.c
+++ b/src/mesa/drivers/dri/r600/r700_fragprog.c
@@ -135,15 +135,19 @@ GLboolean Find_Instruction_Dependencies_fp(struct r700_fragment_program *fp,
 {
     GLuint i, j;
     GLint * puiTEMPwrites;
+    GLint * puiTEMPreads;
     struct prog_instruction * pILInst;
     InstDeps         *pInstDeps;
     struct prog_instruction * texcoord_DepInst;
     GLint              nDepInstID;
 
     puiTEMPwrites = (GLint*) MALLOC(sizeof(GLuint)*mesa_fp->Base.NumTemporaries);
+    puiTEMPreads = (GLint*) MALLOC(sizeof(GLuint)*mesa_fp->Base.NumTemporaries);
+
     for(i=0; i<mesa_fp->Base.NumTemporaries; i++)
     {
         puiTEMPwrites[i] = -1;
+        puiTEMPreads[i] = -1;
     }
 
     pInstDeps = (InstDeps*)MALLOC(sizeof(InstDeps)*mesa_fp->Base.NumInstructions);
@@ -167,6 +171,11 @@ GLboolean Find_Instruction_Dependencies_fp(struct r700_fragment_program *fp,
             {
                 //Set dep.
                 pInstDeps[i].nSrcDeps[j] = puiTEMPwrites[pILInst->SrcReg[j].Index];
+                //Set first read
+                if(puiTEMPreads[pILInst->SrcReg[j].Index] < 0 )
+                {
+                    puiTEMPreads[pILInst->SrcReg[j].Index] = i;
+                }
             }
             else
             {
@@ -177,8 +186,6 @@ GLboolean Find_Instruction_Dependencies_fp(struct r700_fragment_program *fp,
 
     fp->r700AsmCode.pInstDeps = pInstDeps;
 
-    FREE(puiTEMPwrites);
-
     //Find dep for tex inst    
     for(i=0; i<mesa_fp->Base.NumInstructions; i++)
     {
@@ -203,9 +210,25 @@ GLboolean Find_Instruction_Dependencies_fp(struct r700_fragment_program *fp,
                 {   //... other deps?
                 }
             }
+            // make sure that we dont overwrite src used earlier
+            nDepInstID = puiTEMPreads[pILInst->DstReg.Index];
+            if(nDepInstID < i)
+            {
+                pInstDeps[i].nDstDep = puiTEMPreads[pILInst->DstReg.Index];
+                texcoord_DepInst = &(mesa_fp->Base.Instructions[nDepInstID]);
+                if(GL_TRUE == IsAlu(texcoord_DepInst->Opcode) )
+                {
+                    pInstDeps[nDepInstID].nDstDep = i;
+                }
+ 
+            }
+
         }
 	}
 
+    FREE(puiTEMPwrites);
+    FREE(puiTEMPreads);
+
     return GL_TRUE;
 }
 
@@ -251,7 +274,15 @@ GLboolean r700TranslateFragmentShader(struct r700_fragment_program *fp,
 		number_of_colors_exported--;
 	}
 
-	fp->r700Shader.exportMode = number_of_colors_exported << 1 | z_enabled;
+	/* illegal to set this to 0 */
+	if(number_of_colors_exported || z_enabled)
+	{
+	    fp->r700Shader.exportMode = number_of_colors_exported << 1 | z_enabled;
+	}
+	else
+	{
+	    fp->r700Shader.exportMode = (1 << 1);
+	}
 
     fp->translated = GL_TRUE;
 
@@ -341,6 +372,11 @@ GLboolean r700SetupFragmentProgram(GLcontext * ctx)
         SETbit(r700->SPI_PS_IN_CONTROL_0.u32All, POSITION_ENA_bit);
         SETbit(r700->SPI_INPUT_Z.u32All, PROVIDE_Z_TO_SPI_bit);
     }
+    else
+    {
+        CLEARbit(r700->SPI_PS_IN_CONTROL_0.u32All, POSITION_ENA_bit);
+        CLEARbit(r700->SPI_INPUT_Z.u32All, PROVIDE_Z_TO_SPI_bit);
+    }
 
     ui = (unNumOfReg < ui) ? ui : unNumOfReg;
 
diff --git a/src/mesa/drivers/dri/r600/r700_oglprog.c b/src/mesa/drivers/dri/r600/r700_oglprog.c
index 5290ef3..0d476fc 100644
--- a/src/mesa/drivers/dri/r600/r700_oglprog.c
+++ b/src/mesa/drivers/dri/r600/r700_oglprog.c
@@ -40,6 +40,24 @@
 #include "r700_vertprog.h"
 
 
+static void freeVertProgCache(GLcontext *ctx, struct r700_vertex_program_cont *cache)
+{
+	struct r700_vertex_program *tmp, *vp = cache->progs;
+
+	while (vp) {
+		tmp = vp->next;
+		/* Release DMA region */
+		r600DeleteShader(ctx, vp->shaderbo);
+		/* Clean up */
+		Clean_Up_Assembler(&(vp->r700AsmCode));
+		Clean_Up_Shader(&(vp->r700Shader));
+		
+		_mesa_reference_vertprog(ctx, &vp->mesa_program, NULL);
+		_mesa_free(vp);
+		vp = tmp;
+	}
+}
+
 static struct gl_program *r700NewProgram(GLcontext * ctx, 
                                          GLenum target,
 					                     GLuint id)
@@ -84,8 +102,7 @@ static struct gl_program *r700NewProgram(GLcontext * ctx,
 
 static void r700DeleteProgram(GLcontext * ctx, struct gl_program *prog)
 {
-    struct r700_vertex_program_cont   * vpc;
-    struct r700_vertex_program *vp, *tmp;
+    struct r700_vertex_program_cont *vpc = (struct r700_vertex_program_cont *)prog;
     struct r700_fragment_program * fp;
 
 	radeon_print(RADEON_SHADER, RADEON_VERBOSE,
@@ -95,20 +112,7 @@ static void r700DeleteProgram(GLcontext * ctx, struct gl_program *prog)
     {
     case GL_VERTEX_STATE_PROGRAM_NV:
     case GL_VERTEX_PROGRAM_ARB:	    
-        vpc = (struct r700_vertex_program_cont*)prog;
-        vp = vpc->progs;
-	while (vp) {
-		tmp = vp->next;
-		/* Release DMA region */
-	 
-	        r600DeleteShader(ctx, vp->shaderbo);
-
-	        /* Clean up */
-	        Clean_Up_Assembler(&(vp->r700AsmCode));
-	        Clean_Up_Shader(&(vp->r700Shader));
-		_mesa_free(vp);
-		vp = tmp;
-	}
+	    freeVertProgCache(ctx, vpc);
 	    break;
     case GL_FRAGMENT_PROGRAM_NV:
     case GL_FRAGMENT_PROGRAM_ARB:
@@ -131,7 +135,24 @@ static void r700DeleteProgram(GLcontext * ctx, struct gl_program *prog)
 static void
 r700ProgramStringNotify(GLcontext * ctx, GLenum target, struct gl_program *prog)
 {
-
+	struct r700_vertex_program_cont *vpc = (struct r700_vertex_program_cont *)prog;
+	struct r700_fragment_program * fp = (struct r700_fragment_program*)prog;
+
+	switch (target) {
+	case GL_VERTEX_PROGRAM_ARB:
+		freeVertProgCache(ctx, vpc);
+		vpc->progs = NULL;
+		break;
+	case GL_FRAGMENT_PROGRAM_ARB:
+		r600DeleteShader(ctx, fp->shaderbo);
+		Clean_Up_Assembler(&(fp->r700AsmCode));
+		Clean_Up_Shader(&(fp->r700Shader));
+		fp->translated = GL_FALSE;
+		fp->loaded     = GL_FALSE;
+		fp->shaderbo   = NULL;
+		break;
+	}
+		
 }
 
 static GLboolean r700IsProgramNative(GLcontext * ctx, GLenum target, struct gl_program *prog)
diff --git a/src/mesa/drivers/dri/r600/r700_state.c b/src/mesa/drivers/dri/r600/r700_state.c
index 124469b..244a016 100644
--- a/src/mesa/drivers/dri/r600/r700_state.c
+++ b/src/mesa/drivers/dri/r600/r700_state.c
@@ -467,10 +467,10 @@ static void r700SetBlendState(GLcontext * ctx)
 		 eqn, COLOR_COMB_FCN_shift, COLOR_COMB_FCN_mask);
 
 	SETfield(blend_reg,
-		 blend_factor(ctx->Color.BlendSrcRGB, GL_TRUE),
+		 blend_factor(ctx->Color.BlendSrcA, GL_TRUE),
 		 ALPHA_SRCBLEND_shift, ALPHA_SRCBLEND_mask);
 	SETfield(blend_reg,
-		 blend_factor(ctx->Color.BlendDstRGB, GL_FALSE),
+		 blend_factor(ctx->Color.BlendDstA, GL_FALSE),
 		 ALPHA_DESTBLEND_shift, ALPHA_DESTBLEND_mask);
 
 	switch (ctx->Color.BlendEquationA) {
@@ -745,9 +745,9 @@ static void r700ColorMask(GLcontext * ctx,
 			     (b ? 4 : 0) |
 			     (a ? 8 : 0));
 
-	if (mask != r700->CB_SHADER_MASK.u32All) {
+	if (mask != r700->CB_TARGET_MASK.u32All) {
 		R600_STATECHANGE(context, cb);
-		SETfield(r700->CB_SHADER_MASK.u32All, mask, OUTPUT0_ENABLE_shift, OUTPUT0_ENABLE_mask);
+		SETfield(r700->CB_TARGET_MASK.u32All, mask, TARGET0_ENABLE_shift, TARGET0_ENABLE_mask);
 	}
 }
 
@@ -1269,11 +1269,15 @@ void r700SetScissor(context_t *context) //---------------
 		return;
 	}
 	if (context->radeon.state.scissor.enabled) {
-		/* r600 has exclusive scissors */
 		x1 = context->radeon.state.scissor.rect.x1;
 		y1 = context->radeon.state.scissor.rect.y1;
-		x2 = context->radeon.state.scissor.rect.x2 + 1;
-		y2 = context->radeon.state.scissor.rect.y2 + 1;
+		x2 = context->radeon.state.scissor.rect.x2;
+		y2 = context->radeon.state.scissor.rect.y2;
+		/* r600 has exclusive BR scissors */
+		if (context->radeon.radeonScreen->kernel_mm) {
+			x2++;
+			y2++;
+		}
 	} else {
 		if (context->radeon.radeonScreen->driScreen->dri2.enabled) {
 			x1 = 0;
@@ -1754,7 +1758,7 @@ void r700InitState(GLcontext * ctx) //-------------------
     r700->CB_CLRCMP_MSK.u32All = 0xFFFFFFFF;
 
     /* screen/window/view */
-    SETfield(r700->CB_TARGET_MASK.u32All, 0xF, (4 * id), TARGET0_ENABLE_mask);
+    SETfield(r700->CB_SHADER_MASK.u32All, 0xF, (4 * id), OUTPUT0_ENABLE_mask);
 
     context->radeon.hw.all_dirty = GL_TRUE;
 
diff --git a/src/mesa/drivers/dri/radeon/radeon_bo_legacy.c b/src/mesa/drivers/dri/radeon/radeon_bo_legacy.c
index 3e7547d..ce60a2f 100644
--- a/src/mesa/drivers/dri/radeon/radeon_bo_legacy.c
+++ b/src/mesa/drivers/dri/radeon/radeon_bo_legacy.c
@@ -710,6 +710,10 @@ int radeon_bo_legacy_validate(struct radeon_bo *bo,
                 bo, bo->size, bo_legacy->map_count);
         return -EINVAL;
     }
+    if(bo->size == 0) {
+        fprintf(stderr, "bo(%p) has size 0.\n", bo);
+        return -EINVAL;
+    }
     if (bo_legacy->static_bo || bo_legacy->validated) {
         *soffset = bo_legacy->offset;
         *eoffset = bo_legacy->offset + bo->size;
diff --git a/src/mesa/drivers/dri/radeon/radeon_common.c b/src/mesa/drivers/dri/radeon/radeon_common.c
index 9817ff8..8032cbc 100644
--- a/src/mesa/drivers/dri/radeon/radeon_common.c
+++ b/src/mesa/drivers/dri/radeon/radeon_common.c
@@ -229,16 +229,15 @@ void radeonUpdateScissor( GLcontext *ctx )
 	}
 	if (!rmesa->radeonScreen->kernel_mm) {
 	   /* Fix scissors for dri 1 */
-
 	   __DRIdrawablePrivate *dPriv = radeon_get_drawable(rmesa);
 	   x1 += dPriv->x;
-	   x2 += dPriv->x;
+	   x2 += dPriv->x + 1;
 	   min_x += dPriv->x;
-	   max_x += dPriv->x;
+	   max_x += dPriv->x + 1;
 	   y1 += dPriv->y;
-	   y2 += dPriv->y;
+	   y2 += dPriv->y + 1;
 	   min_y += dPriv->y;
-	   max_y += dPriv->y;
+	   max_y += dPriv->y + 1;
 	}
 
 	rmesa->state.scissor.rect.x1 = CLAMP(x1,  min_x, max_x);
diff --git a/src/mesa/drivers/dri/radeon/radeon_fbo.c b/src/mesa/drivers/dri/radeon/radeon_fbo.c
index d83b166..2012cbc 100644
--- a/src/mesa/drivers/dri/radeon/radeon_fbo.c
+++ b/src/mesa/drivers/dri/radeon/radeon_fbo.c
@@ -445,7 +445,6 @@ restart:
 		goto restart;
 	}
 	
-	rrb->pitch = texImage->Width * rrb->cpp;
 	rrb->base.InternalFormat = rrb->base._ActualFormat;
 	rrb->base.Width = texImage->Width;
 	rrb->base.Height = texImage->Height;
@@ -555,8 +554,10 @@ radeon_render_texture(GLcontext * ctx,
       imageOffset += offsets[att->Zoffset];
    }
 
-   /* store that offset in the region */
+   /* store that offset in the region, along with the correct pitch for
+    * the image we are rendering to */
    rrb->draw_offset = imageOffset;
+   rrb->pitch = radeon_image->mt->levels[att->TextureLevel].rowstride;
 
    /* update drawing region, etc */
    radeon_draw_buffer(ctx, fb);
diff --git a/src/mesa/drivers/windows/gdi/mesa.def b/src/mesa/drivers/windows/gdi/mesa.def
index bd3e5b2..05817fd 100644
--- a/src/mesa/drivers/windows/gdi/mesa.def
+++ b/src/mesa/drivers/windows/gdi/mesa.def
@@ -867,12 +867,6 @@ EXPORTS
 	_glapi_get_proc_address
 	_mesa_add_soft_renderbuffers
 	_mesa_add_renderbuffer
-	_mesa_begin_query
-	_mesa_buffer_data
-	_mesa_buffer_get_subdata
-	_mesa_buffer_map
-	_mesa_buffer_subdata
-	_mesa_buffer_unmap
 	_mesa_bzero
 	_mesa_calloc
 	_mesa_choose_tex_format
@@ -880,9 +874,7 @@ EXPORTS
 	_mesa_create_framebuffer
 	_mesa_create_visual
 	_mesa_delete_array_object
-	_mesa_delete_buffer_object
 	_mesa_delete_program
-	_mesa_delete_query
 	_mesa_delete_texture_object
 	_mesa_destroy_framebuffer
 	_mesa_destroy_visual
@@ -892,7 +884,6 @@ EXPORTS
 	_mesa_enable_2_0_extensions
 	_mesa_enable_2_1_extensions
 	_mesa_enable_sw_extensions
-	_mesa_end_query
 	_mesa_error
 	_mesa_finish_render_texture
 	_mesa_framebuffer_renderbuffer
@@ -911,10 +902,8 @@ EXPORTS
 	_mesa_memcpy
 	_mesa_memset
 	_mesa_new_array_object
-	_mesa_new_buffer_object
 	_mesa_new_framebuffer
 	_mesa_new_program
-	_mesa_new_query_object
 	_mesa_new_renderbuffer
 	_mesa_new_soft_renderbuffer
 	_mesa_new_texture_image
@@ -943,7 +932,6 @@ EXPORTS
 	_mesa_update_framebuffer_visual
 	_mesa_use_program
 	_mesa_Viewport
-	_mesa_wait_query
 	_swrast_Accum
 	_swrast_Bitmap
 	_swrast_BlitFramebuffer
diff --git a/src/mesa/drivers/x11/fakeglx.c b/src/mesa/drivers/x11/fakeglx.c
index 34e0b8b..5c0084f 100644
--- a/src/mesa/drivers/x11/fakeglx.c
+++ b/src/mesa/drivers/x11/fakeglx.c
@@ -1197,10 +1197,10 @@ choose_visual( Display *dpy, int screen, const int *list, GLboolean fbConfig )
             if (!fbConfig)
                return NULL;
             parselist++;
-            if (*parselist == GLX_RGBA_BIT) {
+            if (*parselist & GLX_RGBA_BIT) {
                rgb_flag = GL_TRUE;
             }
-            else if (*parselist == GLX_COLOR_INDEX_BIT) {
+            else if (*parselist & GLX_COLOR_INDEX_BIT) {
                rgb_flag = GL_FALSE;
             }
             else if (*parselist == 0) {
@@ -1637,13 +1637,17 @@ Fake_glXCopyContext( Display *dpy, GLXContext src, GLXContext dst,
 
 
 static Bool
-Fake_glXQueryExtension( Display *dpy, int *errorb, int *event )
+Fake_glXQueryExtension( Display *dpy, int *errorBase, int *eventBase )
 {
+   int op, ev, err;
    /* Mesa's GLX isn't really an X extension but we try to act like one. */
-   (void) dpy;
-   (void) errorb;
-   (void) event;
-   return True;
+   if (!XQueryExtension(dpy, GLX_EXTENSION_NAME, &op, &ev, &err))
+      ev = err = 0;
+   if (errorBase)
+      *errorBase = err;
+   if (eventBase)
+      *eventBase = ev;
+   return True; /* we're faking GLX so always return success */
 }
 
 
@@ -2349,32 +2353,42 @@ Fake_glXCreatePbuffer( Display *dpy, GLXFBConfig config,
             break;
          case GLX_PRESERVED_CONTENTS:
             attrib++;
-            preserveContents = *attrib; /* ignored */
+            preserveContents = *attrib;
             break;
          case GLX_LARGEST_PBUFFER:
             attrib++;
-            useLargest = *attrib; /* ignored */
+            useLargest = *attrib;
             break;
          default:
             return 0;
       }
    }
 
-   /* not used at this time */
-   (void) useLargest;
-   (void) preserveContents;
-
    if (width == 0 || height == 0)
       return 0;
 
+   if (width > MAX_WIDTH || height > MAX_HEIGHT) {
+      /* If allocation would have failed and GLX_LARGEST_PBUFFER is set,
+       * allocate the largest possible buffer.
+       */
+      if (useLargest) {
+         width = MAX_WIDTH;
+         height = MAX_HEIGHT;
+      }
+   }
+
    xmbuf = XMesaCreatePBuffer( xmvis, 0, width, height);
    /* A GLXPbuffer handle must be an X Drawable because that's what
     * glXMakeCurrent takes.
     */
-   if (xmbuf)
+   if (xmbuf) {
+      xmbuf->largestPbuffer = useLargest;
+      xmbuf->preservedContents = preserveContents;
       return (GLXPbuffer) xmbuf->frontxrb->pixmap;
-   else
+   }
+   else {
       return 0;
+   }
 }
 
 
@@ -2396,6 +2410,9 @@ Fake_glXQueryDrawable( Display *dpy, GLXDrawable draw, int attribute,
    if (!xmbuf)
       return;
 
+   /* make sure buffer's dimensions are up to date */
+   xmesa_check_and_update_buffer_size(NULL, xmbuf);
+
    switch (attribute) {
       case GLX_WIDTH:
          *value = xmbuf->mesa_buffer.Width;
@@ -2404,10 +2421,10 @@ Fake_glXQueryDrawable( Display *dpy, GLXDrawable draw, int attribute,
          *value = xmbuf->mesa_buffer.Height;
          break;
       case GLX_PRESERVED_CONTENTS:
-         *value = True;
+         *value = xmbuf->preservedContents;
          break;
       case GLX_LARGEST_PBUFFER:
-         *value = xmbuf->mesa_buffer.Width * xmbuf->mesa_buffer.Height;
+         *value = xmbuf->largestPbuffer;
          break;
       case GLX_FBCONFIG_ID:
          *value = xmbuf->xm_visual->visinfo->visualid;
@@ -2477,9 +2494,9 @@ Fake_glXQueryContext( Display *dpy, GLXContext ctx, int attribute, int *value )
       break;
    case GLX_RENDER_TYPE:
       if (xmctx->xm_visual->mesa_visual.rgbMode)
-         *value = GLX_RGBA_BIT;
+         *value = GLX_RGBA_TYPE;
       else
-         *value = GLX_COLOR_INDEX_BIT;
+         *value = GLX_COLOR_INDEX_TYPE;
       break;
    case GLX_SCREEN:
       *value = 0;
@@ -2764,10 +2781,10 @@ Fake_glXQueryGLXPbufferSGIX(Display *dpy, GLXPbufferSGIX pbuf, int attribute, un
 
    switch (attribute) {
       case GLX_PRESERVED_CONTENTS_SGIX:
-         *value = True;
+         *value = xmbuf->preservedContents;
          break;
       case GLX_LARGEST_PBUFFER_SGIX:
-         *value = xmbuf->mesa_buffer.Width * xmbuf->mesa_buffer.Height;
+         *value = xmbuf->largestPbuffer;
          break;
       case GLX_WIDTH_SGIX:
          *value = xmbuf->mesa_buffer.Width;
diff --git a/src/mesa/drivers/x11/xmesaP.h b/src/mesa/drivers/x11/xmesaP.h
index 25db558..3ffd766 100644
--- a/src/mesa/drivers/x11/xmesaP.h
+++ b/src/mesa/drivers/x11/xmesaP.h
@@ -212,6 +212,9 @@ struct xmesa_buffer {
    XMesaDisplay *display;
    BufferType type;             /* window, pixmap, pbuffer or glxwindow */
 
+   GLboolean largestPbuffer;    /**< for pbuffers */
+   GLboolean preservedContents; /**< for pbuffers */
+
    struct xmesa_renderbuffer *frontxrb; /* front color renderbuffer */
    struct xmesa_renderbuffer *backxrb;  /* back color renderbuffer */
 
diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index f6d4ac4..e844a74 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -898,6 +898,7 @@ _mesa_initialize_context(GLcontext *ctx,
       _mesa_free_shared_state(ctx, ctx->Shared);
       if (ctx->Exec)
          _mesa_free(ctx->Exec);
+      return GL_FALSE;
    }
 #if FEATURE_dispatch
    _mesa_init_exec_table(ctx->Exec);
@@ -1543,6 +1544,33 @@ _mesa_record_error(GLcontext *ctx, GLenum error)
 
 
 /**
+ * Flush commands and wait for completion.
+ */
+void
+_mesa_finish(GLcontext *ctx)
+{
+   FLUSH_CURRENT( ctx, 0 );
+   if (ctx->Driver.Finish) {
+      ctx->Driver.Finish(ctx);
+   }
+}
+
+
+/**
+ * Flush commands.
+ */
+void
+_mesa_flush(GLcontext *ctx)
+{
+   FLUSH_CURRENT( ctx, 0 );
+   if (ctx->Driver.Flush) {
+      ctx->Driver.Flush(ctx);
+   }
+}
+
+
+
+/**
  * Execute glFinish().
  *
  * Calls the #ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH macro and the
@@ -1553,10 +1581,7 @@ _mesa_Finish(void)
 {
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
-   FLUSH_CURRENT( ctx, 0 );
-   if (ctx->Driver.Finish) {
-      ctx->Driver.Finish(ctx);
-   }
+   _mesa_finish(ctx);
 }
 
 
@@ -1571,10 +1596,7 @@ _mesa_Flush(void)
 {
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
-   FLUSH_CURRENT( ctx, 0 );
-   if (ctx->Driver.Flush) {
-      ctx->Driver.Flush(ctx);
-   }
+   _mesa_flush(ctx);
 }
 
 
diff --git a/src/mesa/main/context.h b/src/mesa/main/context.h
index 5587695..c3be106 100644
--- a/src/mesa/main/context.h
+++ b/src/mesa/main/context.h
@@ -170,6 +170,14 @@ _mesa_valid_to_render(GLcontext *ctx, const char *where);
 extern void
 _mesa_record_error( GLcontext *ctx, GLenum error );
 
+
+extern void
+_mesa_finish(GLcontext *ctx);
+
+extern void
+_mesa_flush(GLcontext *ctx);
+
+
 extern void GLAPIENTRY
 _mesa_Finish( void );
 
diff --git a/src/mesa/main/dlist.c b/src/mesa/main/dlist.c
index b53c173..41a5b61 100644
--- a/src/mesa/main/dlist.c
+++ b/src/mesa/main/dlist.c
@@ -1956,6 +1956,9 @@ save_Fogiv(GLenum pname, const GLint *params)
    case GL_FOG_END:
    case GL_FOG_INDEX:
       p[0] = (GLfloat) *params;
+      p[1] = 0.0f;
+      p[2] = 0.0f;
+      p[3] = 0.0f;
       break;
    case GL_FOG_COLOR:
       p[0] = INT_TO_FLOAT(params[0]);
@@ -2244,6 +2247,9 @@ save_LightModeliv(GLenum pname, const GLint *params)
    case GL_LIGHT_MODEL_TWO_SIDE:
    case GL_LIGHT_MODEL_COLOR_CONTROL:
       fparam[0] = (GLfloat) params[0];
+      fparam[1] = 0.0F;
+      fparam[2] = 0.0F;
+      fparam[3] = 0.0F;
       break;
    default:
       /* Error will be caught later in gl_LightModelfv */
diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index 825a230..ed1db0f 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -1511,18 +1511,6 @@ framebuffer_texture(GLcontext *ctx, const char *caller, GLenum target,
       return;
    }
 
-   if (texObj && attachment == GL_DEPTH_STENCIL_ATTACHMENT) {
-      /* the texture format must be depth+stencil */
-      const struct gl_texture_image *texImg;
-      texImg = texObj->Image[0][texObj->BaseLevel];
-      if (!texImg || texImg->_BaseFormat != GL_DEPTH_STENCIL) {
-         _mesa_error(ctx, GL_INVALID_OPERATION,
-                     "glFramebufferTexture%sEXT(texture is not"
-                     " DEPTH_STENCIL format)", caller);
-         return;
-      }
-   }
-
    FLUSH_CURRENT(ctx, _NEW_BUFFERS);
    /* The above doesn't fully flush the drivers in the way that a
     * glFlush does, but that is required here:
diff --git a/src/mesa/main/get.c b/src/mesa/main/get.c
index 477ed01..604b106 100644
--- a/src/mesa/main/get.c
+++ b/src/mesa/main/get.c
@@ -5580,16 +5580,16 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
 
    switch (pname) {
       case GL_ACCUM_RED_BITS:
-         params[0] = ctx->DrawBuffer->Visual.accumRedBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.accumRedBits);
          break;
       case GL_ACCUM_GREEN_BITS:
-         params[0] = ctx->DrawBuffer->Visual.accumGreenBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.accumGreenBits);
          break;
       case GL_ACCUM_BLUE_BITS:
-         params[0] = ctx->DrawBuffer->Visual.accumBlueBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.accumBlueBits);
          break;
       case GL_ACCUM_ALPHA_BITS:
-         params[0] = ctx->DrawBuffer->Visual.accumAlphaBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.accumAlphaBits);
          break;
       case GL_ACCUM_CLEAR_VALUE:
          params[0] = FLOAT_TO_INT64(ctx->Accum.ClearColor[0]);
@@ -5601,7 +5601,7 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = IROUND64(ctx->Pixel.AlphaBias);
          break;
       case GL_ALPHA_BITS:
-         params[0] = ctx->DrawBuffer->Visual.alphaBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.alphaBits);
          break;
       case GL_ALPHA_SCALE:
          params[0] = IROUND64(ctx->Pixel.AlphaScale);
@@ -5616,13 +5616,13 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = FLOAT_TO_INT64(ctx->Color.AlphaRef);
          break;
       case GL_ATTRIB_STACK_DEPTH:
-         params[0] = ctx->AttribStackDepth;
+         params[0] = (GLint64)(ctx->AttribStackDepth);
          break;
       case GL_AUTO_NORMAL:
          params[0] = BOOLEAN_TO_INT64(ctx->Eval.AutoNormal);
          break;
       case GL_AUX_BUFFERS:
-         params[0] = ctx->DrawBuffer->Visual.numAuxBuffers;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.numAuxBuffers);
          break;
       case GL_BLEND:
          params[0] = BOOLEAN_TO_INT64(ctx->Color.BlendEnabled);
@@ -5661,13 +5661,13 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = IROUND64(ctx->Pixel.BlueBias);
          break;
       case GL_BLUE_BITS:
-         params[0] = ctx->DrawBuffer->Visual.blueBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.blueBits);
          break;
       case GL_BLUE_SCALE:
          params[0] = IROUND64(ctx->Pixel.BlueScale);
          break;
       case GL_CLIENT_ATTRIB_STACK_DEPTH:
-         params[0] = ctx->ClientAttribStackDepth;
+         params[0] = (GLint64)(ctx->ClientAttribStackDepth);
          break;
       case GL_CLIP_PLANE0:
          params[0] = BOOLEAN_TO_INT64((ctx->Transform.ClipPlanesEnabled >> 0) & 1);
@@ -5703,10 +5703,10 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = ENUM_TO_INT64(ctx->Light.ColorMaterialMode);
          break;
       case GL_COLOR_WRITEMASK:
-         params[0] = ctx->Color.ColorMask[RCOMP] ? 1 : 0;
-         params[1] = ctx->Color.ColorMask[GCOMP] ? 1 : 0;
-         params[2] = ctx->Color.ColorMask[BCOMP] ? 1 : 0;
-         params[3] = ctx->Color.ColorMask[ACOMP] ? 1 : 0;
+         params[0] = (GLint64)(ctx->Color.ColorMask[RCOMP] ? 1 : 0);
+         params[1] = (GLint64)(ctx->Color.ColorMask[GCOMP] ? 1 : 0);
+         params[2] = (GLint64)(ctx->Color.ColorMask[BCOMP] ? 1 : 0);
+         params[3] = (GLint64)(ctx->Color.ColorMask[ACOMP] ? 1 : 0);
          break;
       case GL_CULL_FACE:
          params[0] = BOOLEAN_TO_INT64(ctx->Polygon.CullFlag);
@@ -5787,7 +5787,7 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = IROUND64(ctx->Pixel.DepthBias);
          break;
       case GL_DEPTH_BITS:
-         params[0] = ctx->DrawBuffer->Visual.depthBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.depthBits);
          break;
       case GL_DEPTH_CLEAR_VALUE:
          params[0] = FLOAT_TO_INT64(((GLfloat) ctx->Depth.Clear));
@@ -5824,7 +5824,7 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          }
          break;
       case GL_FEEDBACK_BUFFER_SIZE:
-         params[0] = ctx->Feedback.BufferSize;
+         params[0] = (GLint64)(ctx->Feedback.BufferSize);
          break;
       case GL_FEEDBACK_BUFFER_TYPE:
          params[0] = ENUM_TO_INT64(ctx->Feedback.Type);
@@ -5863,28 +5863,28 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = IROUND64(ctx->Pixel.GreenBias);
          break;
       case GL_GREEN_BITS:
-         params[0] = ctx->DrawBuffer->Visual.greenBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.greenBits);
          break;
       case GL_GREEN_SCALE:
          params[0] = IROUND64(ctx->Pixel.GreenScale);
          break;
       case GL_INDEX_BITS:
-         params[0] = ctx->DrawBuffer->Visual.indexBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.indexBits);
          break;
       case GL_INDEX_CLEAR_VALUE:
-         params[0] = ctx->Color.ClearIndex;
+         params[0] = (GLint64)(ctx->Color.ClearIndex);
          break;
       case GL_INDEX_MODE:
          params[0] = BOOLEAN_TO_INT64(!ctx->DrawBuffer->Visual.rgbMode);
          break;
       case GL_INDEX_OFFSET:
-         params[0] = ctx->Pixel.IndexOffset;
+         params[0] = (GLint64)(ctx->Pixel.IndexOffset);
          break;
       case GL_INDEX_SHIFT:
-         params[0] = ctx->Pixel.IndexShift;
+         params[0] = (GLint64)(ctx->Pixel.IndexShift);
          break;
       case GL_INDEX_WRITEMASK:
-         params[0] = ctx->Color.IndexMask;
+         params[0] = (GLint64)(ctx->Color.IndexMask);
          break;
       case GL_LIGHT0:
          params[0] = BOOLEAN_TO_INT64(ctx->Light.Light[0].Enabled);
@@ -5938,10 +5938,10 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = BOOLEAN_TO_INT64(ctx->Line.StippleFlag);
          break;
       case GL_LINE_STIPPLE_PATTERN:
-         params[0] = ctx->Line.StipplePattern;
+         params[0] = (GLint64)(ctx->Line.StipplePattern);
          break;
       case GL_LINE_STIPPLE_REPEAT:
-         params[0] = ctx->Line.StippleFactor;
+         params[0] = (GLint64)(ctx->Line.StippleFactor);
          break;
       case GL_LINE_WIDTH:
          params[0] = IROUND64(ctx->Line.Width);
@@ -5958,10 +5958,10 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[1] = IROUND64(ctx->Const.MaxLineWidth);
          break;
       case GL_LIST_BASE:
-         params[0] = ctx->List.ListBase;
+         params[0] = (GLint64)(ctx->List.ListBase);
          break;
       case GL_LIST_INDEX:
-         params[0] = (ctx->ListState.CurrentList ? ctx->ListState.CurrentList->Name : 0);
+         params[0] = (GLint64)((ctx->ListState.CurrentList ? ctx->ListState.CurrentList->Name : 0));
          break;
       case GL_LIST_MODE:
          {
@@ -5992,7 +5992,7 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[1] = IROUND64(ctx->Eval.MapGrid1u2);
          break;
       case GL_MAP1_GRID_SEGMENTS:
-         params[0] = ctx->Eval.MapGrid1un;
+         params[0] = (GLint64)(ctx->Eval.MapGrid1un);
          break;
       case GL_MAP1_INDEX:
          params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map1Index);
@@ -6028,8 +6028,8 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[3] = IROUND64(ctx->Eval.MapGrid2v2);
          break;
       case GL_MAP2_GRID_SEGMENTS:
-         params[0] = ctx->Eval.MapGrid2un;
-         params[1] = ctx->Eval.MapGrid2vn;
+         params[0] = (GLint64)(ctx->Eval.MapGrid2un);
+         params[1] = (GLint64)(ctx->Eval.MapGrid2vn);
          break;
       case GL_MAP2_INDEX:
          params[0] = BOOLEAN_TO_INT64(ctx->Eval.Map2Index);
@@ -6065,53 +6065,53 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = ENUM_TO_INT64(ctx->Transform.MatrixMode);
          break;
       case GL_MAX_ATTRIB_STACK_DEPTH:
-         params[0] = MAX_ATTRIB_STACK_DEPTH;
+         params[0] = (GLint64)(MAX_ATTRIB_STACK_DEPTH);
          break;
       case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
-         params[0] = MAX_CLIENT_ATTRIB_STACK_DEPTH;
+         params[0] = (GLint64)(MAX_CLIENT_ATTRIB_STACK_DEPTH);
          break;
       case GL_MAX_CLIP_PLANES:
-         params[0] = ctx->Const.MaxClipPlanes;
+         params[0] = (GLint64)(ctx->Const.MaxClipPlanes);
          break;
       case GL_MAX_ELEMENTS_VERTICES:
-         params[0] = ctx->Const.MaxArrayLockSize;
+         params[0] = (GLint64)(ctx->Const.MaxArrayLockSize);
          break;
       case GL_MAX_ELEMENTS_INDICES:
-         params[0] = ctx->Const.MaxArrayLockSize;
+         params[0] = (GLint64)(ctx->Const.MaxArrayLockSize);
          break;
       case GL_MAX_EVAL_ORDER:
-         params[0] = MAX_EVAL_ORDER;
+         params[0] = (GLint64)(MAX_EVAL_ORDER);
          break;
       case GL_MAX_LIGHTS:
-         params[0] = ctx->Const.MaxLights;
+         params[0] = (GLint64)(ctx->Const.MaxLights);
          break;
       case GL_MAX_LIST_NESTING:
-         params[0] = MAX_LIST_NESTING;
+         params[0] = (GLint64)(MAX_LIST_NESTING);
          break;
       case GL_MAX_MODELVIEW_STACK_DEPTH:
-         params[0] = MAX_MODELVIEW_STACK_DEPTH;
+         params[0] = (GLint64)(MAX_MODELVIEW_STACK_DEPTH);
          break;
       case GL_MAX_NAME_STACK_DEPTH:
-         params[0] = MAX_NAME_STACK_DEPTH;
+         params[0] = (GLint64)(MAX_NAME_STACK_DEPTH);
          break;
       case GL_MAX_PIXEL_MAP_TABLE:
-         params[0] = MAX_PIXEL_MAP_TABLE;
+         params[0] = (GLint64)(MAX_PIXEL_MAP_TABLE);
          break;
       case GL_MAX_PROJECTION_STACK_DEPTH:
-         params[0] = MAX_PROJECTION_STACK_DEPTH;
+         params[0] = (GLint64)(MAX_PROJECTION_STACK_DEPTH);
          break;
       case GL_MAX_TEXTURE_SIZE:
-         params[0] = 1 << (ctx->Const.MaxTextureLevels - 1);
+         params[0] = (GLint64)(1 << (ctx->Const.MaxTextureLevels - 1));
          break;
       case GL_MAX_3D_TEXTURE_SIZE:
-         params[0] = 1 << (ctx->Const.Max3DTextureLevels - 1);
+         params[0] = (GLint64)(1 << (ctx->Const.Max3DTextureLevels - 1));
          break;
       case GL_MAX_TEXTURE_STACK_DEPTH:
-         params[0] = MAX_TEXTURE_STACK_DEPTH;
+         params[0] = (GLint64)(MAX_TEXTURE_STACK_DEPTH);
          break;
       case GL_MAX_VIEWPORT_DIMS:
-         params[0] = ctx->Const.MaxViewportWidth;
-         params[1] = ctx->Const.MaxViewportHeight;
+         params[0] = (GLint64)(ctx->Const.MaxViewportWidth);
+         params[1] = (GLint64)(ctx->Const.MaxViewportHeight);
          break;
       case GL_MODELVIEW_MATRIX:
          {
@@ -6135,37 +6135,37 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          }
          break;
       case GL_MODELVIEW_STACK_DEPTH:
-         params[0] = ctx->ModelviewMatrixStack.Depth + 1;
+         params[0] = (GLint64)(ctx->ModelviewMatrixStack.Depth + 1);
          break;
       case GL_NAME_STACK_DEPTH:
-         params[0] = ctx->Select.NameStackDepth;
+         params[0] = (GLint64)(ctx->Select.NameStackDepth);
          break;
       case GL_NORMALIZE:
          params[0] = BOOLEAN_TO_INT64(ctx->Transform.Normalize);
          break;
       case GL_PACK_ALIGNMENT:
-         params[0] = ctx->Pack.Alignment;
+         params[0] = (GLint64)(ctx->Pack.Alignment);
          break;
       case GL_PACK_LSB_FIRST:
          params[0] = BOOLEAN_TO_INT64(ctx->Pack.LsbFirst);
          break;
       case GL_PACK_ROW_LENGTH:
-         params[0] = ctx->Pack.RowLength;
+         params[0] = (GLint64)(ctx->Pack.RowLength);
          break;
       case GL_PACK_SKIP_PIXELS:
-         params[0] = ctx->Pack.SkipPixels;
+         params[0] = (GLint64)(ctx->Pack.SkipPixels);
          break;
       case GL_PACK_SKIP_ROWS:
-         params[0] = ctx->Pack.SkipRows;
+         params[0] = (GLint64)(ctx->Pack.SkipRows);
          break;
       case GL_PACK_SWAP_BYTES:
          params[0] = BOOLEAN_TO_INT64(ctx->Pack.SwapBytes);
          break;
       case GL_PACK_SKIP_IMAGES_EXT:
-         params[0] = ctx->Pack.SkipImages;
+         params[0] = (GLint64)(ctx->Pack.SkipImages);
          break;
       case GL_PACK_IMAGE_HEIGHT_EXT:
-         params[0] = ctx->Pack.ImageHeight;
+         params[0] = (GLint64)(ctx->Pack.ImageHeight);
          break;
       case GL_PACK_INVERT_MESA:
          params[0] = BOOLEAN_TO_INT64(ctx->Pack.Invert);
@@ -6174,34 +6174,34 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = ENUM_TO_INT64(ctx->Hint.PerspectiveCorrection);
          break;
       case GL_PIXEL_MAP_A_TO_A_SIZE:
-         params[0] = ctx->PixelMaps.AtoA.Size;
+         params[0] = (GLint64)(ctx->PixelMaps.AtoA.Size);
          break;
       case GL_PIXEL_MAP_B_TO_B_SIZE:
-         params[0] = ctx->PixelMaps.BtoB.Size;
+         params[0] = (GLint64)(ctx->PixelMaps.BtoB.Size);
          break;
       case GL_PIXEL_MAP_G_TO_G_SIZE:
-         params[0] = ctx->PixelMaps.GtoG.Size;
+         params[0] = (GLint64)(ctx->PixelMaps.GtoG.Size);
          break;
       case GL_PIXEL_MAP_I_TO_A_SIZE:
-         params[0] = ctx->PixelMaps.ItoA.Size;
+         params[0] = (GLint64)(ctx->PixelMaps.ItoA.Size);
          break;
       case GL_PIXEL_MAP_I_TO_B_SIZE:
-         params[0] = ctx->PixelMaps.ItoB.Size;
+         params[0] = (GLint64)(ctx->PixelMaps.ItoB.Size);
          break;
       case GL_PIXEL_MAP_I_TO_G_SIZE:
-         params[0] = ctx->PixelMaps.ItoG.Size;
+         params[0] = (GLint64)(ctx->PixelMaps.ItoG.Size);
          break;
       case GL_PIXEL_MAP_I_TO_I_SIZE:
-         params[0] = ctx->PixelMaps.ItoI.Size;
+         params[0] = (GLint64)(ctx->PixelMaps.ItoI.Size);
          break;
       case GL_PIXEL_MAP_I_TO_R_SIZE:
-         params[0] = ctx->PixelMaps.ItoR.Size;
+         params[0] = (GLint64)(ctx->PixelMaps.ItoR.Size);
          break;
       case GL_PIXEL_MAP_R_TO_R_SIZE:
-         params[0] = ctx->PixelMaps.RtoR.Size;
+         params[0] = (GLint64)(ctx->PixelMaps.RtoR.Size);
          break;
       case GL_PIXEL_MAP_S_TO_S_SIZE:
-         params[0] = ctx->PixelMaps.StoS.Size;
+         params[0] = (GLint64)(ctx->PixelMaps.StoS.Size);
          break;
       case GL_POINT_SIZE:
          params[0] = IROUND64(ctx->Point.Size);
@@ -6290,7 +6290,7 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          }
          break;
       case GL_PROJECTION_STACK_DEPTH:
-         params[0] = ctx->ProjectionMatrixStack.Depth + 1;
+         params[0] = (GLint64)(ctx->ProjectionMatrixStack.Depth + 1);
          break;
       case GL_READ_BUFFER:
          params[0] = ENUM_TO_INT64(ctx->ReadBuffer->ColorReadBuffer);
@@ -6299,7 +6299,7 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = IROUND64(ctx->Pixel.RedBias);
          break;
       case GL_RED_BITS:
-         params[0] = ctx->DrawBuffer->Visual.redBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.redBits);
          break;
       case GL_RED_SCALE:
          params[0] = IROUND64(ctx->Pixel.RedScale);
@@ -6314,16 +6314,16 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = BOOLEAN_TO_INT64(ctx->DrawBuffer->Visual.rgbMode);
          break;
       case GL_SCISSOR_BOX:
-         params[0] = ctx->Scissor.X;
-         params[1] = ctx->Scissor.Y;
-         params[2] = ctx->Scissor.Width;
-         params[3] = ctx->Scissor.Height;
+         params[0] = (GLint64)(ctx->Scissor.X);
+         params[1] = (GLint64)(ctx->Scissor.Y);
+         params[2] = (GLint64)(ctx->Scissor.Width);
+         params[3] = (GLint64)(ctx->Scissor.Height);
          break;
       case GL_SCISSOR_TEST:
          params[0] = BOOLEAN_TO_INT64(ctx->Scissor.Enabled);
          break;
       case GL_SELECTION_BUFFER_SIZE:
-         params[0] = ctx->Select.BufferSize;
+         params[0] = (GLint64)(ctx->Select.BufferSize);
          break;
       case GL_SHADE_MODEL:
          params[0] = ENUM_TO_INT64(ctx->Light.ShadeModel);
@@ -6332,10 +6332,10 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = BOOLEAN_TO_INT64(ctx->Texture.SharedPalette);
          break;
       case GL_STENCIL_BITS:
-         params[0] = ctx->DrawBuffer->Visual.stencilBits;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.stencilBits);
          break;
       case GL_STENCIL_CLEAR_VALUE:
-         params[0] = ctx->Stencil.Clear;
+         params[0] = (GLint64)(ctx->Stencil.Clear);
          break;
       case GL_STENCIL_FAIL:
          params[0] = ENUM_TO_INT64(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
@@ -6350,22 +6350,22 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = ENUM_TO_INT64(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
          break;
       case GL_STENCIL_REF:
-         params[0] = ctx->Stencil.Ref[ctx->Stencil.ActiveFace];
+         params[0] = (GLint64)(ctx->Stencil.Ref[ctx->Stencil.ActiveFace]);
          break;
       case GL_STENCIL_TEST:
          params[0] = BOOLEAN_TO_INT64(ctx->Stencil.Enabled);
          break;
       case GL_STENCIL_VALUE_MASK:
-         params[0] = ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace];
+         params[0] = (GLint64)(ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace]);
          break;
       case GL_STENCIL_WRITEMASK:
-         params[0] = ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace];
+         params[0] = (GLint64)(ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace]);
          break;
       case GL_STEREO:
          params[0] = BOOLEAN_TO_INT64(ctx->DrawBuffer->Visual.stereoMode);
          break;
       case GL_SUBPIXEL_BITS:
-         params[0] = ctx->Const.SubPixelBits;
+         params[0] = (GLint64)(ctx->Const.SubPixelBits);
          break;
       case GL_TEXTURE_1D:
          params[0] = BOOLEAN_TO_INT64(_mesa_IsEnabled(GL_TEXTURE_1D));
@@ -6385,21 +6385,21 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = BOOLEAN_TO_INT64(_mesa_IsEnabled(GL_TEXTURE_2D_ARRAY_EXT));
          break;
       case GL_TEXTURE_BINDING_1D:
-         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_INDEX]->Name;
+         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_INDEX]->Name);
          break;
       case GL_TEXTURE_BINDING_2D:
-         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_INDEX]->Name;
+         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_INDEX]->Name);
          break;
       case GL_TEXTURE_BINDING_3D:
-         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_3D_INDEX]->Name;
+         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_3D_INDEX]->Name);
          break;
       case GL_TEXTURE_BINDING_1D_ARRAY_EXT:
          CHECK_EXT1(MESA_texture_array, "GetInteger64v");
-         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_ARRAY_INDEX]->Name;
+         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_1D_ARRAY_INDEX]->Name);
          break;
       case GL_TEXTURE_BINDING_2D_ARRAY_EXT:
          CHECK_EXT1(MESA_texture_array, "GetInteger64v");
-         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_ARRAY_INDEX]->Name;
+         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_2D_ARRAY_INDEX]->Name);
          break;
       case GL_TEXTURE_GEN_S:
          params[0] = BOOLEAN_TO_INT64(((ctx->Texture.Unit[ctx->Texture.CurrentUnit].TexGenEnabled & S_BIT) ? 1 : 0));
@@ -6435,40 +6435,40 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          }
          break;
       case GL_TEXTURE_STACK_DEPTH:
-         params[0] = ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Depth + 1;
+         params[0] = (GLint64)(ctx->TextureMatrixStack[ctx->Texture.CurrentUnit].Depth + 1);
          break;
       case GL_UNPACK_ALIGNMENT:
-         params[0] = ctx->Unpack.Alignment;
+         params[0] = (GLint64)(ctx->Unpack.Alignment);
          break;
       case GL_UNPACK_LSB_FIRST:
          params[0] = BOOLEAN_TO_INT64(ctx->Unpack.LsbFirst);
          break;
       case GL_UNPACK_ROW_LENGTH:
-         params[0] = ctx->Unpack.RowLength;
+         params[0] = (GLint64)(ctx->Unpack.RowLength);
          break;
       case GL_UNPACK_SKIP_PIXELS:
-         params[0] = ctx->Unpack.SkipPixels;
+         params[0] = (GLint64)(ctx->Unpack.SkipPixels);
          break;
       case GL_UNPACK_SKIP_ROWS:
-         params[0] = ctx->Unpack.SkipRows;
+         params[0] = (GLint64)(ctx->Unpack.SkipRows);
          break;
       case GL_UNPACK_SWAP_BYTES:
          params[0] = BOOLEAN_TO_INT64(ctx->Unpack.SwapBytes);
          break;
       case GL_UNPACK_SKIP_IMAGES_EXT:
-         params[0] = ctx->Unpack.SkipImages;
+         params[0] = (GLint64)(ctx->Unpack.SkipImages);
          break;
       case GL_UNPACK_IMAGE_HEIGHT_EXT:
-         params[0] = ctx->Unpack.ImageHeight;
+         params[0] = (GLint64)(ctx->Unpack.ImageHeight);
          break;
       case GL_UNPACK_CLIENT_STORAGE_APPLE:
          params[0] = BOOLEAN_TO_INT64(ctx->Unpack.ClientStorage);
          break;
       case GL_VIEWPORT:
-         params[0] = ctx->Viewport.X;
-         params[1] = ctx->Viewport.Y;
-         params[2] = ctx->Viewport.Width;
-         params[3] = ctx->Viewport.Height;
+         params[0] = (GLint64)(ctx->Viewport.X);
+         params[1] = (GLint64)(ctx->Viewport.Y);
+         params[2] = (GLint64)(ctx->Viewport.Width);
+         params[3] = (GLint64)(ctx->Viewport.Height);
          break;
       case GL_ZOOM_X:
          params[0] = IROUND64(ctx->Pixel.ZoomX);
@@ -6480,16 +6480,16 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->Vertex.Enabled);
          break;
       case GL_VERTEX_ARRAY_SIZE:
-         params[0] = ctx->Array.ArrayObj->Vertex.Size;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Vertex.Size);
          break;
       case GL_VERTEX_ARRAY_TYPE:
          params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->Vertex.Type);
          break;
       case GL_VERTEX_ARRAY_STRIDE:
-         params[0] = ctx->Array.ArrayObj->Vertex.Stride;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Vertex.Stride);
          break;
       case GL_VERTEX_ARRAY_COUNT_EXT:
-         params[0] = 0;
+         params[0] = (GLint64)(0);
          break;
       case GL_NORMAL_ARRAY:
          params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->Normal.Enabled);
@@ -6498,25 +6498,25 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->Normal.Type);
          break;
       case GL_NORMAL_ARRAY_STRIDE:
-         params[0] = ctx->Array.ArrayObj->Normal.Stride;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Normal.Stride);
          break;
       case GL_NORMAL_ARRAY_COUNT_EXT:
-         params[0] = 0;
+         params[0] = (GLint64)(0);
          break;
       case GL_COLOR_ARRAY:
          params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->Color.Enabled);
          break;
       case GL_COLOR_ARRAY_SIZE:
-         params[0] = ctx->Array.ArrayObj->Color.Size;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Color.Size);
          break;
       case GL_COLOR_ARRAY_TYPE:
          params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->Color.Type);
          break;
       case GL_COLOR_ARRAY_STRIDE:
-         params[0] = ctx->Array.ArrayObj->Color.Stride;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Color.Stride);
          break;
       case GL_COLOR_ARRAY_COUNT_EXT:
-         params[0] = 0;
+         params[0] = (GLint64)(0);
          break;
       case GL_INDEX_ARRAY:
          params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->Index.Enabled);
@@ -6525,46 +6525,46 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->Index.Type);
          break;
       case GL_INDEX_ARRAY_STRIDE:
-         params[0] = ctx->Array.ArrayObj->Index.Stride;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Index.Stride);
          break;
       case GL_INDEX_ARRAY_COUNT_EXT:
-         params[0] = 0;
+         params[0] = (GLint64)(0);
          break;
       case GL_TEXTURE_COORD_ARRAY:
          params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Enabled);
          break;
       case GL_TEXTURE_COORD_ARRAY_SIZE:
-         params[0] = ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Size;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Size);
          break;
       case GL_TEXTURE_COORD_ARRAY_TYPE:
          params[0] = ENUM_TO_INT64(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Type);
          break;
       case GL_TEXTURE_COORD_ARRAY_STRIDE:
-         params[0] = ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Stride;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].Stride);
          break;
       case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
-         params[0] = 0;
+         params[0] = (GLint64)(0);
          break;
       case GL_EDGE_FLAG_ARRAY:
          params[0] = BOOLEAN_TO_INT64(ctx->Array.ArrayObj->EdgeFlag.Enabled);
          break;
       case GL_EDGE_FLAG_ARRAY_STRIDE:
-         params[0] = ctx->Array.ArrayObj->EdgeFlag.Stride;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->EdgeFlag.Stride);
          break;
       case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
-         params[0] = 0;
+         params[0] = (GLint64)(0);
          break;
       case GL_MAX_TEXTURE_UNITS_ARB:
          CHECK_EXT1(ARB_multitexture, "GetInteger64v");
-         params[0] = ctx->Const.MaxTextureUnits;
+         params[0] = (GLint64)(ctx->Const.MaxTextureUnits);
          break;
       case GL_ACTIVE_TEXTURE_ARB:
          CHECK_EXT1(ARB_multitexture, "GetInteger64v");
-         params[0] = GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit;
+         params[0] = (GLint64)(GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit);
          break;
       case GL_CLIENT_ACTIVE_TEXTURE_ARB:
          CHECK_EXT1(ARB_multitexture, "GetInteger64v");
-         params[0] = GL_TEXTURE0_ARB + ctx->Array.ActiveTexture;
+         params[0] = (GLint64)(GL_TEXTURE0_ARB + ctx->Array.ActiveTexture);
          break;
       case GL_TEXTURE_CUBE_MAP_ARB:
          CHECK_EXT1(ARB_texture_cube_map, "GetInteger64v");
@@ -6572,17 +6572,17 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
          CHECK_EXT1(ARB_texture_cube_map, "GetInteger64v");
-         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_CUBE_INDEX]->Name;
+         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_CUBE_INDEX]->Name);
          break;
       case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
          CHECK_EXT1(ARB_texture_cube_map, "GetInteger64v");
-         params[0] = (1 << (ctx->Const.MaxCubeTextureLevels - 1));
+         params[0] = (GLint64)((1 << (ctx->Const.MaxCubeTextureLevels - 1)));
          break;
       case GL_TEXTURE_COMPRESSION_HINT_ARB:
-         params[0] = ctx->Hint.TextureCompression;
+         params[0] = (GLint64)(ctx->Hint.TextureCompression);
          break;
       case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
-         params[0] = _mesa_get_compressed_formats(ctx, NULL, GL_FALSE);
+         params[0] = (GLint64)(_mesa_get_compressed_formats(ctx, NULL, GL_FALSE));
          break;
       case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
          {
@@ -6595,11 +6595,11 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
          CHECK_EXT1(EXT_compiled_vertex_array, "GetInteger64v");
-         params[0] = ctx->Array.LockFirst;
+         params[0] = (GLint64)(ctx->Array.LockFirst);
          break;
       case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
          CHECK_EXT1(EXT_compiled_vertex_array, "GetInteger64v");
-         params[0] = ctx->Array.LockCount;
+         params[0] = (GLint64)(ctx->Array.LockCount);
          break;
       case GL_TRANSPOSE_COLOR_MATRIX_ARB:
          {
@@ -6707,10 +6707,10 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          }
          break;
       case GL_COLOR_MATRIX_STACK_DEPTH_SGI:
-         params[0] = ctx->ColorMatrixStack.Depth + 1;
+         params[0] = (GLint64)(ctx->ColorMatrixStack.Depth + 1);
          break;
       case GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI:
-         params[0] = MAX_COLOR_STACK_DEPTH;
+         params[0] = (GLint64)(MAX_COLOR_STACK_DEPTH);
          break;
       case GL_POST_COLOR_MATRIX_RED_SCALE_SGI:
          params[0] = IROUND64(ctx->Pixel.PostColorMatrixScale[0]);
@@ -6828,11 +6828,11 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
          CHECK_EXT1(EXT_secondary_color, "GetInteger64v");
-         params[0] = ctx->Array.ArrayObj->SecondaryColor.Stride;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->SecondaryColor.Stride);
          break;
       case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
          CHECK_EXT1(EXT_secondary_color, "GetInteger64v");
-         params[0] = ctx->Array.ArrayObj->SecondaryColor.Size;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->SecondaryColor.Size);
          break;
       case GL_CURRENT_FOG_COORDINATE_EXT:
          CHECK_EXT1(EXT_fog_coord, "GetInteger64v");
@@ -6851,7 +6851,7 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
          CHECK_EXT1(EXT_fog_coord, "GetInteger64v");
-         params[0] = ctx->Array.ArrayObj->FogCoord.Stride;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->FogCoord.Stride);
          break;
       case GL_FOG_COORDINATE_SOURCE_EXT:
          CHECK_EXT1(EXT_fog_coord, "GetInteger64v");
@@ -6884,10 +6884,10 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = BOOLEAN_TO_INT64(ctx->Multisample.SampleCoverageInvert);
          break;
       case GL_SAMPLE_BUFFERS_ARB:
-         params[0] = ctx->DrawBuffer->Visual.sampleBuffers;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.sampleBuffers);
          break;
       case GL_SAMPLES_ARB:
-         params[0] = ctx->DrawBuffer->Visual.samples;
+         params[0] = (GLint64)(ctx->DrawBuffer->Visual.samples);
          break;
       case GL_RASTER_POSITION_UNCLIPPED_IBM:
          CHECK_EXT1(IBM_rasterpos_clip, "GetInteger64v");
@@ -6911,7 +6911,7 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_VERTEX_PROGRAM_BINDING_NV:
          CHECK_EXT1(NV_vertex_program, "GetInteger64v");
-         params[0] = (ctx->VertexProgram.Current ? ctx->VertexProgram.Current->Base.Id : 0);
+         params[0] = (GLint64)((ctx->VertexProgram.Current ? ctx->VertexProgram.Current->Base.Id : 0));
          break;
       case GL_VERTEX_ATTRIB_ARRAY0_NV:
          CHECK_EXT1(NV_vertex_program, "GetInteger64v");
@@ -7047,11 +7047,11 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_FRAGMENT_PROGRAM_BINDING_NV:
          CHECK_EXT1(NV_fragment_program, "GetInteger64v");
-         params[0] = ctx->FragmentProgram.Current ? ctx->FragmentProgram.Current->Base.Id : 0;
+         params[0] = (GLint64)(ctx->FragmentProgram.Current ? ctx->FragmentProgram.Current->Base.Id : 0);
          break;
       case GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV:
          CHECK_EXT1(NV_fragment_program, "GetInteger64v");
-         params[0] = MAX_NV_FRAGMENT_PROGRAM_PARAMS;
+         params[0] = (GLint64)(MAX_NV_FRAGMENT_PROGRAM_PARAMS);
          break;
       case GL_TEXTURE_RECTANGLE_NV:
          CHECK_EXT1(NV_texture_rectangle, "GetInteger64v");
@@ -7059,11 +7059,11 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_TEXTURE_BINDING_RECTANGLE_NV:
          CHECK_EXT1(NV_texture_rectangle, "GetInteger64v");
-         params[0] = ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_RECT_INDEX]->Name;
+         params[0] = (GLint64)(ctx->Texture.Unit[ctx->Texture.CurrentUnit].CurrentTex[TEXTURE_RECT_INDEX]->Name);
          break;
       case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
          CHECK_EXT1(NV_texture_rectangle, "GetInteger64v");
-         params[0] = ctx->Const.MaxTextureRectSize;
+         params[0] = (GLint64)(ctx->Const.MaxTextureRectSize);
          break;
       case GL_STENCIL_TEST_TWO_SIDE_EXT:
          CHECK_EXT1(EXT_stencil_two_side, "GetInteger64v");
@@ -7082,42 +7082,42 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[0] = IROUND64(ctx->Const.MaxSpotExponent);
          break;
       case GL_ARRAY_BUFFER_BINDING_ARB:
-         params[0] = ctx->Array.ArrayBufferObj->Name;
+         params[0] = (GLint64)(ctx->Array.ArrayBufferObj->Name);
          break;
       case GL_VERTEX_ARRAY_BUFFER_BINDING_ARB:
-         params[0] = ctx->Array.ArrayObj->Vertex.BufferObj->Name;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Vertex.BufferObj->Name);
          break;
       case GL_NORMAL_ARRAY_BUFFER_BINDING_ARB:
-         params[0] = ctx->Array.ArrayObj->Normal.BufferObj->Name;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Normal.BufferObj->Name);
          break;
       case GL_COLOR_ARRAY_BUFFER_BINDING_ARB:
-         params[0] = ctx->Array.ArrayObj->Color.BufferObj->Name;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Color.BufferObj->Name);
          break;
       case GL_INDEX_ARRAY_BUFFER_BINDING_ARB:
-         params[0] = ctx->Array.ArrayObj->Index.BufferObj->Name;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Index.BufferObj->Name);
          break;
       case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB:
-         params[0] = ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].BufferObj->Name;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->TexCoord[ctx->Array.ActiveTexture].BufferObj->Name);
          break;
       case GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB:
-         params[0] = ctx->Array.ArrayObj->EdgeFlag.BufferObj->Name;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->EdgeFlag.BufferObj->Name);
          break;
       case GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB:
-         params[0] = ctx->Array.ArrayObj->SecondaryColor.BufferObj->Name;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->SecondaryColor.BufferObj->Name);
          break;
       case GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB:
-         params[0] = ctx->Array.ArrayObj->FogCoord.BufferObj->Name;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->FogCoord.BufferObj->Name);
          break;
       case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
-         params[0] = ctx->Array.ElementArrayBufferObj->Name;
+         params[0] = (GLint64)(ctx->Array.ElementArrayBufferObj->Name);
          break;
       case GL_PIXEL_PACK_BUFFER_BINDING_EXT:
          CHECK_EXT1(EXT_pixel_buffer_object, "GetInteger64v");
-         params[0] = ctx->Pack.BufferObj->Name;
+         params[0] = (GLint64)(ctx->Pack.BufferObj->Name);
          break;
       case GL_PIXEL_UNPACK_BUFFER_BINDING_EXT:
          CHECK_EXT1(EXT_pixel_buffer_object, "GetInteger64v");
-         params[0] = ctx->Unpack.BufferObj->Name;
+         params[0] = (GLint64)(ctx->Unpack.BufferObj->Name);
          break;
       case GL_VERTEX_PROGRAM_ARB:
          CHECK_EXT2(ARB_vertex_program, NV_vertex_program, "GetInteger64v");
@@ -7133,11 +7133,11 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB:
          CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetInteger64v");
-         params[0] = ctx->Const.MaxProgramMatrixStackDepth;
+         params[0] = (GLint64)(ctx->Const.MaxProgramMatrixStackDepth);
          break;
       case GL_MAX_PROGRAM_MATRICES_ARB:
          CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetInteger64v");
-         params[0] = ctx->Const.MaxProgramMatrices;
+         params[0] = (GLint64)(ctx->Const.MaxProgramMatrices);
          break;
       case GL_CURRENT_MATRIX_STACK_DEPTH_ARB:
          CHECK_EXT3(ARB_vertex_program, ARB_fragment_program, NV_vertex_program, "GetInteger64v");
@@ -7189,11 +7189,11 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_MAX_VERTEX_ATTRIBS_ARB:
          CHECK_EXT1(ARB_vertex_program, "GetInteger64v");
-         params[0] = ctx->Const.VertexProgram.MaxAttribs;
+         params[0] = (GLint64)(ctx->Const.VertexProgram.MaxAttribs);
          break;
       case GL_PROGRAM_ERROR_POSITION_ARB:
          CHECK_EXT4(NV_vertex_program, ARB_vertex_program, NV_fragment_program, ARB_fragment_program, "GetInteger64v");
-         params[0] = ctx->Program.ErrorPos;
+         params[0] = (GLint64)(ctx->Program.ErrorPos);
          break;
       case GL_FRAGMENT_PROGRAM_ARB:
          CHECK_EXT1(ARB_fragment_program, "GetInteger64v");
@@ -7201,11 +7201,11 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_MAX_TEXTURE_COORDS_ARB:
          CHECK_EXT2(ARB_fragment_program, NV_fragment_program, "GetInteger64v");
-         params[0] = ctx->Const.MaxTextureCoordUnits;
+         params[0] = (GLint64)(ctx->Const.MaxTextureCoordUnits);
          break;
       case GL_MAX_TEXTURE_IMAGE_UNITS_ARB:
          CHECK_EXT2(ARB_fragment_program, NV_fragment_program, "GetInteger64v");
-         params[0] = ctx->Const.MaxTextureImageUnits;
+         params[0] = (GLint64)(ctx->Const.MaxTextureImageUnits);
          break;
       case GL_DEPTH_BOUNDS_TEST_EXT:
          CHECK_EXT1(EXT_depth_bounds_test, "GetInteger64v");
@@ -7217,7 +7217,7 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          params[1] = IROUND64(ctx->Depth.BoundsMax);
          break;
       case GL_MAX_DRAW_BUFFERS_ARB:
-         params[0] = ctx->Const.MaxDrawBuffers;
+         params[0] = (GLint64)(ctx->Const.MaxDrawBuffers);
          break;
       case GL_DRAW_BUFFER0_ARB:
          params[0] = ENUM_TO_INT64(ctx->DrawBuffer->ColorDrawBuffer[0]);
@@ -7257,31 +7257,31 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_IMPLEMENTATION_COLOR_READ_TYPE_OES:
          CHECK_EXT1(OES_read_format, "GetInteger64v");
-         params[0] = ctx->Const.ColorReadType;
+         params[0] = (GLint64)(ctx->Const.ColorReadType);
          break;
       case GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES:
          CHECK_EXT1(OES_read_format, "GetInteger64v");
-         params[0] = ctx->Const.ColorReadFormat;
+         params[0] = (GLint64)(ctx->Const.ColorReadFormat);
          break;
       case GL_NUM_FRAGMENT_REGISTERS_ATI:
          CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
-         params[0] = 6;
+         params[0] = (GLint64)(6);
          break;
       case GL_NUM_FRAGMENT_CONSTANTS_ATI:
          CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
-         params[0] = 8;
+         params[0] = (GLint64)(8);
          break;
       case GL_NUM_PASSES_ATI:
          CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
-         params[0] = 2;
+         params[0] = (GLint64)(2);
          break;
       case GL_NUM_INSTRUCTIONS_PER_PASS_ATI:
          CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
-         params[0] = 8;
+         params[0] = (GLint64)(8);
          break;
       case GL_NUM_INSTRUCTIONS_TOTAL_ATI:
          CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
-         params[0] = 16;
+         params[0] = (GLint64)(16);
          break;
       case GL_COLOR_ALPHA_PAIRING_ATI:
          CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
@@ -7289,23 +7289,23 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_NUM_LOOPBACK_COMPONENTS_ATI:
          CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
-         params[0] = 3;
+         params[0] = (GLint64)(3);
          break;
       case GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI:
          CHECK_EXT1(ATI_fragment_shader, "GetInteger64v");
-         params[0] = 3;
+         params[0] = (GLint64)(3);
          break;
       case GL_STENCIL_BACK_FUNC:
          params[0] = ENUM_TO_INT64(ctx->Stencil.Function[1]);
          break;
       case GL_STENCIL_BACK_VALUE_MASK:
-         params[0] = ctx->Stencil.ValueMask[1];
+         params[0] = (GLint64)(ctx->Stencil.ValueMask[1]);
          break;
       case GL_STENCIL_BACK_WRITEMASK:
-         params[0] = ctx->Stencil.WriteMask[1];
+         params[0] = (GLint64)(ctx->Stencil.WriteMask[1]);
          break;
       case GL_STENCIL_BACK_REF:
-         params[0] = ctx->Stencil.Ref[1];
+         params[0] = (GLint64)(ctx->Stencil.Ref[1]);
          break;
       case GL_STENCIL_BACK_FAIL:
          params[0] = ENUM_TO_INT64(ctx->Stencil.FailFunc[1]);
@@ -7318,23 +7318,23 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_FRAMEBUFFER_BINDING_EXT:
          CHECK_EXT1(EXT_framebuffer_object, "GetInteger64v");
-         params[0] = ctx->DrawBuffer->Name;
+         params[0] = (GLint64)(ctx->DrawBuffer->Name);
          break;
       case GL_RENDERBUFFER_BINDING_EXT:
          CHECK_EXT1(EXT_framebuffer_object, "GetInteger64v");
-         params[0] = ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0;
+         params[0] = (GLint64)(ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0);
          break;
       case GL_MAX_COLOR_ATTACHMENTS_EXT:
          CHECK_EXT1(EXT_framebuffer_object, "GetInteger64v");
-         params[0] = ctx->Const.MaxColorAttachments;
+         params[0] = (GLint64)(ctx->Const.MaxColorAttachments);
          break;
       case GL_MAX_RENDERBUFFER_SIZE_EXT:
          CHECK_EXT1(EXT_framebuffer_object, "GetInteger64v");
-         params[0] = ctx->Const.MaxRenderbufferSize;
+         params[0] = (GLint64)(ctx->Const.MaxRenderbufferSize);
          break;
       case GL_READ_FRAMEBUFFER_BINDING_EXT:
          CHECK_EXT1(EXT_framebuffer_blit, "GetInteger64v");
-         params[0] = ctx->ReadBuffer->Name;
+         params[0] = (GLint64)(ctx->ReadBuffer->Name);
          break;
       case GL_PROVOKING_VERTEX_EXT:
          CHECK_EXT1(EXT_provoking_vertex, "GetInteger64v");
@@ -7346,7 +7346,7 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB:
          CHECK_EXT1(ARB_fragment_shader, "GetInteger64v");
-         params[0] = ctx->Const.FragmentProgram.MaxUniformComponents;
+         params[0] = (GLint64)(ctx->Const.FragmentProgram.MaxUniformComponents);
          break;
       case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB:
          CHECK_EXT1(ARB_fragment_shader, "GetInteger64v");
@@ -7354,31 +7354,31 @@ _mesa_GetInteger64v( GLenum pname, GLint64 *params )
          break;
       case GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB:
          CHECK_EXT1(ARB_vertex_shader, "GetInteger64v");
-         params[0] = ctx->Const.VertexProgram.MaxUniformComponents;
+         params[0] = (GLint64)(ctx->Const.VertexProgram.MaxUniformComponents);
          break;
       case GL_MAX_VARYING_FLOATS_ARB:
          CHECK_EXT1(ARB_vertex_shader, "GetInteger64v");
-         params[0] = ctx->Const.MaxVarying * 4;
+         params[0] = (GLint64)(ctx->Const.MaxVarying * 4);
          break;
       case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB:
          CHECK_EXT1(ARB_vertex_shader, "GetInteger64v");
-         params[0] = ctx->Const.MaxVertexTextureImageUnits;
+         params[0] = (GLint64)(ctx->Const.MaxVertexTextureImageUnits);
          break;
       case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB:
          CHECK_EXT1(ARB_vertex_shader, "GetInteger64v");
-         params[0] = MAX_COMBINED_TEXTURE_IMAGE_UNITS;
+         params[0] = (GLint64)(MAX_COMBINED_TEXTURE_IMAGE_UNITS);
          break;
       case GL_CURRENT_PROGRAM:
          CHECK_EXT1(ARB_shader_objects, "GetInteger64v");
-         params[0] = ctx->Shader.CurrentProgram ? ctx->Shader.CurrentProgram->Name : 0;
+         params[0] = (GLint64)(ctx->Shader.CurrentProgram ? ctx->Shader.CurrentProgram->Name : 0);
          break;
       case GL_MAX_SAMPLES:
          CHECK_EXT1(ARB_framebuffer_object, "GetInteger64v");
-         params[0] = ctx->Const.MaxSamples;
+         params[0] = (GLint64)(ctx->Const.MaxSamples);
          break;
       case GL_VERTEX_ARRAY_BINDING_APPLE:
          CHECK_EXT1(APPLE_vertex_array_object, "GetInteger64v");
-         params[0] = ctx->Array.ArrayObj->Name;
+         params[0] = (GLint64)(ctx->Array.ArrayObj->Name);
          break;
       case GL_TEXTURE_CUBE_MAP_SEAMLESS:
          CHECK_EXT1(ARB_seamless_cube_map, "GetInteger64v");
diff --git a/src/mesa/main/image.c b/src/mesa/main/image.c
index baecbab..139e56a 100644
--- a/src/mesa/main/image.c
+++ b/src/mesa/main/image.c
@@ -5511,7 +5511,7 @@ _mesa_clip_drawpixels(const GLcontext *ctx,
    }
 
    if (*height <= 0)
-      return GL_TRUE;
+      return GL_FALSE;
 
    return GL_TRUE;
 }
@@ -5564,7 +5564,7 @@ _mesa_clip_readpixels(const GLcontext *ctx,
       *height -= (*srcY + *height - buffer->Height);
 
    if (*height <= 0)
-      return GL_TRUE;
+      return GL_FALSE;
 
    return GL_TRUE;
 }
diff --git a/src/mesa/main/imports.c b/src/mesa/main/imports.c
index 6ffaddc..91d8d15 100644
--- a/src/mesa/main/imports.c
+++ b/src/mesa/main/imports.c
@@ -48,6 +48,13 @@
 #include "context.h"
 #include "version.h"
 
+#ifdef _GNU_SOURCE
+#include <locale.h>
+#ifdef __APPLE__
+#include <xlocale.h>
+#endif
+#endif
+
 
 #define MAXSTRING 4000  /* for vsnprintf() */
 
@@ -908,7 +915,15 @@ _mesa_atoi(const char *s)
 double
 _mesa_strtod( const char *s, char **end )
 {
+#ifdef _GNU_SOURCE
+   static locale_t loc = NULL;
+   if (!loc) {
+      loc = newlocale(LC_CTYPE_MASK, "C", NULL);
+   }
+   return strtod_l(s, end, loc);
+#else
    return strtod(s, end);
+#endif
 }
 
 /** Compute simple checksum/hash for a string */
@@ -919,9 +934,9 @@ _mesa_str_checksum(const char *str)
    unsigned int sum, i;
    const char *c;
    sum = i = 1;
-   for (c = str; *c; c++)
+   for (c = str; *c; c++, i++)
       sum += *c * (i % 100);
-   return sum;
+   return sum + i;
 }
 
 
diff --git a/src/mesa/main/mipmap.c b/src/mesa/main/mipmap.c
index 3dca09d..c3928fa 100644
--- a/src/mesa/main/mipmap.c
+++ b/src/mesa/main/mipmap.c
@@ -1501,8 +1501,7 @@ _mesa_generate_mipmap(GLcontext *ctx, GLenum target,
    GLuint comps;
 
    ASSERT(texObj);
-   /* XXX choose cube map face here??? */
-   srcImage = texObj->Image[0][texObj->BaseLevel];
+   srcImage = _mesa_select_tex_image(ctx, texObj, target, texObj->BaseLevel);
    ASSERT(srcImage);
 
    maxLevels = _mesa_max_texture_levels(ctx, texObj->Target);
@@ -1510,7 +1509,9 @@ _mesa_generate_mipmap(GLcontext *ctx, GLenum target,
 
    /* Find convertFormat - the format that do_row() will process */
    if (srcImage->IsCompressed) {
-      /* setup for compressed textures */
+      /* setup for compressed textures - need to allocate temporary
+       * image buffers to hold uncompressed images.
+       */
       GLuint row;
       GLint  components, size;
       GLchan *dst;
@@ -1587,11 +1588,7 @@ _mesa_generate_mipmap(GLcontext *ctx, GLenum target,
                                          &dstWidth, &dstHeight, &dstDepth);
       if (!nextLevel) {
          /* all done */
-         if (srcImage->IsCompressed) {
-            _mesa_free((void *) srcData);
-            _mesa_free(dstData);
-         }
-         return;
+         break;
       }
 
       /* get dest gl_texture_image */
@@ -1682,6 +1679,12 @@ _mesa_generate_mipmap(GLcontext *ctx, GLenum target,
       }
 
    } /* loop over mipmap levels */
+
+   if (srcImage->IsCompressed) {
+      /* free uncompressed image buffers */
+      _mesa_free((void *) srcData);
+      _mesa_free(dstData);
+   }
 }
 
 
diff --git a/src/mesa/main/renderbuffer.c b/src/mesa/main/renderbuffer.c
index 38be826..5bef7c8 100644
--- a/src/mesa/main/renderbuffer.c
+++ b/src/mesa/main/renderbuffer.c
@@ -1955,7 +1955,7 @@ _mesa_add_aux_renderbuffers(GLcontext *ctx, struct gl_framebuffer *fb,
       return GL_FALSE;
    }
 
-   assert(numBuffers < MAX_AUX_BUFFERS);
+   assert(numBuffers <= MAX_AUX_BUFFERS);
 
    for (i = 0; i < numBuffers; i++) {
       struct gl_renderbuffer *rb = _mesa_new_renderbuffer(ctx, 0);
diff --git a/src/mesa/main/syncobj.c b/src/mesa/main/syncobj.c
index 64f923f..ac3f9eb 100644
--- a/src/mesa/main/syncobj.c
+++ b/src/mesa/main/syncobj.c
@@ -190,7 +190,7 @@ _mesa_unref_sync_object(GLcontext *ctx, struct gl_sync_object *syncObj)
 }
 
 
-GLboolean
+GLboolean GLAPIENTRY
 _mesa_IsSync(GLsync sync)
 {
    GET_CURRENT_CONTEXT(ctx);
@@ -201,7 +201,7 @@ _mesa_IsSync(GLsync sync)
 }
 
 
-void
+void GLAPIENTRY
 _mesa_DeleteSync(GLsync sync)
 {
    GET_CURRENT_CONTEXT(ctx);
@@ -231,7 +231,7 @@ _mesa_DeleteSync(GLsync sync)
 }
 
 
-GLsync
+GLsync GLAPIENTRY
 _mesa_FenceSync(GLenum condition, GLbitfield flags)
 {
    GET_CURRENT_CONTEXT(ctx);
@@ -278,7 +278,7 @@ _mesa_FenceSync(GLenum condition, GLbitfield flags)
 }
 
 
-GLenum
+GLenum GLAPIENTRY
 _mesa_ClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
 {
    GET_CURRENT_CONTEXT(ctx);
@@ -319,7 +319,7 @@ _mesa_ClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
 }
 
 
-void
+void GLAPIENTRY
 _mesa_WaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
 {
    GET_CURRENT_CONTEXT(ctx);
@@ -348,7 +348,7 @@ _mesa_WaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
 }
 
 
-void
+void GLAPIENTRY
 _mesa_GetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length,
 		GLint *values)
 {
diff --git a/src/mesa/main/syncobj.h b/src/mesa/main/syncobj.h
index fc160af..f23fa28 100644
--- a/src/mesa/main/syncobj.h
+++ b/src/mesa/main/syncobj.h
@@ -48,22 +48,22 @@ _mesa_ref_sync_object(GLcontext *ctx, struct gl_sync_object *syncObj);
 extern void
 _mesa_unref_sync_object(GLcontext *ctx, struct gl_sync_object *syncObj);
 
-extern GLboolean
+extern GLboolean GLAPIENTRY
 _mesa_IsSync(GLsync sync);
 
-extern void
+extern void GLAPIENTRY
 _mesa_DeleteSync(GLsync sync);
 
-extern GLsync
+extern GLsync GLAPIENTRY
 _mesa_FenceSync(GLenum condition, GLbitfield flags);
 
-extern GLenum
+extern GLenum GLAPIENTRY
 _mesa_ClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
 
-extern void
+extern void GLAPIENTRY
 _mesa_WaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
 
-extern void
+extern void GLAPIENTRY
 _mesa_GetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length,
 		GLint *values);
 
diff --git a/src/mesa/main/texcompress.c b/src/mesa/main/texcompress.c
index c1b8c76..2cda4dd 100644
--- a/src/mesa/main/texcompress.c
+++ b/src/mesa/main/texcompress.c
@@ -360,3 +360,53 @@ _mesa_compressed_image_address(GLint col, GLint row, GLint img,
 
    return addr;
 }
+
+
+/**
+ * Given a compressed MESA_FORMAT_x value, return the corresponding
+ * GLenum for that format.
+ * This is needed for glGetTexLevelParameter(GL_TEXTURE_INTERNAL_FORMAT)
+ * which must return the specific texture format used when the user might
+ * have originally specified a generic compressed format in their
+ * glTexImage2D() call.
+ * For non-compressed textures, we always return the user-specified
+ * internal format unchanged.
+ */
+GLenum
+_mesa_compressed_format_to_glenum(GLcontext *ctx, GLuint mesaFormat)
+{
+   switch (mesaFormat) {
+#if FEATURE_texture_fxt1
+   case MESA_FORMAT_RGB_FXT1:
+      return GL_COMPRESSED_RGB_FXT1_3DFX;
+   case MESA_FORMAT_RGBA_FXT1:
+      return GL_COMPRESSED_RGBA_FXT1_3DFX;
+#endif
+#if FEATURE_texture_s3tc
+   case MESA_FORMAT_RGB_DXT1:
+      return GL_COMPRESSED_RGB_S3TC_DXT1_EXT;
+   case MESA_FORMAT_RGBA_DXT1:
+      return GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;
+   case MESA_FORMAT_RGBA_DXT3:
+      return GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;
+   case MESA_FORMAT_RGBA_DXT5:
+      return GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
+#if FEATURE_EXT_texture_sRGB
+   case MESA_FORMAT_SRGB_DXT1:
+      return GL_COMPRESSED_SRGB_S3TC_DXT1_EXT;
+   case MESA_FORMAT_SRGBA_DXT1:
+      return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
+   case MESA_FORMAT_SRGBA_DXT3:
+      return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
+   case MESA_FORMAT_SRGBA_DXT5:
+      return GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
+#endif
+#endif
+   default:
+      _mesa_problem(ctx, "Unexpected mesa texture format in"
+                    " _mesa_compressed_format_to_glenum()");
+      return 0;
+   }
+}
+
+
diff --git a/src/mesa/main/texcompress.h b/src/mesa/main/texcompress.h
index 44f3338..0f1a38f 100644
--- a/src/mesa/main/texcompress.h
+++ b/src/mesa/main/texcompress.h
@@ -52,6 +52,10 @@ _mesa_compressed_image_address(GLint col, GLint row, GLint img,
                                GLsizei width, const GLubyte *image);
 
 
+extern GLenum
+_mesa_compressed_format_to_glenum(GLcontext *ctx, GLuint mesaFormat);
+
+
 extern void
 _mesa_init_texture_s3tc( GLcontext *ctx );
 
diff --git a/src/mesa/main/texformat.c b/src/mesa/main/texformat.c
index c709004..9d5534e 100644
--- a/src/mesa/main/texformat.c
+++ b/src/mesa/main/texformat.c
@@ -1590,25 +1590,25 @@ _mesa_choose_tex_format( GLcontext *ctx, GLint internalFormat,
       case GL_COMPRESSED_INTENSITY_ARB:
          return &_mesa_texformat_intensity;
       case GL_COMPRESSED_RGB_ARB:
-#if FEATURE_texture_fxt1
-         if (ctx->Extensions.TDFX_texture_compression_FXT1)
-            return &_mesa_texformat_rgb_fxt1;
-#endif
 #if FEATURE_texture_s3tc
          if (ctx->Extensions.EXT_texture_compression_s3tc ||
              ctx->Extensions.S3_s3tc)
             return &_mesa_texformat_rgb_dxt1;
 #endif
-         return &_mesa_texformat_rgb;
-      case GL_COMPRESSED_RGBA_ARB:
 #if FEATURE_texture_fxt1
          if (ctx->Extensions.TDFX_texture_compression_FXT1)
-            return &_mesa_texformat_rgba_fxt1;
+            return &_mesa_texformat_rgb_fxt1;
 #endif
+         return &_mesa_texformat_rgb;
+      case GL_COMPRESSED_RGBA_ARB:
 #if FEATURE_texture_s3tc
          if (ctx->Extensions.EXT_texture_compression_s3tc ||
              ctx->Extensions.S3_s3tc)
-            return &_mesa_texformat_rgba_dxt3; /* Not rgba_dxt1, see spec */
+            return &_mesa_texformat_rgba_dxt5; /* Not rgba_dxt1, see spec */
+#endif
+#if FEATURE_texture_fxt1
+         if (ctx->Extensions.TDFX_texture_compression_FXT1)
+            return &_mesa_texformat_rgba_fxt1;
 #endif
          return &_mesa_texformat_rgba;
       default:
diff --git a/src/mesa/main/texobj.c b/src/mesa/main/texobj.c
index d09c439..da55ac8 100644
--- a/src/mesa/main/texobj.c
+++ b/src/mesa/main/texobj.c
@@ -863,7 +863,7 @@ unbind_texobj_from_texunits(GLcontext *ctx, struct gl_texture_object *texObj)
       for (tex = 0; tex < NUM_TEXTURE_TARGETS; tex++) {
          if (texObj == unit->CurrentTex[tex]) {
             _mesa_reference_texobj(&unit->CurrentTex[tex],
-                                   ctx->Shared->DefaultTex[TEXTURE_1D_INDEX]);
+                                   ctx->Shared->DefaultTex[tex]);
             ASSERT(unit->CurrentTex[tex]);
             break;
          }
diff --git a/src/mesa/main/texparam.c b/src/mesa/main/texparam.c
index b2fbe22..9d1fdd0 100644
--- a/src/mesa/main/texparam.c
+++ b/src/mesa/main/texparam.c
@@ -776,7 +776,15 @@ _mesa_GetTexLevelParameteriv( GLenum target, GLint level,
          *params = img->Depth;
          break;
       case GL_TEXTURE_INTERNAL_FORMAT:
-         *params = img->InternalFormat;
+         if (img->IsCompressed) {
+            /* need to return the actual compressed format */
+            *params = _mesa_compressed_format_to_glenum(ctx,
+                                          img->TexFormat->MesaFormat);
+         }
+         else {
+            /* return the user's requested internal format */
+            *params = img->InternalFormat;
+         }
          break;
       case GL_TEXTURE_BORDER:
          *params = img->Border;
diff --git a/src/mesa/main/texstate.c b/src/mesa/main/texstate.c
index 861c5f3..8292d43 100644
--- a/src/mesa/main/texstate.c
+++ b/src/mesa/main/texstate.c
@@ -99,16 +99,22 @@ _mesa_copy_texture_state( const GLcontext *src, GLcontext *dst )
       dst->Texture.Unit[u].BumpTarget = src->Texture.Unit[u].BumpTarget;
       COPY_4V(dst->Texture.Unit[u].RotMatrix, src->Texture.Unit[u].RotMatrix);
 
+      /*
+       * XXX strictly speaking, we should compare texture names/ids and
+       * bind textures in the dest context according to id.  For now, only
+       * copy bindings if the contexts share the same pool of textures to
+       * avoid refcounting bugs.
+       */
+      if (dst->Shared == src->Shared) {
+         /* copy texture object bindings, not contents of texture objects */
+         _mesa_lock_context_textures(dst);
 
-      /* copy texture object bindings, not contents of texture objects */
-      _mesa_lock_context_textures(dst);
-
-      for (tex = 0; tex < NUM_TEXTURE_TARGETS; tex++) {
-         _mesa_reference_texobj(&dst->Texture.Unit[u].CurrentTex[tex],
-                                src->Texture.Unit[u].CurrentTex[tex]);
+         for (tex = 0; tex < NUM_TEXTURE_TARGETS; tex++) {
+            _mesa_reference_texobj(&dst->Texture.Unit[u].CurrentTex[tex],
+                                   src->Texture.Unit[u].CurrentTex[tex]);
+         }
+         _mesa_unlock_context_textures(dst);
       }
-
-      _mesa_unlock_context_textures(dst);
    }
 }
 
diff --git a/src/mesa/main/texstore.c b/src/mesa/main/texstore.c
index a22db62..d323795 100644
--- a/src/mesa/main/texstore.c
+++ b/src/mesa/main/texstore.c
@@ -589,8 +589,12 @@ _mesa_make_temp_chan_image(GLcontext *ctx, GLuint dims,
    /* unpack and transfer the source image */
    tempImage = (GLchan *) _mesa_malloc(srcWidth * srcHeight * srcDepth
                                        * components * sizeof(GLchan));
-   if (!tempImage)
+   if (!tempImage) {
+      if (freeSrcImage) {
+         _mesa_free((void *) srcAddr);
+      }
       return NULL;
+   }
 
    dst = tempImage;
    for (img = 0; img < srcDepth; img++) {
diff --git a/src/mesa/shader/hash_table.c b/src/mesa/shader/hash_table.c
index 881179f..e89a256 100644
--- a/src/mesa/shader/hash_table.c
+++ b/src/mesa/shader/hash_table.c
@@ -27,10 +27,6 @@
  *
  * \author Ian Romanick <ian.d.romanick@intel.com>
  */
-#include <stdlib.h>
-#include <string.h>
-
-#include <assert.h>
 
 #include "main/imports.h"
 #include "main/simple_list.h"
diff --git a/src/mesa/shader/lex.yy.c b/src/mesa/shader/lex.yy.c
index 709426f..728c2dc 100644
--- a/src/mesa/shader/lex.yy.c
+++ b/src/mesa/shader/lex.yy.c
@@ -53,7 +53,6 @@ typedef int flex_int32_t;
 typedef unsigned char flex_uint8_t; 
 typedef unsigned short int flex_uint16_t;
 typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
 
 /* Limits of integral types. */
 #ifndef INT8_MIN
@@ -84,6 +83,8 @@ typedef unsigned int flex_uint32_t;
 #define UINT32_MAX             (4294967295U)
 #endif
 
+#endif /* ! C99 */
+
 #endif /* ! FLEXINT_H */
 
 #ifdef __cplusplus
@@ -157,7 +158,15 @@ typedef void* yyscan_t;
 
 /* Size of default input buffer. */
 #ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
 #define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
 #endif
 
 /* The state buf must be large enough to hold one state per character in the main buffer.
@@ -900,6 +909,7 @@ static yyconst flex_int16_t yy_chk[1023] =
  * DEALINGS IN THE SOFTWARE.
  */
 #include "main/glheader.h"
+#include "main/imports.h"
 #include "prog_instruction.h"
 #include "prog_statevars.h"
 
@@ -917,7 +927,7 @@ static yyconst flex_int16_t yy_chk[1023] =
       if (condition) {					\
 	 return token;					\
       } else {						\
-	 yylval->string = strdup(yytext);		\
+	 yylval->string = return_string(yyextra, yytext);	\
 	 return IDENTIFIER;				\
       }							\
    } while (0)
@@ -940,7 +950,7 @@ static yyconst flex_int16_t yy_chk[1023] =
 	 yylval->temp_inst.SaturateMode = SATURATE_ ## sat; \
 	 return token;					\
       } else {						\
-	 yylval->string = strdup(yytext);		\
+	 yylval->string = return_string(yyextra, yytext);		\
 	 return IDENTIFIER;				\
       }							\
    } while (0)
@@ -948,6 +958,45 @@ static yyconst flex_int16_t yy_chk[1023] =
 #define SWIZZLE_INVAL  MAKE_SWIZZLE4(SWIZZLE_NIL, SWIZZLE_NIL, \
 				     SWIZZLE_NIL, SWIZZLE_NIL)
 
+/**
+ * Send a string to the parser using asm_parser_state::string_dumpster
+ *
+ * Sends a string to the parser using asm_parser_state::string_dumpster as a
+ * temporary storage buffer.  Data previously stored in
+ * asm_parser_state::string_dumpster will be lost.  If
+ * asm_parser_state::string_dumpster is not large enough to hold the new
+ * string, the buffer size will be increased.  The buffer size is \b never
+ * decreased.
+ *
+ * \param state   Assembler parser state tracking
+ * \param str     String to be passed to the parser
+ *
+ * \return
+ * A pointer to asm_parser_state::string_dumpster on success or \c NULL on
+ * failure.  Currently the only failure case is \c ENOMEM.
+ */
+static char *
+return_string(struct asm_parser_state *state, const char *str)
+{
+   const size_t len = strlen(str);
+
+   if (len >= state->dumpster_size) {
+      char *const dumpster = _mesa_realloc(state->string_dumpster,
+					   state->dumpster_size,
+					   len + 1);
+      if (dumpster == NULL) {
+	 return NULL;
+      }
+
+      state->string_dumpster = dumpster;
+      state->dumpster_size = len + 1;
+   }
+
+   memcpy(state->string_dumpster, str, len + 1);
+   return state->string_dumpster;
+}
+
+
 static unsigned
 mask_from_char(char c)
 {
@@ -1003,7 +1052,7 @@ swiz_from_char(char c)
    } while(0);
 
 #define YY_EXTRA_TYPE struct asm_parser_state *
-#line 1007 "lex.yy.c"
+#line 1056 "lex.yy.c"
 
 #define INITIAL 0
 
@@ -1140,7 +1189,12 @@ static int input (yyscan_t yyscanner );
 
 /* Amount of stuff to slurp up with each read. */
 #ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
 #define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
@@ -1148,7 +1202,7 @@ static int input (yyscan_t yyscanner );
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -1159,7 +1213,7 @@ static int input (yyscan_t yyscanner );
 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
 		int c = '*'; \
-		unsigned n; \
+		size_t n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
@@ -1244,10 +1298,10 @@ YY_DECL
 	register int yy_act;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
-#line 136 "program_lexer.l"
+#line 176 "program_lexer.l"
 
 
-#line 1251 "lex.yy.c"
+#line 1305 "lex.yy.c"
 
     yylval = yylval_param;
 
@@ -1336,17 +1390,17 @@ do_action:	/* This label is used only to access EOF actions. */
 
 case 1:
 YY_RULE_SETUP
-#line 138 "program_lexer.l"
+#line 178 "program_lexer.l"
 { return ARBvp_10; }
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 139 "program_lexer.l"
+#line 179 "program_lexer.l"
 { return ARBfp_10; }
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 140 "program_lexer.l"
+#line 180 "program_lexer.l"
 {
    yylval->integer = at_address;
    return_token_or_IDENTIFIER(require_ARB_vp, ADDRESS);
@@ -1354,760 +1408,760 @@ YY_RULE_SETUP
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 144 "program_lexer.l"
+#line 184 "program_lexer.l"
 { return ALIAS; }
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 145 "program_lexer.l"
+#line 185 "program_lexer.l"
 { return ATTRIB; }
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 146 "program_lexer.l"
+#line 186 "program_lexer.l"
 { return END; }
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 147 "program_lexer.l"
+#line 187 "program_lexer.l"
 { return OPTION; }
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 148 "program_lexer.l"
+#line 188 "program_lexer.l"
 { return OUTPUT; }
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 149 "program_lexer.l"
+#line 189 "program_lexer.l"
 { return PARAM; }
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 150 "program_lexer.l"
+#line 190 "program_lexer.l"
 { yylval->integer = at_temp; return TEMP; }
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 152 "program_lexer.l"
+#line 192 "program_lexer.l"
 { return_opcode(             1, VECTOR_OP, ABS, OFF); }
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 153 "program_lexer.l"
+#line 193 "program_lexer.l"
 { return_opcode(require_ARB_fp, VECTOR_OP, ABS, ZERO_ONE); }
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 154 "program_lexer.l"
+#line 194 "program_lexer.l"
 { return_opcode(             1, BIN_OP, ADD, OFF); }
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 155 "program_lexer.l"
+#line 195 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, ADD, ZERO_ONE); }
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 156 "program_lexer.l"
+#line 196 "program_lexer.l"
 { return_opcode(require_ARB_vp, ARL, ARL, OFF); }
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 158 "program_lexer.l"
+#line 198 "program_lexer.l"
 { return_opcode(require_ARB_fp, TRI_OP, CMP, OFF); }
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 159 "program_lexer.l"
+#line 199 "program_lexer.l"
 { return_opcode(require_ARB_fp, TRI_OP, CMP, ZERO_ONE); }
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 160 "program_lexer.l"
+#line 200 "program_lexer.l"
 { return_opcode(require_ARB_fp, SCALAR_OP, COS, OFF); }
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 161 "program_lexer.l"
+#line 201 "program_lexer.l"
 { return_opcode(require_ARB_fp, SCALAR_OP, COS, ZERO_ONE); }
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 163 "program_lexer.l"
+#line 203 "program_lexer.l"
 { return_opcode(             1, BIN_OP, DP3, OFF); }
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 164 "program_lexer.l"
+#line 204 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, DP3, ZERO_ONE); }
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 165 "program_lexer.l"
+#line 205 "program_lexer.l"
 { return_opcode(             1, BIN_OP, DP4, OFF); }
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 166 "program_lexer.l"
+#line 206 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, DP4, ZERO_ONE); }
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 167 "program_lexer.l"
+#line 207 "program_lexer.l"
 { return_opcode(             1, BIN_OP, DPH, OFF); }
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 168 "program_lexer.l"
+#line 208 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, DPH, ZERO_ONE); }
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 169 "program_lexer.l"
+#line 209 "program_lexer.l"
 { return_opcode(             1, BIN_OP, DST, OFF); }
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 170 "program_lexer.l"
+#line 210 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, DST, ZERO_ONE); }
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 172 "program_lexer.l"
+#line 212 "program_lexer.l"
 { return_opcode(             1, SCALAR_OP, EX2, OFF); }
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 173 "program_lexer.l"
+#line 213 "program_lexer.l"
 { return_opcode(require_ARB_fp, SCALAR_OP, EX2, ZERO_ONE); }
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 174 "program_lexer.l"
+#line 214 "program_lexer.l"
 { return_opcode(require_ARB_vp, SCALAR_OP, EXP, OFF); }
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 176 "program_lexer.l"
+#line 216 "program_lexer.l"
 { return_opcode(             1, VECTOR_OP, FLR, OFF); }
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 177 "program_lexer.l"
+#line 217 "program_lexer.l"
 { return_opcode(require_ARB_fp, VECTOR_OP, FLR, ZERO_ONE); }
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 178 "program_lexer.l"
+#line 218 "program_lexer.l"
 { return_opcode(             1, VECTOR_OP, FRC, OFF); }
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 179 "program_lexer.l"
+#line 219 "program_lexer.l"
 { return_opcode(require_ARB_fp, VECTOR_OP, FRC, ZERO_ONE); }
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 181 "program_lexer.l"
+#line 221 "program_lexer.l"
 { return_opcode(require_ARB_fp, KIL, KIL, OFF); }
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 183 "program_lexer.l"
+#line 223 "program_lexer.l"
 { return_opcode(             1, VECTOR_OP, LIT, OFF); }
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 184 "program_lexer.l"
+#line 224 "program_lexer.l"
 { return_opcode(require_ARB_fp, VECTOR_OP, LIT, ZERO_ONE); }
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 185 "program_lexer.l"
+#line 225 "program_lexer.l"
 { return_opcode(             1, SCALAR_OP, LG2, OFF); }
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 186 "program_lexer.l"
+#line 226 "program_lexer.l"
 { return_opcode(require_ARB_fp, SCALAR_OP, LG2, ZERO_ONE); }
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 187 "program_lexer.l"
+#line 227 "program_lexer.l"
 { return_opcode(require_ARB_vp, SCALAR_OP, LOG, OFF); }
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 188 "program_lexer.l"
+#line 228 "program_lexer.l"
 { return_opcode(require_ARB_fp, TRI_OP, LRP, OFF); }
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 189 "program_lexer.l"
+#line 229 "program_lexer.l"
 { return_opcode(require_ARB_fp, TRI_OP, LRP, ZERO_ONE); }
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 191 "program_lexer.l"
+#line 231 "program_lexer.l"
 { return_opcode(             1, TRI_OP, MAD, OFF); }
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 192 "program_lexer.l"
+#line 232 "program_lexer.l"
 { return_opcode(require_ARB_fp, TRI_OP, MAD, ZERO_ONE); }
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 193 "program_lexer.l"
+#line 233 "program_lexer.l"
 { return_opcode(             1, BIN_OP, MAX, OFF); }
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 194 "program_lexer.l"
+#line 234 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, MAX, ZERO_ONE); }
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 195 "program_lexer.l"
+#line 235 "program_lexer.l"
 { return_opcode(             1, BIN_OP, MIN, OFF); }
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
-#line 196 "program_lexer.l"
+#line 236 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, MIN, ZERO_ONE); }
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 197 "program_lexer.l"
+#line 237 "program_lexer.l"
 { return_opcode(             1, VECTOR_OP, MOV, OFF); }
 	YY_BREAK
 case 50:
 YY_RULE_SETUP
-#line 198 "program_lexer.l"
+#line 238 "program_lexer.l"
 { return_opcode(require_ARB_fp, VECTOR_OP, MOV, ZERO_ONE); }
 	YY_BREAK
 case 51:
 YY_RULE_SETUP
-#line 199 "program_lexer.l"
+#line 239 "program_lexer.l"
 { return_opcode(             1, BIN_OP, MUL, OFF); }
 	YY_BREAK
 case 52:
 YY_RULE_SETUP
-#line 200 "program_lexer.l"
+#line 240 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, MUL, ZERO_ONE); }
 	YY_BREAK
 case 53:
 YY_RULE_SETUP
-#line 202 "program_lexer.l"
+#line 242 "program_lexer.l"
 { return_opcode(             1, BINSC_OP, POW, OFF); }
 	YY_BREAK
 case 54:
 YY_RULE_SETUP
-#line 203 "program_lexer.l"
+#line 243 "program_lexer.l"
 { return_opcode(require_ARB_fp, BINSC_OP, POW, ZERO_ONE); }
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 205 "program_lexer.l"
+#line 245 "program_lexer.l"
 { return_opcode(             1, SCALAR_OP, RCP, OFF); }
 	YY_BREAK
 case 56:
 YY_RULE_SETUP
-#line 206 "program_lexer.l"
+#line 246 "program_lexer.l"
 { return_opcode(require_ARB_fp, SCALAR_OP, RCP, ZERO_ONE); }
 	YY_BREAK
 case 57:
 YY_RULE_SETUP
-#line 207 "program_lexer.l"
+#line 247 "program_lexer.l"
 { return_opcode(             1, SCALAR_OP, RSQ, OFF); }
 	YY_BREAK
 case 58:
 YY_RULE_SETUP
-#line 208 "program_lexer.l"
+#line 248 "program_lexer.l"
 { return_opcode(require_ARB_fp, SCALAR_OP, RSQ, ZERO_ONE); }
 	YY_BREAK
 case 59:
 YY_RULE_SETUP
-#line 210 "program_lexer.l"
+#line 250 "program_lexer.l"
 { return_opcode(require_ARB_fp, SCALAR_OP, SCS, OFF); }
 	YY_BREAK
 case 60:
 YY_RULE_SETUP
-#line 211 "program_lexer.l"
+#line 251 "program_lexer.l"
 { return_opcode(require_ARB_fp, SCALAR_OP, SCS, ZERO_ONE); }
 	YY_BREAK
 case 61:
 YY_RULE_SETUP
-#line 212 "program_lexer.l"
+#line 252 "program_lexer.l"
 { return_opcode(             1, BIN_OP, SGE, OFF); }
 	YY_BREAK
 case 62:
 YY_RULE_SETUP
-#line 213 "program_lexer.l"
+#line 253 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, SGE, ZERO_ONE); }
 	YY_BREAK
 case 63:
 YY_RULE_SETUP
-#line 214 "program_lexer.l"
+#line 254 "program_lexer.l"
 { return_opcode(require_ARB_fp, SCALAR_OP, SIN, OFF); }
 	YY_BREAK
 case 64:
 YY_RULE_SETUP
-#line 215 "program_lexer.l"
+#line 255 "program_lexer.l"
 { return_opcode(require_ARB_fp, SCALAR_OP, SIN, ZERO_ONE); }
 	YY_BREAK
 case 65:
 YY_RULE_SETUP
-#line 216 "program_lexer.l"
+#line 256 "program_lexer.l"
 { return_opcode(             1, BIN_OP, SLT, OFF); }
 	YY_BREAK
 case 66:
 YY_RULE_SETUP
-#line 217 "program_lexer.l"
+#line 257 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, SLT, ZERO_ONE); }
 	YY_BREAK
 case 67:
 YY_RULE_SETUP
-#line 218 "program_lexer.l"
+#line 258 "program_lexer.l"
 { return_opcode(             1, BIN_OP, SUB, OFF); }
 	YY_BREAK
 case 68:
 YY_RULE_SETUP
-#line 219 "program_lexer.l"
+#line 259 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, SUB, ZERO_ONE); }
 	YY_BREAK
 case 69:
 YY_RULE_SETUP
-#line 220 "program_lexer.l"
+#line 260 "program_lexer.l"
 { return_opcode(             1, SWZ, SWZ, OFF); }
 	YY_BREAK
 case 70:
 YY_RULE_SETUP
-#line 221 "program_lexer.l"
+#line 261 "program_lexer.l"
 { return_opcode(require_ARB_fp, SWZ, SWZ, ZERO_ONE); }
 	YY_BREAK
 case 71:
 YY_RULE_SETUP
-#line 223 "program_lexer.l"
+#line 263 "program_lexer.l"
 { return_opcode(require_ARB_fp, SAMPLE_OP, TEX, OFF); }
 	YY_BREAK
 case 72:
 YY_RULE_SETUP
-#line 224 "program_lexer.l"
+#line 264 "program_lexer.l"
 { return_opcode(require_ARB_fp, SAMPLE_OP, TEX, ZERO_ONE); }
 	YY_BREAK
 case 73:
 YY_RULE_SETUP
-#line 225 "program_lexer.l"
+#line 265 "program_lexer.l"
 { return_opcode(require_ARB_fp, SAMPLE_OP, TXB, OFF); }
 	YY_BREAK
 case 74:
 YY_RULE_SETUP
-#line 226 "program_lexer.l"
+#line 266 "program_lexer.l"
 { return_opcode(require_ARB_fp, SAMPLE_OP, TXB, ZERO_ONE); }
 	YY_BREAK
 case 75:
 YY_RULE_SETUP
-#line 227 "program_lexer.l"
+#line 267 "program_lexer.l"
 { return_opcode(require_ARB_fp, SAMPLE_OP, TXP, OFF); }
 	YY_BREAK
 case 76:
 YY_RULE_SETUP
-#line 228 "program_lexer.l"
+#line 268 "program_lexer.l"
 { return_opcode(require_ARB_fp, SAMPLE_OP, TXP, ZERO_ONE); }
 	YY_BREAK
 case 77:
 YY_RULE_SETUP
-#line 230 "program_lexer.l"
+#line 270 "program_lexer.l"
 { return_opcode(             1, BIN_OP, XPD, OFF); }
 	YY_BREAK
 case 78:
 YY_RULE_SETUP
-#line 231 "program_lexer.l"
+#line 271 "program_lexer.l"
 { return_opcode(require_ARB_fp, BIN_OP, XPD, ZERO_ONE); }
 	YY_BREAK
 case 79:
 YY_RULE_SETUP
-#line 233 "program_lexer.l"
+#line 273 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_vp, VERTEX); }
 	YY_BREAK
 case 80:
 YY_RULE_SETUP
-#line 234 "program_lexer.l"
+#line 274 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp, FRAGMENT); }
 	YY_BREAK
 case 81:
 YY_RULE_SETUP
-#line 235 "program_lexer.l"
+#line 275 "program_lexer.l"
 { return PROGRAM; }
 	YY_BREAK
 case 82:
 YY_RULE_SETUP
-#line 236 "program_lexer.l"
+#line 276 "program_lexer.l"
 { return STATE; }
 	YY_BREAK
 case 83:
 YY_RULE_SETUP
-#line 237 "program_lexer.l"
+#line 277 "program_lexer.l"
 { return RESULT; }
 	YY_BREAK
 case 84:
 YY_RULE_SETUP
-#line 239 "program_lexer.l"
+#line 279 "program_lexer.l"
 { return AMBIENT; }
 	YY_BREAK
 case 85:
 YY_RULE_SETUP
-#line 240 "program_lexer.l"
+#line 280 "program_lexer.l"
 { return ATTENUATION; }
 	YY_BREAK
 case 86:
 YY_RULE_SETUP
-#line 241 "program_lexer.l"
+#line 281 "program_lexer.l"
 { return BACK; }
 	YY_BREAK
 case 87:
 YY_RULE_SETUP
-#line 242 "program_lexer.l"
+#line 282 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, CLIP); }
 	YY_BREAK
 case 88:
 YY_RULE_SETUP
-#line 243 "program_lexer.l"
+#line 283 "program_lexer.l"
 { return COLOR; }
 	YY_BREAK
 case 89:
 YY_RULE_SETUP
-#line 244 "program_lexer.l"
+#line 284 "program_lexer.l"
 { return_token_or_DOT(require_ARB_fp, DEPTH); }
 	YY_BREAK
 case 90:
 YY_RULE_SETUP
-#line 245 "program_lexer.l"
+#line 285 "program_lexer.l"
 { return DIFFUSE; }
 	YY_BREAK
 case 91:
 YY_RULE_SETUP
-#line 246 "program_lexer.l"
+#line 286 "program_lexer.l"
 { return DIRECTION; }
 	YY_BREAK
 case 92:
 YY_RULE_SETUP
-#line 247 "program_lexer.l"
+#line 287 "program_lexer.l"
 { return EMISSION; }
 	YY_BREAK
 case 93:
 YY_RULE_SETUP
-#line 248 "program_lexer.l"
+#line 288 "program_lexer.l"
 { return ENV; }
 	YY_BREAK
 case 94:
 YY_RULE_SETUP
-#line 249 "program_lexer.l"
+#line 289 "program_lexer.l"
 { return EYE; }
 	YY_BREAK
 case 95:
 YY_RULE_SETUP
-#line 250 "program_lexer.l"
+#line 290 "program_lexer.l"
 { return FOGCOORD; }
 	YY_BREAK
 case 96:
 YY_RULE_SETUP
-#line 251 "program_lexer.l"
+#line 291 "program_lexer.l"
 { return FOG; }
 	YY_BREAK
 case 97:
 YY_RULE_SETUP
-#line 252 "program_lexer.l"
+#line 292 "program_lexer.l"
 { return FRONT; }
 	YY_BREAK
 case 98:
 YY_RULE_SETUP
-#line 253 "program_lexer.l"
+#line 293 "program_lexer.l"
 { return HALF; }
 	YY_BREAK
 case 99:
 YY_RULE_SETUP
-#line 254 "program_lexer.l"
+#line 294 "program_lexer.l"
 { return INVERSE; }
 	YY_BREAK
 case 100:
 YY_RULE_SETUP
-#line 255 "program_lexer.l"
+#line 295 "program_lexer.l"
 { return INVTRANS; }
 	YY_BREAK
 case 101:
 YY_RULE_SETUP
-#line 256 "program_lexer.l"
+#line 296 "program_lexer.l"
 { return LIGHT; }
 	YY_BREAK
 case 102:
 YY_RULE_SETUP
-#line 257 "program_lexer.l"
+#line 297 "program_lexer.l"
 { return LIGHTMODEL; }
 	YY_BREAK
 case 103:
 YY_RULE_SETUP
-#line 258 "program_lexer.l"
+#line 298 "program_lexer.l"
 { return LIGHTPROD; }
 	YY_BREAK
 case 104:
 YY_RULE_SETUP
-#line 259 "program_lexer.l"
+#line 299 "program_lexer.l"
 { return LOCAL; }
 	YY_BREAK
 case 105:
 YY_RULE_SETUP
-#line 260 "program_lexer.l"
+#line 300 "program_lexer.l"
 { return MATERIAL; }
 	YY_BREAK
 case 106:
 YY_RULE_SETUP
-#line 261 "program_lexer.l"
+#line 301 "program_lexer.l"
 { return MAT_PROGRAM; }
 	YY_BREAK
 case 107:
 YY_RULE_SETUP
-#line 262 "program_lexer.l"
+#line 302 "program_lexer.l"
 { return MATRIX; }
 	YY_BREAK
 case 108:
 YY_RULE_SETUP
-#line 263 "program_lexer.l"
+#line 303 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, MATRIXINDEX); }
 	YY_BREAK
 case 109:
 YY_RULE_SETUP
-#line 264 "program_lexer.l"
+#line 304 "program_lexer.l"
 { return MODELVIEW; }
 	YY_BREAK
 case 110:
 YY_RULE_SETUP
-#line 265 "program_lexer.l"
+#line 305 "program_lexer.l"
 { return MVP; }
 	YY_BREAK
 case 111:
 YY_RULE_SETUP
-#line 266 "program_lexer.l"
+#line 306 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, NORMAL); }
 	YY_BREAK
 case 112:
 YY_RULE_SETUP
-#line 267 "program_lexer.l"
+#line 307 "program_lexer.l"
 { return OBJECT; }
 	YY_BREAK
 case 113:
 YY_RULE_SETUP
-#line 268 "program_lexer.l"
+#line 308 "program_lexer.l"
 { return PALETTE; }
 	YY_BREAK
 case 114:
 YY_RULE_SETUP
-#line 269 "program_lexer.l"
+#line 309 "program_lexer.l"
 { return PARAMS; }
 	YY_BREAK
 case 115:
 YY_RULE_SETUP
-#line 270 "program_lexer.l"
+#line 310 "program_lexer.l"
 { return PLANE; }
 	YY_BREAK
 case 116:
 YY_RULE_SETUP
-#line 271 "program_lexer.l"
+#line 311 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, POINT_TOK); }
 	YY_BREAK
 case 117:
 YY_RULE_SETUP
-#line 272 "program_lexer.l"
+#line 312 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, POINTSIZE); }
 	YY_BREAK
 case 118:
 YY_RULE_SETUP
-#line 273 "program_lexer.l"
+#line 313 "program_lexer.l"
 { return POSITION; }
 	YY_BREAK
 case 119:
 YY_RULE_SETUP
-#line 274 "program_lexer.l"
+#line 314 "program_lexer.l"
 { return PRIMARY; }
 	YY_BREAK
 case 120:
 YY_RULE_SETUP
-#line 275 "program_lexer.l"
+#line 315 "program_lexer.l"
 { return PROJECTION; }
 	YY_BREAK
 case 121:
 YY_RULE_SETUP
-#line 276 "program_lexer.l"
+#line 316 "program_lexer.l"
 { return_token_or_DOT(require_ARB_fp, RANGE); }
 	YY_BREAK
 case 122:
 YY_RULE_SETUP
-#line 277 "program_lexer.l"
+#line 317 "program_lexer.l"
 { return ROW; }
 	YY_BREAK
 case 123:
 YY_RULE_SETUP
-#line 278 "program_lexer.l"
+#line 318 "program_lexer.l"
 { return SCENECOLOR; }
 	YY_BREAK
 case 124:
 YY_RULE_SETUP
-#line 279 "program_lexer.l"
+#line 319 "program_lexer.l"
 { return SECONDARY; }
 	YY_BREAK
 case 125:
 YY_RULE_SETUP
-#line 280 "program_lexer.l"
+#line 320 "program_lexer.l"
 { return SHININESS; }
 	YY_BREAK
 case 126:
 YY_RULE_SETUP
-#line 281 "program_lexer.l"
+#line 321 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, SIZE_TOK); }
 	YY_BREAK
 case 127:
 YY_RULE_SETUP
-#line 282 "program_lexer.l"
+#line 322 "program_lexer.l"
 { return SPECULAR; }
 	YY_BREAK
 case 128:
 YY_RULE_SETUP
-#line 283 "program_lexer.l"
+#line 323 "program_lexer.l"
 { return SPOT; }
 	YY_BREAK
 case 129:
 YY_RULE_SETUP
-#line 284 "program_lexer.l"
+#line 324 "program_lexer.l"
 { return TEXCOORD; }
 	YY_BREAK
 case 130:
 YY_RULE_SETUP
-#line 285 "program_lexer.l"
+#line 325 "program_lexer.l"
 { return_token_or_DOT(require_ARB_fp, TEXENV); }
 	YY_BREAK
 case 131:
 YY_RULE_SETUP
-#line 286 "program_lexer.l"
+#line 326 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, TEXGEN); }
 	YY_BREAK
 case 132:
 YY_RULE_SETUP
-#line 287 "program_lexer.l"
+#line 327 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, TEXGEN_Q); }
 	YY_BREAK
 case 133:
 YY_RULE_SETUP
-#line 288 "program_lexer.l"
+#line 328 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, TEXGEN_S); }
 	YY_BREAK
 case 134:
 YY_RULE_SETUP
-#line 289 "program_lexer.l"
+#line 329 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, TEXGEN_T); }
 	YY_BREAK
 case 135:
 YY_RULE_SETUP
-#line 290 "program_lexer.l"
+#line 330 "program_lexer.l"
 { return TEXTURE; }
 	YY_BREAK
 case 136:
 YY_RULE_SETUP
-#line 291 "program_lexer.l"
+#line 331 "program_lexer.l"
 { return TRANSPOSE; }
 	YY_BREAK
 case 137:
 YY_RULE_SETUP
-#line 292 "program_lexer.l"
+#line 332 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, VTXATTRIB); }
 	YY_BREAK
 case 138:
 YY_RULE_SETUP
-#line 293 "program_lexer.l"
+#line 333 "program_lexer.l"
 { return_token_or_DOT(require_ARB_vp, WEIGHT); }
 	YY_BREAK
 case 139:
 YY_RULE_SETUP
-#line 295 "program_lexer.l"
+#line 335 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp, TEXTURE_UNIT); }
 	YY_BREAK
 case 140:
 YY_RULE_SETUP
-#line 296 "program_lexer.l"
+#line 336 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp, TEX_1D); }
 	YY_BREAK
 case 141:
 YY_RULE_SETUP
-#line 297 "program_lexer.l"
+#line 337 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp, TEX_2D); }
 	YY_BREAK
 case 142:
 YY_RULE_SETUP
-#line 298 "program_lexer.l"
+#line 338 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp, TEX_3D); }
 	YY_BREAK
 case 143:
 YY_RULE_SETUP
-#line 299 "program_lexer.l"
+#line 339 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp, TEX_CUBE); }
 	YY_BREAK
 case 144:
 YY_RULE_SETUP
-#line 300 "program_lexer.l"
+#line 340 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp && require_rect, TEX_RECT); }
 	YY_BREAK
 case 145:
 YY_RULE_SETUP
-#line 301 "program_lexer.l"
+#line 341 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp && require_shadow, TEX_SHADOW1D); }
 	YY_BREAK
 case 146:
 YY_RULE_SETUP
-#line 302 "program_lexer.l"
+#line 342 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp && require_shadow, TEX_SHADOW2D); }
 	YY_BREAK
 case 147:
 YY_RULE_SETUP
-#line 303 "program_lexer.l"
+#line 343 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp && require_shadow && require_rect, TEX_SHADOWRECT); }
 	YY_BREAK
 case 148:
 YY_RULE_SETUP
-#line 304 "program_lexer.l"
+#line 344 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp && require_texarray, TEX_ARRAY1D); }
 	YY_BREAK
 case 149:
 YY_RULE_SETUP
-#line 305 "program_lexer.l"
+#line 345 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp && require_texarray, TEX_ARRAY2D); }
 	YY_BREAK
 case 150:
 YY_RULE_SETUP
-#line 306 "program_lexer.l"
+#line 346 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp && require_shadow && require_texarray, TEX_ARRAYSHADOW1D); }
 	YY_BREAK
 case 151:
 YY_RULE_SETUP
-#line 307 "program_lexer.l"
+#line 347 "program_lexer.l"
 { return_token_or_IDENTIFIER(require_ARB_fp && require_shadow && require_texarray, TEX_ARRAYSHADOW2D); }
 	YY_BREAK
 case 152:
 YY_RULE_SETUP
-#line 309 "program_lexer.l"
+#line 349 "program_lexer.l"
 {
-   yylval->string = strdup(yytext);
+   yylval->string = return_string(yyextra, yytext);
    return IDENTIFIER;
 }
 	YY_BREAK
 case 153:
 YY_RULE_SETUP
-#line 314 "program_lexer.l"
+#line 354 "program_lexer.l"
 { return DOT_DOT; }
 	YY_BREAK
 case 154:
 YY_RULE_SETUP
-#line 316 "program_lexer.l"
+#line 356 "program_lexer.l"
 {
    yylval->integer = strtol(yytext, NULL, 10);
    return INTEGER;
@@ -2115,9 +2169,9 @@ YY_RULE_SETUP
 	YY_BREAK
 case 155:
 YY_RULE_SETUP
-#line 320 "program_lexer.l"
+#line 360 "program_lexer.l"
 {
-   yylval->real = strtod(yytext, NULL);
+   yylval->real = _mesa_strtod(yytext, NULL);
    return REAL;
 }
 	YY_BREAK
@@ -2127,31 +2181,31 @@ case 156:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 324 "program_lexer.l"
+#line 364 "program_lexer.l"
 {
-   yylval->real = strtod(yytext, NULL);
+   yylval->real = _mesa_strtod(yytext, NULL);
    return REAL;
 }
 	YY_BREAK
 case 157:
 YY_RULE_SETUP
-#line 328 "program_lexer.l"
+#line 368 "program_lexer.l"
 {
-   yylval->real = strtod(yytext, NULL);
+   yylval->real = _mesa_strtod(yytext, NULL);
    return REAL;
 }
 	YY_BREAK
 case 158:
 YY_RULE_SETUP
-#line 332 "program_lexer.l"
+#line 372 "program_lexer.l"
 {
-   yylval->real = strtod(yytext, NULL);
+   yylval->real = _mesa_strtod(yytext, NULL);
    return REAL;
 }
 	YY_BREAK
 case 159:
 YY_RULE_SETUP
-#line 337 "program_lexer.l"
+#line 377 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_NOOP;
    yylval->swiz_mask.mask = WRITEMASK_XYZW;
@@ -2160,7 +2214,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 160:
 YY_RULE_SETUP
-#line 343 "program_lexer.l"
+#line 383 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_XY
@@ -2170,7 +2224,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 161:
 YY_RULE_SETUP
-#line 349 "program_lexer.l"
+#line 389 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_XZW;
@@ -2179,7 +2233,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 162:
 YY_RULE_SETUP
-#line 354 "program_lexer.l"
+#line 394 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_YZW;
@@ -2188,7 +2242,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 163:
 YY_RULE_SETUP
-#line 360 "program_lexer.l"
+#line 400 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_X
@@ -2198,7 +2252,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 164:
 YY_RULE_SETUP
-#line 366 "program_lexer.l"
+#line 406 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_Y
@@ -2208,7 +2262,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 165:
 YY_RULE_SETUP
-#line 372 "program_lexer.l"
+#line 412 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_ZW;
@@ -2217,7 +2271,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 166:
 YY_RULE_SETUP
-#line 378 "program_lexer.l"
+#line 418 "program_lexer.l"
 {
    const unsigned s = swiz_from_char(yytext[1]);
    yylval->swiz_mask.swizzle = MAKE_SWIZZLE4(s, s, s, s);
@@ -2227,7 +2281,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 167:
 YY_RULE_SETUP
-#line 385 "program_lexer.l"
+#line 425 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = MAKE_SWIZZLE4(swiz_from_char(yytext[1]),
 					    swiz_from_char(yytext[2]),
@@ -2239,7 +2293,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 168:
 YY_RULE_SETUP
-#line 394 "program_lexer.l"
+#line 434 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_NOOP;
    yylval->swiz_mask.mask = WRITEMASK_XYZW;
@@ -2248,7 +2302,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 169:
 YY_RULE_SETUP
-#line 400 "program_lexer.l"
+#line 440 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_XY
@@ -2258,7 +2312,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 170:
 YY_RULE_SETUP
-#line 406 "program_lexer.l"
+#line 446 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_XZW;
@@ -2267,7 +2321,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 171:
 YY_RULE_SETUP
-#line 411 "program_lexer.l"
+#line 451 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_YZW;
@@ -2276,7 +2330,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 172:
 YY_RULE_SETUP
-#line 417 "program_lexer.l"
+#line 457 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_X
@@ -2286,7 +2340,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 173:
 YY_RULE_SETUP
-#line 423 "program_lexer.l"
+#line 463 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_Y
@@ -2296,7 +2350,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 174:
 YY_RULE_SETUP
-#line 429 "program_lexer.l"
+#line 469 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = SWIZZLE_INVAL;
    yylval->swiz_mask.mask = WRITEMASK_ZW;
@@ -2305,7 +2359,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 175:
 YY_RULE_SETUP
-#line 435 "program_lexer.l"
+#line 475 "program_lexer.l"
 {
    const unsigned s = swiz_from_char(yytext[1]);
    yylval->swiz_mask.swizzle = MAKE_SWIZZLE4(s, s, s, s);
@@ -2315,7 +2369,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 176:
 YY_RULE_SETUP
-#line 443 "program_lexer.l"
+#line 483 "program_lexer.l"
 {
    if (require_ARB_vp) {
       return TEXGEN_R;
@@ -2329,7 +2383,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 177:
 YY_RULE_SETUP
-#line 454 "program_lexer.l"
+#line 494 "program_lexer.l"
 {
    yylval->swiz_mask.swizzle = MAKE_SWIZZLE4(swiz_from_char(yytext[1]),
 					    swiz_from_char(yytext[2]),
@@ -2341,13 +2395,13 @@ YY_RULE_SETUP
 	YY_BREAK
 case 178:
 YY_RULE_SETUP
-#line 463 "program_lexer.l"
+#line 503 "program_lexer.l"
 { return DOT; }
 	YY_BREAK
 case 179:
 /* rule 179 can match eol */
 YY_RULE_SETUP
-#line 465 "program_lexer.l"
+#line 505 "program_lexer.l"
 {
    yylloc->first_line++;
    yylloc->first_column = 1;
@@ -2358,7 +2412,7 @@ YY_RULE_SETUP
 	YY_BREAK
 case 180:
 YY_RULE_SETUP
-#line 472 "program_lexer.l"
+#line 512 "program_lexer.l"
 /* eat whitespace */ ;
 	YY_BREAK
 case 181:
@@ -2366,20 +2420,20 @@ case 181:
 yyg->yy_c_buf_p = yy_cp -= 1;
 YY_DO_BEFORE_ACTION; /* set up yytext again */
 YY_RULE_SETUP
-#line 473 "program_lexer.l"
+#line 513 "program_lexer.l"
 /* eat comments */ ;
 	YY_BREAK
 case 182:
 YY_RULE_SETUP
-#line 474 "program_lexer.l"
+#line 514 "program_lexer.l"
 { return yytext[0]; }
 	YY_BREAK
 case 183:
 YY_RULE_SETUP
-#line 475 "program_lexer.l"
+#line 515 "program_lexer.l"
 ECHO;
 	YY_BREAK
-#line 2383 "lex.yy.c"
+#line 2437 "lex.yy.c"
 case YY_STATE_EOF(INITIAL):
 	yyterminate();
 
@@ -3147,8 +3201,8 @@ YY_BUFFER_STATE yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
 
 /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
  * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  */
@@ -3554,7 +3608,7 @@ void yyfree (void * ptr , yyscan_t yyscanner)
 
 #define YYTABLES_NAME "yytables"
 
-#line 475 "program_lexer.l"
+#line 515 "program_lexer.l"
 
 
 
diff --git a/src/mesa/shader/prog_execute.c b/src/mesa/shader/prog_execute.c
index 69b81e7..192d39a 100644
--- a/src/mesa/shader/prog_execute.c
+++ b/src/mesa/shader/prog_execute.c
@@ -939,7 +939,7 @@ _mesa_execute_program(GLcontext * ctx,
 	    /* The fast LOG2 macro doesn't meet the precision requirements.
 	     */
             if (a[0] == 0.0F) {
-               val = 0.0F;
+               val = -FLT_MAX;
             }
             else {
                val = log(a[0]) * 1.442695F;
diff --git a/src/mesa/shader/prog_optimize.c b/src/mesa/shader/prog_optimize.c
index be90310..9d93748 100644
--- a/src/mesa/shader/prog_optimize.c
+++ b/src/mesa/shader/prog_optimize.c
@@ -217,6 +217,7 @@ _mesa_remove_dead_code(struct gl_program *prog)
             if (inst->SrcReg[j].RelAddr) {
                if (dbg)
                   _mesa_printf("abort remove dead code (indirect temp)\n");
+               _mesa_free(removeInst);
                return;
             }
 
@@ -232,6 +233,7 @@ _mesa_remove_dead_code(struct gl_program *prog)
          if (inst->DstReg.RelAddr) {
             if (dbg)
                _mesa_printf("abort remove dead code (indirect temp)\n");
+            _mesa_free(removeInst);
             return;
          }
 
@@ -422,6 +424,8 @@ _mesa_remove_extra_moves(struct gl_program *prog)
    /* now remove the instructions which aren't needed */
    rem = remove_instructions(prog, removeInst);
 
+   _mesa_free(removeInst);
+
    if (dbg) {
       _mesa_printf("Optimize: End remove extra moves.  %u instructions removed\n", rem);
       /*_mesa_print_program(prog);*/
diff --git a/src/mesa/shader/prog_parameter.h b/src/mesa/shader/prog_parameter.h
index d1fcf47..699cb0c 100644
--- a/src/mesa/shader/prog_parameter.h
+++ b/src/mesa/shader/prog_parameter.h
@@ -56,7 +56,13 @@ struct gl_program_parameter
    const char *Name;        /**< Null-terminated string */
    gl_register_file Type;   /**< PROGRAM_NAMED_PARAM, CONSTANT or STATE_VAR */
    GLenum DataType;         /**< GL_FLOAT, GL_FLOAT_VEC2, etc */
-   GLuint Size;             /**< Number of components (1..4) */
+   /**
+    * Number of components (1..4), or more.
+    * If the number of components is greater than 4,
+    * this parameter is part of a larger uniform like a GLSL matrix or array.
+    * The next program parameter's Size will be Size-4 of this parameter.
+    */
+   GLuint Size;
    GLboolean Used;          /**< Helper flag for GLSL uniform tracking */
    GLboolean Initialized;   /**< Has the ParameterValue[] been set? */
    GLbitfield Flags;        /**< Bitmask of PROG_PARAM_*_BIT */
diff --git a/src/mesa/shader/program_lexer.l b/src/mesa/shader/program_lexer.l
index d240217..6c4fad3 100644
--- a/src/mesa/shader/program_lexer.l
+++ b/src/mesa/shader/program_lexer.l
@@ -22,6 +22,7 @@
  * DEALINGS IN THE SOFTWARE.
  */
 #include "main/glheader.h"
+#include "main/imports.h"
 #include "prog_instruction.h"
 #include "prog_statevars.h"
 
@@ -39,7 +40,7 @@
       if (condition) {					\
 	 return token;					\
       } else {						\
-	 yylval->string = strdup(yytext);		\
+	 yylval->string = return_string(yyextra, yytext);	\
 	 return IDENTIFIER;				\
       }							\
    } while (0)
@@ -62,7 +63,7 @@
 	 yylval->temp_inst.SaturateMode = SATURATE_ ## sat; \
 	 return token;					\
       } else {						\
-	 yylval->string = strdup(yytext);		\
+	 yylval->string = return_string(yyextra, yytext);		\
 	 return IDENTIFIER;				\
       }							\
    } while (0)
@@ -70,6 +71,45 @@
 #define SWIZZLE_INVAL  MAKE_SWIZZLE4(SWIZZLE_NIL, SWIZZLE_NIL, \
 				     SWIZZLE_NIL, SWIZZLE_NIL)
 
+/**
+ * Send a string to the parser using asm_parser_state::string_dumpster
+ *
+ * Sends a string to the parser using asm_parser_state::string_dumpster as a
+ * temporary storage buffer.  Data previously stored in
+ * asm_parser_state::string_dumpster will be lost.  If
+ * asm_parser_state::string_dumpster is not large enough to hold the new
+ * string, the buffer size will be increased.  The buffer size is \b never
+ * decreased.
+ *
+ * \param state   Assembler parser state tracking
+ * \param str     String to be passed to the parser
+ *
+ * \return
+ * A pointer to asm_parser_state::string_dumpster on success or \c NULL on
+ * failure.  Currently the only failure case is \c ENOMEM.
+ */
+static char *
+return_string(struct asm_parser_state *state, const char *str)
+{
+   const size_t len = strlen(str);
+
+   if (len >= state->dumpster_size) {
+      char *const dumpster = _mesa_realloc(state->string_dumpster,
+					   state->dumpster_size,
+					   len + 1);
+      if (dumpster == NULL) {
+	 return NULL;
+      }
+
+      state->string_dumpster = dumpster;
+      state->dumpster_size = len + 1;
+   }
+
+   memcpy(state->string_dumpster, str, len + 1);
+   return state->string_dumpster;
+}
+
+
 static unsigned
 mask_from_char(char c)
 {
@@ -307,7 +347,7 @@ ARRAYSHADOW1D             { return_token_or_IDENTIFIER(require_ARB_fp && require
 ARRAYSHADOW2D             { return_token_or_IDENTIFIER(require_ARB_fp && require_shadow && require_texarray, TEX_ARRAYSHADOW2D); }
 
 [_a-zA-Z$][_a-zA-Z0-9$]*  {
-   yylval->string = strdup(yytext);
+   yylval->string = return_string(yyextra, yytext);
    return IDENTIFIER;
 }
 
@@ -318,19 +358,19 @@ ARRAYSHADOW2D             { return_token_or_IDENTIFIER(require_ARB_fp && require
    return INTEGER;
 }
 {num}?{frac}{exp}?        {
-   yylval->real = strtod(yytext, NULL);
+   yylval->real = _mesa_strtod(yytext, NULL);
    return REAL;
 }
 {num}"."/[^.]             {
-   yylval->real = strtod(yytext, NULL);
+   yylval->real = _mesa_strtod(yytext, NULL);
    return REAL;
 }
 {num}{exp}                {
-   yylval->real = strtod(yytext, NULL);
+   yylval->real = _mesa_strtod(yytext, NULL);
    return REAL;
 }
 {num}"."{exp}             {
-   yylval->real = strtod(yytext, NULL);
+   yylval->real = _mesa_strtod(yytext, NULL);
    return REAL;
 }
 
diff --git a/src/mesa/shader/program_parse.tab.c b/src/mesa/shader/program_parse.tab.c
index 9f2d4de..261b605 100644
--- a/src/mesa/shader/program_parse.tab.c
+++ b/src/mesa/shader/program_parse.tab.c
@@ -3109,7 +3109,7 @@ yyreduce:
 /* Line 1455 of yacc.c  */
 #line 1041 "program_parse.y"
     {
-	   if (((yyvsp[(1) - (1)].integer) < 1) || ((unsigned) (yyvsp[(1) - (1)].integer) >= state->limits->MaxParameters)) {
+	   if (((yyvsp[(1) - (1)].integer) < 1) || ((unsigned) (yyvsp[(1) - (1)].integer) > state->limits->MaxParameters)) {
 	      yyerror(& (yylsp[(1) - (1)]), state, "invalid parameter array size");
 	      YYERROR;
 	   } else {
@@ -4565,7 +4565,7 @@ yyreduce:
 		      "undefined variable binding in ALIAS statement");
 	      YYERROR;
 	   } else {
-	      _mesa_symbol_table_add_symbol(state->st, 0, (yyvsp[(2) - (4)].string), target);
+	      _mesa_symbol_table_add_symbol(state->st, 0, strdup((yyvsp[(2) - (4)].string)), target);
 	   }
 	;}
     break;
@@ -4896,10 +4896,14 @@ declare_variable(struct asm_parser_state *state, char *name, enum asm_type t,
    if (exist != NULL) {
       yyerror(locp, state, "redeclared identifier");
    } else {
-      s = calloc(1, sizeof(struct asm_symbol));
-      s->name = name;
+      const size_t name_len = strlen(name);
+
+      s = calloc(1, sizeof(struct asm_symbol) + name_len + 1);
+      s->name = (char *)(s + 1);
       s->type = t;
 
+      memcpy((char *) s->name, name, name_len + 1);
+
       switch (t) {
       case at_temp:
 	 if (state->prog->NumTemporaries >= state->limits->MaxTemps) {
@@ -5147,6 +5151,11 @@ _mesa_parse_arb_program(GLcontext *ctx, GLenum target, const GLubyte *str,
    _mesa_memcpy (strz, str, len);
    strz[len] = '\0';
 
+   if (state->prog->String != NULL) {
+      _mesa_free(state->prog->String);
+      state->prog->String = NULL;
+   }
+
    state->prog->String = strz;
 
    state->st = _mesa_symbol_table_ctor();
@@ -5236,7 +5245,6 @@ error:
    for (sym = state->sym; sym != NULL; sym = temp) {
       temp = sym->next;
 
-      _mesa_free((void *) sym->name);
       _mesa_free(sym);
    }
    state->sym = NULL;
@@ -5244,6 +5252,11 @@ error:
    _mesa_symbol_table_dtor(state->st);
    state->st = NULL;
 
+   if (state->string_dumpster != NULL) {
+      _mesa_free(state->string_dumpster);
+      state->dumpster_size = 0;
+   }
+
    return result;
 }
 
diff --git a/src/mesa/shader/program_parse.y b/src/mesa/shader/program_parse.y
index 06c1915..a23625d 100644
--- a/src/mesa/shader/program_parse.y
+++ b/src/mesa/shader/program_parse.y
@@ -1039,7 +1039,7 @@ optArraySize:
 	}
 	| INTEGER
         {
-	   if (($1 < 1) || ((unsigned) $1 >= state->limits->MaxParameters)) {
+	   if (($1 < 1) || ((unsigned) $1 > state->limits->MaxParameters)) {
 	      yyerror(& @1, state, "invalid parameter array size");
 	      YYERROR;
 	   } else {
@@ -1919,7 +1919,7 @@ ALIAS_statement: ALIAS IDENTIFIER '=' IDENTIFIER
 		      "undefined variable binding in ALIAS statement");
 	      YYERROR;
 	   } else {
-	      _mesa_symbol_table_add_symbol(state->st, 0, $2, target);
+	      _mesa_symbol_table_add_symbol(state->st, 0, strdup($2), target);
 	   }
 	}
 	;
@@ -2027,10 +2027,14 @@ declare_variable(struct asm_parser_state *state, char *name, enum asm_type t,
    if (exist != NULL) {
       yyerror(locp, state, "redeclared identifier");
    } else {
-      s = calloc(1, sizeof(struct asm_symbol));
-      s->name = name;
+      const size_t name_len = strlen(name);
+
+      s = calloc(1, sizeof(struct asm_symbol) + name_len + 1);
+      s->name = (char *)(s + 1);
       s->type = t;
 
+      memcpy((char *) s->name, name, name_len + 1);
+
       switch (t) {
       case at_temp:
 	 if (state->prog->NumTemporaries >= state->limits->MaxTemps) {
@@ -2278,6 +2282,11 @@ _mesa_parse_arb_program(GLcontext *ctx, GLenum target, const GLubyte *str,
    _mesa_memcpy (strz, str, len);
    strz[len] = '\0';
 
+   if (state->prog->String != NULL) {
+      _mesa_free(state->prog->String);
+      state->prog->String = NULL;
+   }
+
    state->prog->String = strz;
 
    state->st = _mesa_symbol_table_ctor();
@@ -2367,7 +2376,6 @@ error:
    for (sym = state->sym; sym != NULL; sym = temp) {
       temp = sym->next;
 
-      _mesa_free((void *) sym->name);
       _mesa_free(sym);
    }
    state->sym = NULL;
@@ -2375,5 +2383,10 @@ error:
    _mesa_symbol_table_dtor(state->st);
    state->st = NULL;
 
+   if (state->string_dumpster != NULL) {
+      _mesa_free(state->string_dumpster);
+      state->dumpster_size = 0;
+   }
+
    return result;
 }
diff --git a/src/mesa/shader/program_parser.h b/src/mesa/shader/program_parser.h
index fa47d84..8d8b4d8 100644
--- a/src/mesa/shader/program_parser.h
+++ b/src/mesa/shader/program_parser.h
@@ -38,6 +38,13 @@ enum asm_type {
    at_output,
 };
 
+/**
+ * \note
+ * Objects of this type are allocated as the object plus the name of the
+ * symbol.  That is, malloc(sizeof(struct asm_symbol) + strlen(name) + 1).
+ * Alternately, asm_symbol::name could be moved to the bottom of the structure
+ * and declared as 'char name[0];'.
+ */
 struct asm_symbol {
    struct asm_symbol *next;    /**< List linkage for freeing. */
    const char *name;
@@ -158,6 +165,15 @@ struct asm_parser_state {
 
 
    /**
+    * Buffer to hold strings transfered from the lexer to the parser
+    */
+   /*@{*/
+   char *string_dumpster;      /**< String data transfered. */
+   size_t dumpster_size;       /**< Total size, in bytes, of the buffer. */
+   /*@}*/
+
+
+   /**
     * Selected limits copied from gl_constants
     *
     * These are limits from the GL context, but various bits in the program
diff --git a/src/mesa/shader/shader_api.c b/src/mesa/shader/shader_api.c
index 178b7d0..b282d7a 100644
--- a/src/mesa/shader/shader_api.c
+++ b/src/mesa/shader/shader_api.c
@@ -1702,8 +1702,8 @@ set_program_uniform(GLcontext *ctx, struct gl_program *program,
          /* we'll ignore extra data below */
       }
       else {
-         /* non-array: count must be one */
-         if (count != 1) {
+         /* non-array: count must be at most one; count == 0 is handled by the loop below */
+         if (count > 1) {
             _mesa_error(ctx, GL_INVALID_OPERATION,
                         "glUniform(uniform is not an array)");
             return;
@@ -1880,20 +1880,27 @@ set_program_uniform_matrix(GLcontext *ctx, struct gl_program *program,
                            GLboolean transpose, const GLfloat *values)
 {
    GLuint mat, row, col;
-   GLuint dst = index + offset, src = 0;
+   GLuint src = 0;
+   const struct gl_program_parameter * param = &program->Parameters->Parameters[index];
+   const GLint slots = (param->Size + 3) / 4;
+   const GLint typeSize = sizeof_glsl_type(param->DataType);
    GLint nr, nc;
 
    /* check that the number of rows, columns is correct */
-   get_matrix_dims(program->Parameters->Parameters[index].DataType, &nr, &nc);
+   get_matrix_dims(param->DataType, &nr, &nc);
    if (rows != nr || cols != nc) {
       _mesa_error(ctx, GL_INVALID_OPERATION,
                   "glUniformMatrix(matrix size mismatch)");
       return;
    }
 
-   if (index + offset > program->Parameters->Size) {
-      /* out of bounds! */
-      return;
+   if (param->Size <= typeSize) {
+      /* non-array: count must be at most one; count == 0 is handled by the loop below */
+      if (count > 1) {
+         _mesa_error(ctx, GL_INVALID_OPERATION,
+                     "glUniformMatrix(uniform is not an array)");
+         return;
+      }
    }
 
    /*
@@ -1907,7 +1914,12 @@ set_program_uniform_matrix(GLcontext *ctx, struct gl_program *program,
 
       /* each matrix: */
       for (col = 0; col < cols; col++) {
-         GLfloat *v = program->Parameters->ParameterValues[dst];
+         GLfloat *v;
+         if (offset >= slots) {
+            /* Ignore writes beyond the end of (the used part of) an array */
+            return;
+         }
+         v = program->Parameters->ParameterValues[index + offset];
          for (row = 0; row < rows; row++) {
             if (transpose) {
                v[row] = values[src + row * cols + col];
@@ -1916,7 +1928,8 @@ set_program_uniform_matrix(GLcontext *ctx, struct gl_program *program,
                v[row] = values[src + col * rows + row];
             }
          }
-         dst++;
+
+         offset++;
       }
 
       src += rows * cols;  /* next matrix */
diff --git a/src/mesa/shader/slang/library/slang_common_builtin.gc b/src/mesa/shader/slang/library/slang_common_builtin.gc
index 9764fc2..56de47e 100644
--- a/src/mesa/shader/slang/library/slang_common_builtin.gc
+++ b/src/mesa/shader/slang/library/slang_common_builtin.gc
@@ -602,42 +602,50 @@ vec4 exp2(const vec4 a)
 
 float sqrt(const float x)
 {
+   const float nx = -x;
    float r;
    __asm float_rsq r, x;
-   __asm float_rcp __retVal, r;
-}
-
-vec2 sqrt(const vec2 v)
-{
-   float r;
-   __asm float_rsq r, v.x;
-   __asm float_rcp __retVal.x, r;
-   __asm float_rsq r, v.y;
-   __asm float_rcp __retVal.y, r;
-}
-
-vec3 sqrt(const vec3 v)
-{
-   float r;
-   __asm float_rsq r, v.x;
-   __asm float_rcp __retVal.x, r;
-   __asm float_rsq r, v.y;
-   __asm float_rcp __retVal.y, r;
-   __asm float_rsq r, v.z;
-   __asm float_rcp __retVal.z, r;
-}
-
-vec4 sqrt(const vec4 v)
-{
-   float r;
-   __asm float_rsq r, v.x;
-   __asm float_rcp __retVal.x, r;
-   __asm float_rsq r, v.y;
-   __asm float_rcp __retVal.y, r;
-   __asm float_rsq r, v.z;
-   __asm float_rcp __retVal.z, r;
-   __asm float_rsq r, v.w;
-   __asm float_rcp __retVal.w, r;
+   __asm float_rcp r, r;
+   __asm vec4_cmp __retVal, nx, r, 0.0;
+}
+
+vec2 sqrt(const vec2 x)
+{
+   const vec2 nx = -x, zero = vec2(0.0);
+   vec2 r;
+   __asm float_rsq r.x, x.x;
+   __asm float_rsq r.y, x.y;
+   __asm float_rcp r.x, r.x;
+   __asm float_rcp r.y, r.y;
+   __asm vec4_cmp __retVal, nx, r, zero;
+}
+
+vec3 sqrt(const vec3 x)
+{
+   const vec3 nx = -x, zero = vec3(0.0);
+   vec3 r;
+   __asm float_rsq r.x, x.x;
+   __asm float_rsq r.y, x.y;
+   __asm float_rsq r.z, x.z;
+   __asm float_rcp r.x, r.x;
+   __asm float_rcp r.y, r.y;
+   __asm float_rcp r.z, r.z;
+   __asm vec4_cmp __retVal, nx, r, zero;
+}
+
+vec4 sqrt(const vec4 x)
+{
+   const vec4 nx = -x, zero = vec4(0.0);
+   vec4 r;
+   __asm float_rsq r.x, x.x;
+   __asm float_rsq r.y, x.y;
+   __asm float_rsq r.z, x.z;
+   __asm float_rsq r.w, x.w;
+   __asm float_rcp r.x, r.x;
+   __asm float_rcp r.y, r.y;
+   __asm float_rcp r.z, r.z;
+   __asm float_rcp r.w, r.w;
+   __asm vec4_cmp __retVal, nx, r, zero;
 }
 
 
diff --git a/src/mesa/shader/slang/library/slang_common_builtin_gc.h b/src/mesa/shader/slang/library/slang_common_builtin_gc.h
index 78a7b83..3c3666e 100644
--- a/src/mesa/shader/slang/library/slang_common_builtin_gc.h
+++ b/src/mesa/shader/slang/library/slang_common_builtin_gc.h
@@ -307,55 +307,63 @@
 0,0,18,97,0,59,121,0,0,0,4,102,108,111,97,116,95,101,120,112,50,0,18,95,95,114,101,116,86,97,108,0,
 59,122,0,0,18,97,0,59,122,0,0,0,4,102,108,111,97,116,95,101,120,112,50,0,18,95,95,114,101,116,86,
 97,108,0,59,119,0,0,18,97,0,59,119,0,0,0,0,1,90,95,0,0,9,0,0,115,113,114,116,0,1,1,0,0,9,0,120,0,0,
-0,1,3,2,90,95,0,0,9,0,1,114,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,114,0,0,18,120,0,0,0,4,
-102,108,111,97,116,95,114,99,112,0,18,95,95,114,101,116,86,97,108,0,0,18,114,0,0,0,0,1,90,95,0,0,
-10,0,0,115,113,114,116,0,1,1,0,0,10,0,118,0,0,0,1,3,2,90,95,0,0,9,0,1,114,0,0,0,4,102,108,111,97,
-116,95,114,115,113,0,18,114,0,0,18,118,0,59,120,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,95,
-95,114,101,116,86,97,108,0,59,120,0,0,18,114,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,114,0,
-0,18,118,0,59,121,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,95,95,114,101,116,86,97,108,0,59,
-121,0,0,18,114,0,0,0,0,1,90,95,0,0,11,0,0,115,113,114,116,0,1,1,0,0,11,0,118,0,0,0,1,3,2,90,95,0,0,
-9,0,1,114,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,114,0,0,18,118,0,59,120,0,0,0,4,102,108,
-111,97,116,95,114,99,112,0,18,95,95,114,101,116,86,97,108,0,59,120,0,0,18,114,0,0,0,4,102,108,111,
-97,116,95,114,115,113,0,18,114,0,0,18,118,0,59,121,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,
-95,95,114,101,116,86,97,108,0,59,121,0,0,18,114,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,114,
-0,0,18,118,0,59,122,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,95,95,114,101,116,86,97,108,0,59,
-122,0,0,18,114,0,0,0,0,1,90,95,0,0,12,0,0,115,113,114,116,0,1,1,0,0,12,0,118,0,0,0,1,3,2,90,95,0,0,
-9,0,1,114,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,114,0,0,18,118,0,59,120,0,0,0,4,102,108,
-111,97,116,95,114,99,112,0,18,95,95,114,101,116,86,97,108,0,59,120,0,0,18,114,0,0,0,4,102,108,111,
-97,116,95,114,115,113,0,18,114,0,0,18,118,0,59,121,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,
-95,95,114,101,116,86,97,108,0,59,121,0,0,18,114,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,114,
-0,0,18,118,0,59,122,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,95,95,114,101,116,86,97,108,0,59,
-122,0,0,18,114,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,114,0,0,18,118,0,59,119,0,0,0,4,102,
-108,111,97,116,95,114,99,112,0,18,95,95,114,101,116,86,97,108,0,59,119,0,0,18,114,0,0,0,0,1,90,95,
-0,0,9,0,0,105,110,118,101,114,115,101,115,113,114,116,0,1,1,0,0,9,0,120,0,0,0,1,4,102,108,111,97,
-116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,120,0,0,18,120,0,0,0,0,1,90,95,0,0,10,0,0,
-105,110,118,101,114,115,101,115,113,114,116,0,1,1,0,0,10,0,118,0,0,0,1,4,102,108,111,97,116,95,114,
-115,113,0,18,95,95,114,101,116,86,97,108,0,59,120,0,0,18,118,0,59,120,0,0,0,4,102,108,111,97,116,
-95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,121,0,0,18,118,0,59,121,0,0,0,0,1,90,95,0,0,
-11,0,0,105,110,118,101,114,115,101,115,113,114,116,0,1,1,0,0,11,0,118,0,0,0,1,4,102,108,111,97,116,
-95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,120,0,0,18,118,0,59,120,0,0,0,4,102,108,111,
-97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,121,0,0,18,118,0,59,121,0,0,0,4,102,
-108,111,97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,122,0,0,18,118,0,59,122,0,0,0,
-0,1,90,95,0,0,12,0,0,105,110,118,101,114,115,101,115,113,114,116,0,1,1,0,0,12,0,118,0,0,0,1,4,102,
-108,111,97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,120,0,0,18,118,0,59,120,0,0,0,
-4,102,108,111,97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,121,0,0,18,118,0,59,121,
-0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,122,0,0,18,118,0,
-59,122,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,119,0,0,18,
-118,0,59,119,0,0,0,0,1,90,95,0,0,9,0,0,110,111,114,109,97,108,105,122,101,0,1,1,0,0,9,0,120,0,0,0,
-1,9,18,95,95,114,101,116,86,97,108,0,17,49,0,48,0,0,20,0,0,1,90,95,0,0,10,0,0,110,111,114,109,97,
-108,105,122,101,0,1,1,0,0,10,0,118,0,0,0,1,3,2,90,95,1,0,9,0,1,115,0,2,58,105,110,118,101,114,115,
-101,115,113,114,116,0,0,58,100,111,116,0,0,18,118,0,0,18,118,0,0,0,0,0,0,0,4,118,101,99,52,95,109,
-117,108,116,105,112,108,121,0,18,95,95,114,101,116,86,97,108,0,59,120,121,0,0,18,118,0,0,18,115,0,
-0,0,0,1,90,95,0,0,11,0,0,110,111,114,109,97,108,105,122,101,0,1,1,0,0,11,0,118,0,0,0,1,3,2,90,95,0,
-0,9,0,1,116,109,112,0,0,0,4,118,101,99,51,95,100,111,116,0,18,116,109,112,0,0,18,118,0,0,18,118,0,
-0,0,4,102,108,111,97,116,95,114,115,113,0,18,116,109,112,0,0,18,116,109,112,0,0,0,4,118,101,99,52,
-95,109,117,108,116,105,112,108,121,0,18,95,95,114,101,116,86,97,108,0,59,120,121,122,0,0,18,118,0,
-0,18,116,109,112,0,0,0,0,1,90,95,0,0,12,0,0,110,111,114,109,97,108,105,122,101,0,1,1,0,0,12,0,118,
-0,0,0,1,3,2,90,95,0,0,9,0,1,116,109,112,0,0,0,4,118,101,99,52,95,100,111,116,0,18,116,109,112,0,0,
-18,118,0,0,18,118,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,116,109,112,0,0,18,116,109,112,0,
-0,0,4,118,101,99,52,95,109,117,108,116,105,112,108,121,0,18,95,95,114,101,116,86,97,108,0,59,120,
-121,122,0,0,18,118,0,0,18,116,109,112,0,0,0,0,1,90,95,0,0,9,0,0,97,98,115,0,1,1,0,0,9,0,97,0,0,0,1,
-4,118,101,99,52,95,97,98,115,0,18,95,95,114,101,116,86,97,108,0,0,18,97,0,0,0,0,1,90,95,0,0,10,0,0,
+0,1,3,2,90,95,1,0,9,0,1,110,120,0,2,18,120,0,54,0,0,3,2,90,95,0,0,9,0,1,114,0,0,0,4,102,108,111,97,
+116,95,114,115,113,0,18,114,0,0,18,120,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,114,0,0,18,
+114,0,0,0,4,118,101,99,52,95,99,109,112,0,18,95,95,114,101,116,86,97,108,0,0,18,110,120,0,0,18,114,
+0,0,17,48,0,48,0,0,0,0,0,1,90,95,0,0,10,0,0,115,113,114,116,0,1,1,0,0,10,0,120,0,0,0,1,3,2,90,95,1,
+0,10,0,1,110,120,0,2,18,120,0,54,0,1,1,122,101,114,111,0,2,58,118,101,99,50,0,0,17,48,0,48,0,0,0,0,
+0,0,3,2,90,95,0,0,10,0,1,114,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,114,0,59,120,0,0,18,
+120,0,59,120,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,114,0,59,121,0,0,18,120,0,59,121,0,0,0,
+4,102,108,111,97,116,95,114,99,112,0,18,114,0,59,120,0,0,18,114,0,59,120,0,0,0,4,102,108,111,97,
+116,95,114,99,112,0,18,114,0,59,121,0,0,18,114,0,59,121,0,0,0,4,118,101,99,52,95,99,109,112,0,18,
+95,95,114,101,116,86,97,108,0,0,18,110,120,0,0,18,114,0,0,18,122,101,114,111,0,0,0,0,1,90,95,0,0,
+11,0,0,115,113,114,116,0,1,1,0,0,11,0,120,0,0,0,1,3,2,90,95,1,0,11,0,1,110,120,0,2,18,120,0,54,0,1,
+1,122,101,114,111,0,2,58,118,101,99,51,0,0,17,48,0,48,0,0,0,0,0,0,3,2,90,95,0,0,11,0,1,114,0,0,0,4,
+102,108,111,97,116,95,114,115,113,0,18,114,0,59,120,0,0,18,120,0,59,120,0,0,0,4,102,108,111,97,116,
+95,114,115,113,0,18,114,0,59,121,0,0,18,120,0,59,121,0,0,0,4,102,108,111,97,116,95,114,115,113,0,
+18,114,0,59,122,0,0,18,120,0,59,122,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,114,0,59,120,0,0,
+18,114,0,59,120,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,114,0,59,121,0,0,18,114,0,59,121,0,0,
+0,4,102,108,111,97,116,95,114,99,112,0,18,114,0,59,122,0,0,18,114,0,59,122,0,0,0,4,118,101,99,52,
+95,99,109,112,0,18,95,95,114,101,116,86,97,108,0,0,18,110,120,0,0,18,114,0,0,18,122,101,114,111,0,
+0,0,0,1,90,95,0,0,12,0,0,115,113,114,116,0,1,1,0,0,12,0,120,0,0,0,1,3,2,90,95,1,0,12,0,1,110,120,0,
+2,18,120,0,54,0,1,1,122,101,114,111,0,2,58,118,101,99,52,0,0,17,48,0,48,0,0,0,0,0,0,3,2,90,95,0,0,
+12,0,1,114,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,114,0,59,120,0,0,18,120,0,59,120,0,0,0,4,
+102,108,111,97,116,95,114,115,113,0,18,114,0,59,121,0,0,18,120,0,59,121,0,0,0,4,102,108,111,97,116,
+95,114,115,113,0,18,114,0,59,122,0,0,18,120,0,59,122,0,0,0,4,102,108,111,97,116,95,114,115,113,0,
+18,114,0,59,119,0,0,18,120,0,59,119,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,114,0,59,120,0,0,
+18,114,0,59,120,0,0,0,4,102,108,111,97,116,95,114,99,112,0,18,114,0,59,121,0,0,18,114,0,59,121,0,0,
+0,4,102,108,111,97,116,95,114,99,112,0,18,114,0,59,122,0,0,18,114,0,59,122,0,0,0,4,102,108,111,97,
+116,95,114,99,112,0,18,114,0,59,119,0,0,18,114,0,59,119,0,0,0,4,118,101,99,52,95,99,109,112,0,18,
+95,95,114,101,116,86,97,108,0,0,18,110,120,0,0,18,114,0,0,18,122,101,114,111,0,0,0,0,1,90,95,0,0,9,
+0,0,105,110,118,101,114,115,101,115,113,114,116,0,1,1,0,0,9,0,120,0,0,0,1,4,102,108,111,97,116,95,
+114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,120,0,0,18,120,0,0,0,0,1,90,95,0,0,10,0,0,105,
+110,118,101,114,115,101,115,113,114,116,0,1,1,0,0,10,0,118,0,0,0,1,4,102,108,111,97,116,95,114,115,
+113,0,18,95,95,114,101,116,86,97,108,0,59,120,0,0,18,118,0,59,120,0,0,0,4,102,108,111,97,116,95,
+114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,121,0,0,18,118,0,59,121,0,0,0,0,1,90,95,0,0,11,0,
+0,105,110,118,101,114,115,101,115,113,114,116,0,1,1,0,0,11,0,118,0,0,0,1,4,102,108,111,97,116,95,
+114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,120,0,0,18,118,0,59,120,0,0,0,4,102,108,111,97,
+116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,121,0,0,18,118,0,59,121,0,0,0,4,102,108,
+111,97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,122,0,0,18,118,0,59,122,0,0,0,0,1,
+90,95,0,0,12,0,0,105,110,118,101,114,115,101,115,113,114,116,0,1,1,0,0,12,0,118,0,0,0,1,4,102,108,
+111,97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,120,0,0,18,118,0,59,120,0,0,0,4,
+102,108,111,97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,121,0,0,18,118,0,59,121,0,
+0,0,4,102,108,111,97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,122,0,0,18,118,0,59,
+122,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,95,95,114,101,116,86,97,108,0,59,119,0,0,18,118,
+0,59,119,0,0,0,0,1,90,95,0,0,9,0,0,110,111,114,109,97,108,105,122,101,0,1,1,0,0,9,0,120,0,0,0,1,9,
+18,95,95,114,101,116,86,97,108,0,17,49,0,48,0,0,20,0,0,1,90,95,0,0,10,0,0,110,111,114,109,97,108,
+105,122,101,0,1,1,0,0,10,0,118,0,0,0,1,3,2,90,95,1,0,9,0,1,115,0,2,58,105,110,118,101,114,115,101,
+115,113,114,116,0,0,58,100,111,116,0,0,18,118,0,0,18,118,0,0,0,0,0,0,0,4,118,101,99,52,95,109,117,
+108,116,105,112,108,121,0,18,95,95,114,101,116,86,97,108,0,59,120,121,0,0,18,118,0,0,18,115,0,0,0,
+0,1,90,95,0,0,11,0,0,110,111,114,109,97,108,105,122,101,0,1,1,0,0,11,0,118,0,0,0,1,3,2,90,95,0,0,9,
+0,1,116,109,112,0,0,0,4,118,101,99,51,95,100,111,116,0,18,116,109,112,0,0,18,118,0,0,18,118,0,0,0,
+4,102,108,111,97,116,95,114,115,113,0,18,116,109,112,0,0,18,116,109,112,0,0,0,4,118,101,99,52,95,
+109,117,108,116,105,112,108,121,0,18,95,95,114,101,116,86,97,108,0,59,120,121,122,0,0,18,118,0,0,
+18,116,109,112,0,0,0,0,1,90,95,0,0,12,0,0,110,111,114,109,97,108,105,122,101,0,1,1,0,0,12,0,118,0,
+0,0,1,3,2,90,95,0,0,9,0,1,116,109,112,0,0,0,4,118,101,99,52,95,100,111,116,0,18,116,109,112,0,0,18,
+118,0,0,18,118,0,0,0,4,102,108,111,97,116,95,114,115,113,0,18,116,109,112,0,0,18,116,109,112,0,0,0,
+4,118,101,99,52,95,109,117,108,116,105,112,108,121,0,18,95,95,114,101,116,86,97,108,0,59,120,121,
+122,0,0,18,118,0,0,18,116,109,112,0,0,0,0,1,90,95,0,0,9,0,0,97,98,115,0,1,1,0,0,9,0,97,0,0,0,1,4,
+118,101,99,52,95,97,98,115,0,18,95,95,114,101,116,86,97,108,0,0,18,97,0,0,0,0,1,90,95,0,0,10,0,0,
 97,98,115,0,1,1,0,0,10,0,97,0,0,0,1,4,118,101,99,52,95,97,98,115,0,18,95,95,114,101,116,86,97,108,
 0,59,120,121,0,0,18,97,0,0,0,0,1,90,95,0,0,11,0,0,97,98,115,0,1,1,0,0,11,0,97,0,0,0,1,4,118,101,99,
 52,95,97,98,115,0,18,95,95,114,101,116,86,97,108,0,59,120,121,122,0,0,18,97,0,0,0,0,1,90,95,0,0,12,
diff --git a/src/mesa/shader/slang/slang_codegen.c b/src/mesa/shader/slang/slang_codegen.c
index 703af9f..344dfdc 100644
--- a/src/mesa/shader/slang/slang_codegen.c
+++ b/src/mesa/shader/slang/slang_codegen.c
@@ -422,6 +422,7 @@ static slang_asm_info AsmInfo[] = {
    { "vec4_lrp", IR_LRP, 1, 3 },
    { "vec4_min", IR_MIN, 1, 2 },
    { "vec4_max", IR_MAX, 1, 2 },
+   { "vec4_cmp", IR_CMP, 1, 3 },
    { "vec4_clamp", IR_CLAMP, 1, 3 },
    { "vec4_seq", IR_SEQUAL, 1, 2 },
    { "vec4_sne", IR_SNEQUAL, 1, 2 },
diff --git a/src/mesa/shader/slang/slang_emit.c b/src/mesa/shader/slang/slang_emit.c
index 3f455e0..3af301e 100644
--- a/src/mesa/shader/slang/slang_emit.c
+++ b/src/mesa/shader/slang/slang_emit.c
@@ -2287,6 +2287,7 @@ emit(slang_emit_info *emitInfo, slang_ir_node *n)
    case IR_POW:
    /* trinary operators */
    case IR_LRP:
+   case IR_CMP:
       return emit_arith(emitInfo, n);
 
    case IR_EQUAL:
diff --git a/src/mesa/shader/slang/slang_ir.c b/src/mesa/shader/slang/slang_ir.c
index 1c7f747..6260350 100644
--- a/src/mesa/shader/slang/slang_ir.c
+++ b/src/mesa/shader/slang/slang_ir.c
@@ -80,6 +80,7 @@ static const slang_ir_info IrInfo[] = {
    { IR_NOISE4, "IR_NOISE4", OPCODE_NOISE4, 1, 1 },
 
    /* other */
+   { IR_CMP, "IR_CMP", OPCODE_CMP, 4, 3 },  /* compare/select */
    { IR_SEQ, "IR_SEQ", OPCODE_NOP, 0, 0 },
    { IR_SCOPE, "IR_SCOPE", OPCODE_NOP, 0, 0 },
    { IR_LABEL, "IR_LABEL", OPCODE_NOP, 0, 0 },
diff --git a/src/mesa/shader/slang/slang_ir.h b/src/mesa/shader/slang/slang_ir.h
index e796693..166b4e8 100644
--- a/src/mesa/shader/slang/slang_ir.h
+++ b/src/mesa/shader/slang/slang_ir.h
@@ -91,6 +91,7 @@ typedef enum
    IR_CLAMP,
    IR_MIN,
    IR_MAX,
+   IR_CMP,     /* = (op0 < 0) ? op1 : op2 */
    IR_SEQUAL,  /* Set if args are equal (vector) */
    IR_SNEQUAL, /* Set if args are not equal (vector) */
    IR_SGE,     /* Set if greater or equal (vector) */
diff --git a/src/mesa/shader/slang/slang_link.c b/src/mesa/shader/slang/slang_link.c
index 8f2b40d..144c126 100644
--- a/src/mesa/shader/slang/slang_link.c
+++ b/src/mesa/shader/slang/slang_link.c
@@ -104,7 +104,7 @@ link_varying_vars(GLcontext *ctx,
    GLuint *map, i, firstVarying, newFile;
    GLbitfield *inOutFlags;
 
-   map = (GLuint *) malloc(prog->Varying->NumParameters * sizeof(GLuint));
+   map = (GLuint *) _mesa_malloc(prog->Varying->NumParameters * sizeof(GLuint));
    if (!map)
       return GL_FALSE;
 
@@ -135,6 +135,7 @@ link_varying_vars(GLcontext *ctx,
             &shProg->Varying->Parameters[j];
          if (var->Size != v->Size) {
             link_error(shProg, "mismatched varying variable types");
+            _mesa_free(map);
             return GL_FALSE;
          }
          if (!bits_agree(var->Flags, v->Flags, PROG_PARAM_BIT_CENTROID)) {
@@ -142,6 +143,7 @@ link_varying_vars(GLcontext *ctx,
             _mesa_snprintf(msg, sizeof(msg),
                            "centroid modifier mismatch for '%s'", var->Name);
             link_error(shProg, msg);
+            _mesa_free(map);
             return GL_FALSE;
          }
          if (!bits_agree(var->Flags, v->Flags, PROG_PARAM_BIT_INVARIANT)) {
@@ -149,6 +151,7 @@ link_varying_vars(GLcontext *ctx,
             _mesa_snprintf(msg, sizeof(msg),
                            "invariant modifier mismatch for '%s'", var->Name);
             link_error(shProg, msg);
+            _mesa_free(map);
             return GL_FALSE;
          }
       }
@@ -160,6 +163,7 @@ link_varying_vars(GLcontext *ctx,
 
       if (shProg->Varying->NumParameters > ctx->Const.MaxVarying) {
          link_error(shProg, "Too many varying variables");
+         _mesa_free(map);
          return GL_FALSE;
       }
 
@@ -199,7 +203,7 @@ link_varying_vars(GLcontext *ctx,
       }
    }
 
-   free(map);
+   _mesa_free(map);
 
    /* these will get recomputed before linking is completed */
    prog->InputsRead = 0x0;
@@ -670,6 +674,7 @@ get_main_shader(GLcontext *ctx,
           !shader->Main ||
           shader->UnresolvedRefs) {
          link_error(shProg, "Unresolved symbols");
+         _mesa_free_shader(ctx, shader);
          return NULL;
       }
    }
diff --git a/src/mesa/shader/symbol_table.c b/src/mesa/shader/symbol_table.c
index 7a9aa7b..1f6d9b8 100644
--- a/src/mesa/shader/symbol_table.c
+++ b/src/mesa/shader/symbol_table.c
@@ -20,12 +20,8 @@
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  */
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <assert.h>
 
+#include "main/imports.h"
 #include "symbol_table.h"
 #include "hash_table.h"
 
@@ -73,6 +69,9 @@ struct symbol {
 /**
  */
 struct symbol_header {
+    /** Linkage in list of all headers in a given symbol table. */
+    struct symbol_header *next;
+
     /** Symbol name. */
     const char *name;
 
@@ -102,6 +101,9 @@ struct _mesa_symbol_table {
 
     /** Top of scope stack. */
     struct scope_level *current_scope;
+
+    /** List of all symbol headers in the table. */
+    struct symbol_header *hdr;
 };
 
 
@@ -301,6 +303,8 @@ _mesa_symbol_table_add_symbol(struct _mesa_symbol_table *table,
         hdr->name = name;
 
         hash_table_insert(table->ht, hdr, name);
+	hdr->next = table->hdr;
+	table->hdr = hdr;
     }
 
     check_symbol_table(table);
@@ -341,10 +345,18 @@ _mesa_symbol_table_ctor(void)
 void
 _mesa_symbol_table_dtor(struct _mesa_symbol_table *table)
 {
+   struct symbol_header *hdr;
+   struct symbol_header *next;
+
    while (table->current_scope != NULL) {
       _mesa_symbol_table_pop_scope(table);
    }
 
+   for (hdr = table->hdr; hdr != NULL; hdr = next) {
+       next = hdr->next;
+       _mesa_free(hdr);
+   }
+
    hash_table_dtor(table->ht);
    free(table);
 }
diff --git a/src/mesa/state_tracker/st_cb_drawpixels.c b/src/mesa/state_tracker/st_cb_drawpixels.c
index a9cafbf..2a227a7 100644
--- a/src/mesa/state_tracker/st_cb_drawpixels.c
+++ b/src/mesa/state_tracker/st_cb_drawpixels.c
@@ -598,15 +598,15 @@ draw_textured_quad(GLcontext *ctx, GLint x, GLint y, GLfloat z,
 
    /* viewport state: viewport matching window dims */
    {
-      const float width = (float) ctx->DrawBuffer->Width;
-      const float height = (float) ctx->DrawBuffer->Height;
+      const float w = (float) ctx->DrawBuffer->Width;
+      const float h = (float) ctx->DrawBuffer->Height;
       struct pipe_viewport_state vp;
-      vp.scale[0] =  0.5f * width;
-      vp.scale[1] = -0.5f * height;
+      vp.scale[0] =  0.5f * w;
+      vp.scale[1] = -0.5f * h;
       vp.scale[2] = 1.0f;
       vp.scale[3] = 1.0f;
-      vp.translate[0] = 0.5f * width;
-      vp.translate[1] = 0.5f * height;
+      vp.translate[0] = 0.5f * w;
+      vp.translate[1] = 0.5f * h;
       vp.translate[2] = 0.0f;
       vp.translate[3] = 0.0f;
       cso_set_viewport(cso, &vp);
@@ -661,6 +661,15 @@ draw_stencil_pixels(GLcontext *ctx, GLint x, GLint y,
    const GLboolean zoom = ctx->Pixel.ZoomX != 1.0 || ctx->Pixel.ZoomY != 1.0;
    GLint skipPixels;
    ubyte *stmap;
+   struct gl_pixelstore_attrib clippedUnpack = *unpack;
+
+   if (!zoom) {
+      if (!_mesa_clip_drawpixels(ctx, &x, &y, &width, &height,
+                                 &clippedUnpack)) {
+         /* totally clipped */
+         return;
+      }
+   }
 
    strb = st_renderbuffer(ctx->DrawBuffer->
                           Attachment[BUFFER_STENCIL].Renderbuffer);
@@ -681,7 +690,7 @@ draw_stencil_pixels(GLcontext *ctx, GLint x, GLint y,
 
    stmap = screen->transfer_map(screen, pt);
 
-   pixels = _mesa_map_pbo_source(ctx, unpack, pixels);
+   pixels = _mesa_map_pbo_source(ctx, &clippedUnpack, pixels);
    assert(pixels);
 
    /* if width > MAX_WIDTH, have to process image in chunks */
@@ -694,17 +703,18 @@ draw_stencil_pixels(GLcontext *ctx, GLint x, GLint y,
          GLubyte sValues[MAX_WIDTH];
          GLuint zValues[MAX_WIDTH];
          GLenum destType = GL_UNSIGNED_BYTE;
-         const GLvoid *source = _mesa_image_address2d(unpack, pixels,
+         const GLvoid *source = _mesa_image_address2d(&clippedUnpack, pixels,
                                                       width, height,
                                                       format, type,
                                                       row, skipPixels);
          _mesa_unpack_stencil_span(ctx, spanWidth, destType, sValues,
-                                   type, source, unpack,
+                                   type, source, &clippedUnpack,
                                    ctx->_ImageTransferState);
 
          if (format == GL_DEPTH_STENCIL) {
             _mesa_unpack_depth_span(ctx, spanWidth, GL_UNSIGNED_INT, zValues,
-                                    (1 << 24) - 1, type, source, unpack);
+                                    (1 << 24) - 1, type, source,
+                                    &clippedUnpack);
          }
 
          if (zoom) {
@@ -775,7 +785,7 @@ draw_stencil_pixels(GLcontext *ctx, GLint x, GLint y,
       skipPixels += spanWidth;
    }
 
-   _mesa_unmap_pbo_source(ctx, unpack);
+   _mesa_unmap_pbo_source(ctx, &clippedUnpack);
 
    /* unmap the stencil buffer */
    screen->transfer_unmap(screen, pt);
diff --git a/src/mesa/state_tracker/st_cb_fbo.c b/src/mesa/state_tracker/st_cb_fbo.c
index fe0a121..e8399de 100644
--- a/src/mesa/state_tracker/st_cb_fbo.c
+++ b/src/mesa/state_tracker/st_cb_fbo.c
@@ -165,12 +165,12 @@ st_renderbuffer_alloc_storage(GLcontext * ctx, struct gl_renderbuffer *rb,
                                                      strb->texture,
                                                      0, 0, 0,
                                                      surface_usage );
-
-      assert(strb->surface->texture);
-      assert(strb->surface->format);
-      assert(strb->surface->width == width);
-      assert(strb->surface->height == height);
-
+      if (strb->surface) {
+         assert(strb->surface->texture);
+         assert(strb->surface->format);
+         assert(strb->surface->width == width);
+         assert(strb->surface->height == height);
+      }
 
       return strb->surface != NULL;
    }
@@ -298,6 +298,7 @@ st_new_renderbuffer_fb(enum pipe_format format, int samples, boolean sw)
    default:
       _mesa_problem(NULL,
 		    "Unexpected format in st_new_renderbuffer_fb");
+      _mesa_free(strb);
       return NULL;
    }
 
diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index b13e377..f45b3e6 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -1313,7 +1313,8 @@ fallback_copy_texsubimage(GLcontext *ctx, GLenum target, GLint level,
 					       srcX, srcY,
 					       width, height);
 
-   if (baseFormat == GL_DEPTH_COMPONENT &&
+   if ((baseFormat == GL_DEPTH_COMPONENT ||
+        baseFormat == GL_DEPTH_STENCIL) &&
        pf_is_depth_and_stencil(stImage->pt->format))
       transfer_usage = PIPE_TRANSFER_READ_WRITE;
    else
@@ -1326,7 +1327,7 @@ fallback_copy_texsubimage(GLcontext *ctx, GLenum target, GLint level,
                                   destX, destY, width, height);
 
    if (baseFormat == GL_DEPTH_COMPONENT ||
-       baseFormat == GL_DEPTH24_STENCIL8) {
+       baseFormat == GL_DEPTH_STENCIL) {
       const GLboolean scaleOrBias = (ctx->Pixel.DepthScale != 1.0F ||
                                      ctx->Pixel.DepthBias != 0.0F);
       GLint row, yStep;
@@ -1453,7 +1454,7 @@ st_copy_texsubimage(GLcontext *ctx,
    struct gl_texture_image *texImage =
       _mesa_select_tex_image(ctx, texObj, target, level);
    struct st_texture_image *stImage = st_texture_image(texImage);
-   const GLenum texBaseFormat = texImage->InternalFormat;
+   const GLenum texBaseFormat = texImage->_BaseFormat;
    struct gl_framebuffer *fb = ctx->ReadBuffer;
    struct st_renderbuffer *strb;
    struct pipe_context *pipe = ctx->st->pipe;
@@ -1474,12 +1475,9 @@ st_copy_texsubimage(GLcontext *ctx,
 
    /* determine if copying depth or color data */
    if (texBaseFormat == GL_DEPTH_COMPONENT ||
-       texBaseFormat == GL_DEPTH24_STENCIL8) {
+       texBaseFormat == GL_DEPTH_STENCIL) {
       strb = st_renderbuffer(fb->_DepthBuffer);
    }
-   else if (texBaseFormat == GL_DEPTH_STENCIL_EXT) {
-      strb = st_renderbuffer(fb->_StencilBuffer);
-   }
    else {
       /* texBaseFormat == GL_RGB, GL_RGBA, GL_ALPHA, etc */
       strb = st_renderbuffer(fb->_ColorReadBuffer);
@@ -1562,6 +1560,8 @@ st_copy_texsubimage(GLcontext *ctx,
          use_fallback = GL_FALSE;
       }
       else if (format_writemask &&
+               texBaseFormat != GL_DEPTH_COMPONENT &&
+               texBaseFormat != GL_DEPTH_STENCIL &&
                screen->is_format_supported(screen, src_format,
                                            PIPE_TEXTURE_2D, 
                                            PIPE_TEXTURE_USAGE_SAMPLER,
@@ -1775,7 +1775,11 @@ st_finalize_texture(GLcontext *ctx,
        * incomplete.  In that case, we'll have set stObj->lastLevel before
        * we get here.
        */
-      stObj->lastLevel = stObj->base._MaxLevel - stObj->base.BaseLevel;
+      if (stObj->base.MinFilter == GL_LINEAR ||
+          stObj->base.MinFilter == GL_NEAREST)
+         stObj->lastLevel = stObj->base.BaseLevel;
+      else
+         stObj->lastLevel = stObj->base._MaxLevel - stObj->base.BaseLevel;
    }
 
    firstImage = st_texture_image(stObj->base.Image[0][stObj->base.BaseLevel]);
diff --git a/src/mesa/state_tracker/st_framebuffer.c b/src/mesa/state_tracker/st_framebuffer.c
index 5c0d335..a5d1ae3 100644
--- a/src/mesa/state_tracker/st_framebuffer.c
+++ b/src/mesa/state_tracker/st_framebuffer.c
@@ -52,6 +52,7 @@ st_create_framebuffer( const __GLcontextModes *visual,
    struct st_framebuffer *stfb = ST_CALLOC_STRUCT(st_framebuffer);
    if (stfb) {
       int samples = st_get_msaa();
+      int i;
 
       if (visual->sampleBuffers)
          samples = visual->samples;
@@ -119,6 +120,12 @@ st_create_framebuffer( const __GLcontextModes *visual,
          _mesa_add_renderbuffer(&stfb->Base, BUFFER_ACCUM, accumRb);
       }
 
+      for (i = 0; i < visual->numAuxBuffers; i++) {
+         struct gl_renderbuffer *aux
+            = st_new_renderbuffer_fb(colorFormat, 0, FALSE);
+         _mesa_add_renderbuffer(&stfb->Base, BUFFER_AUX0 + i, aux);
+      }
+
       stfb->Base.Initialized = GL_TRUE;
       stfb->InitWidth = width;
       stfb->InitHeight = height;
diff --git a/src/mesa/swrast/s_depth.c b/src/mesa/swrast/s_depth.c
index 26e23f0..7086cae 100644
--- a/src/mesa/swrast/s_depth.c
+++ b/src/mesa/swrast/s_depth.c
@@ -1211,6 +1211,7 @@ _swrast_read_depth_span_float( GLcontext *ctx, struct gl_renderbuffer *rb,
    if (!rb) {
       /* really only doing this to prevent FP exceptions later */
       _mesa_bzero(depth, n * sizeof(GLfloat));
+      return;
    }
 
    ASSERT(rb->_BaseFormat == GL_DEPTH_COMPONENT);
@@ -1273,7 +1274,8 @@ _swrast_read_depth_span_uint( GLcontext *ctx, struct gl_renderbuffer *rb,
 {
    if (!rb) {
       /* really only doing this to prevent FP exceptions later */
-      _mesa_bzero(depth, n * sizeof(GLfloat));
+      _mesa_bzero(depth, n * sizeof(GLuint));
+      return;
    }
 
    ASSERT(rb->_BaseFormat == GL_DEPTH_COMPONENT);

