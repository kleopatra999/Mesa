diff --git a/Makefile b/Makefile
index b8069f9..b13ed33 100644
--- a/Makefile
+++ b/Makefile
@@ -347,23 +347,19 @@ GALLIUM_FILES = \
 
 DRI_FILES = \
 	$(DIRECTORY)/include/GL/internal/dri_interface.h		\
-	$(DIRECTORY)/include/GL/internal/glcore.h			\
 	$(DIRECTORY)/include/GL/internal/sarea.h			\
 	$(DIRECTORY)/src/glx/Makefile					\
-	$(DIRECTORY)/src/glx/Makefile					\
 	$(DIRECTORY)/src/glx/*.[ch]					\
 	$(DIRECTORY)/src/mesa/drivers/dri/Makefile			\
 	$(DIRECTORY)/src/mesa/drivers/dri/Makefile.template		\
 	$(DIRECTORY)/src/mesa/drivers/dri/dri.pc.in			\
-	$(DIRECTORY)/src/mesa/drivers/dri/common/xmlpool/*.[ch]		\
 	$(DIRECTORY)/src/mesa/drivers/dri/common/xmlpool/*.po		\
 	$(DIRECTORY)/src/mesa/drivers/dri/*/*.[chS]			\
 	$(DIRECTORY)/src/mesa/drivers/dri/*/*.cpp			\
 	$(DIRECTORY)/src/mesa/drivers/dri/*/*/*.[chS]			\
 	$(DIRECTORY)/src/mesa/drivers/dri/*/Makefile			\
 	$(DIRECTORY)/src/mesa/drivers/dri/*/*/Makefile			\
-	$(DIRECTORY)/src/mesa/drivers/dri/*/Doxyfile			\
-	$(DIRECTORY)/src/mesa/drivers/dri/*/server/*.[ch]
+	$(DIRECTORY)/src/mesa/drivers/dri/*/Doxyfile
 
 SGI_GLU_FILES = \
 	$(DIRECTORY)/src/glu/Makefile					\
diff --git a/docs/devinfo.html b/docs/devinfo.html
index df0e726..2d1c125 100644
--- a/docs/devinfo.html
+++ b/docs/devinfo.html
@@ -145,7 +145,7 @@ Make sure the values in src/mesa/main/version.h are correct.
 </p>
 
 <p>
-Update the docs/news.html file and docs/download.html files.
+Update docs/news.html.
 </p>
 
 <p>
@@ -208,10 +208,11 @@ sftp USERNAME,mesa3d@web.sourceforge.net
 
 <p>
 Make an announcement on the mailing lists:
-<em>m</em><em>e</em><em>s</em><em>a</em><em>3</em><em>d</em><em>-</em><em>d</em><em>e</em><em>v</em><em>@</em><em>l</em><em>i</em><em>s</em><em>t</em><em>s</em><em>.</em><em>s</em><em>f</em><em>.</em><em>n</em><em>e</em><em>t</em>,
-<em>m</em><em>e</em><em>s</em><em>a</em><em>3</em><em>d</em><em>-</em><em>u</em><em>s</em><em>e</em><em>r</em><em>s</em><em>@</em><em>l</em><em>i</em><em>s</em><em>t</em><em>s</em><em>.</em><em>s</em><em>f</em><em>.</em><em>n</em><em>e</em><em>t</em>
+
+<em>m</em><em>e</em><em>s</em><em>a</em><em>-</em><em>d</em><em>e</em><em>v</em><em>@</em><em>l</em><em>i</em><em>s</em><em>t</em><em>s</em><em>.</em><em>f</em><em>r</em><em>e</em><em>e</em><em>d</em><em>e</em><em>s</em><em>k</em><em>t</em><em>o</em><em>p</em><em>.</em><em>o</em><em>r</em><em>g</em>,
+<em>m</em><em>e</em><em>s</em><em>a</em><em>-</em><em>u</em><em>s</em><em>e</em><em>r</em><em>s</em><em>@</em><em>l</em><em>i</em><em>s</em><em>t</em><em>s</em><em>.</em><em>f</em><em>r</em><em>e</em><em>e</em><em>d</em><em>e</em><em>s</em><em>k</em><em>t</em><em>o</em><em>p</em><em>.</em><em>o</em><em>r</em><em>g</em>
 and
-<em>m</em><em>e</em><em>s</em><em>a</em><em>3</em><em>d</em><em>-</em><em>a</em><em>n</em><em>n</em><em>o</em><em>u</em><em>n</em><em>c</em><em>e</em><em>@</em><em>l</em><em>i</em><em>s</em><em>t</em><em>s</em><em>.</em><em>s</em><em>f</em><em>.</em><em>n</em><em>e</em><em>t</em>
+<em>m</em><em>e</em><em>s</em><em>a</em><em>-</em><em>a</em><em>n</em><em>n</em><em>o</em><em>u</em><em>n</em><em>c</em><em>e</em><em>@</em><em>l</em><em>i</em><em>s</em><em>t</em><em>s</em><em>.</em><em>f</em><em>r</em><em>e</em><em>e</em><em>d</em><em>e</em><em>s</em><em>k</em><em>t</em><em>o</em><em>p</em><em>.</em><em>o</em><em>r</em><em>g</em>
 </p>
 
 
diff --git a/docs/news.html b/docs/news.html
index b3fb8b5..72d38ee 100644
--- a/docs/news.html
+++ b/docs/news.html
@@ -11,10 +11,18 @@
 <H1>News</H1>
 
 
+<h2>October 4, 2010</h2>
+
+<p>
+<a href="relnotes-7.9.html">Mesa 7.9</a> (final) is released.  This is a new
+development release.
+</p>
+
+
 <h2>September 27, 2010</h2>
 
 <p>
-<a href="relnotes-7.9.0.html">Mesa 7.9.0-rc1</a> is released.  This is a
+<a href="relnotes-7.9.html">Mesa 7.9.0-rc1</a> is released.  This is a
 release candidate for the 7.9 development release.
 </p>
 
diff --git a/docs/relnotes-7.8.2.html b/docs/relnotes-7.8.2.html
index e1b0f2d..1393b2e 100644
--- a/docs/relnotes-7.8.2.html
+++ b/docs/relnotes-7.8.2.html
@@ -26,7 +26,15 @@ for DRI hardware acceleration.
 
 <h2>MD5 checksums</h2>
 <pre>
-tbd
+c89b63d253605ed40e8ac370d25a833c  MesaLib-7.8.2.tar.gz
+6be2d343a0089bfd395ce02aaf8adb57  MesaLib-7.8.2.tar.bz2
+a04ad3b06ac5ff3969a003fa7bbf7d5b  MesaLib-7.8.2.zip
+7c213f92efeb471f0331670d5079d4c0  MesaDemos-7.8.2.tar.gz
+757d9e2e06f48b1a52848be9b0307ced  MesaDemos-7.8.2.tar.bz2
+8d0e5cfe68b8ebf90265d350ae2c48b1  MesaDemos-7.8.2.zip
+b74482e3f44f35ed395c4aada4fd8240  MesaGLUT-7.8.2.tar.gz
+a471807b65e49c325808ba4551be93ed  MesaGLUT-7.8.2.tar.bz2
+9f190268c42be582ef66e47365ee61e3  MesaGLUT-7.8.2.zip
 </pre>
 
 
@@ -44,10 +52,95 @@ tbd
 <ul>
 <li>Fixed Gallium glDrawPixels(GL_DEPTH_COMPONENT).
 <li>Fixed Gallium Cell driver to buildable, runable state
+<li>Fixed bad error checking for glFramebufferRenderbuffer(attachment=GL_DEPTH_STENCIL_ATTACHMENT).
+<li>Fixed incorrect Z coordinate handling in "meta" glDraw/CopyPixels.
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=23670">Bug
+    #23670</a>.</li>
+
+<li>Assorted i965 driver fixes.
+    Including but not limited to:
+  <ul>
+    <li>Fix scissoring when width or height is
+    0.  <a href="https://bugs.freedesktop.org/show_bug.cgi?id=27643">Bug
+    #27643</a>.
+    <li>Fix bit allocation for number of color regions for
+    ARB_draw_buffers.</li>
+    <li>Set the correct provoking vertex for clipped first-mode
+    trifans.  <a href="https://bugs.freedesktop.org/show_bug.cgi?id=24470">Bug
+    #24470</a>.</li>
+    <li>Use <code>R16G16B16A16_FLOAT</code> for 3-component half-float.</li>
+    <li>Fix assertion for surface tile offset usage on Ironlake.</li>
+    <li>Fix cube map layouts on Ironlake.</li>
+    <li>When an RB gets a new region, clear the old from the state
+    cache.  <a href="https://bugs.freedesktop.org/show_bug.cgi?id=24119">Bug
+    #24119</a>.</li>
+    <li>Reject shaders with uninlined function calls instead of hanging.</li>
+  </ul>
+</li>
+
+<li>Assorted i915 driver fixes.  Including but not limited to:
+  <ul>
+    <li>Fixed texture LOD clamping in i915 driver.
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=24846">Bug
+    #24846</a>.</li>
+    <li>Fix off-by-one for drawing rectangle.
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=27408">Bug
+    #27408</a>.</li>
+  </ul>
+</li>
+
+<li>Fixed hangs in etracer on 830 and 845
+    chipsets.  <a href="https://bugs.freedesktop.org/show_bug.cgi?id=26557">Bug
+    #26557</a>.</li>
+<li>Fixed tiling of small textures on all Intel drivers.</li>
+<li>Fixed crash in Savage driver when using <code>_mesa_CopyTexImage2D</code>.
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=27652">Bug
+    #27652</a>.</li>
+
+<li>Assorted GLX fixes.  Including but not limited to:
+  <ul>
+    <li>Fixed <code>__glXInitializeVisualConfigFromTags</code>'s handling of
+        unrecognized fbconfig tags.</li>
+    <li>Fixed regression with <code>GLX_USE_GL</code>.
+    <li>Fixed config chooser logic for 'mask' matching.</li>
+    <li>Report swap events correctly in direct rendered case (DRI2)</li>
+    <li>Fixed build with dri2proto which doesn't define
+        <code>X_DRI2SwapInterval</code>.</li>
+    <li>Get <code>GLX_SCREEN</code> first in <code>__glXQueryContextInfo</code>.
+        <a href="https://bugs.freedesktop.org/show_bug.cgi?id=14245">Bug
+	#14245</a>.</li>
+  </ul>
+</li>
+
+<li>Assorted GLSL fixes.  Including but not limited to:
+  <ul>
+    <li>Change variable declared assertion into conditional in GLSL
+        compiler.  <a href="https://bugs.freedesktop.org/show_bug.cgi?id=27921">Bug
+        #27921</a>.</li>
+    <li>Fix instruction indexing
+        bugs.  <a href="https://bugs.freedesktop.org/show_bug.cgi?id=27566">Bug
+        #27566</a>.</li>
+    <li>Updated uniform location / offset encoding to be more like
+        other implementations.</li>
+    <li>Don't overwrite a driver's shader infolog with generic failure
+        message.</li>
+  </ul>
+</li>
+
+<li>Fixed OSMesa build for 16 and 32-bit color channel depth.
+<li>Fixed OSMesa build with hidden symbol visibility. libOSMesa no longer links to libGL.
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=28305">Bug
+    #28305</a>.
+<li>Fixed handling of multiple render targets in fixed-function
+    texture envrionmnent programs.</li>
+<li>Fixed conversion errors in <code>signed_rgba8888[rev]</code> texel
+    fetch.</li>
+<li>Don't set srcLevel on <code>GL_TEXTURE_RECTANGLE_ARB</code> targets.</li>
+<li>Various build fixes for OpenBSD.</li>
+<li>Various build fixes for OS X.</li>
+<li>Various build fixes for GCC 3.3.</li>
 </ul>
 
 
-<h2>Changes</h2>
-<p>None.</p>
 </body>
 </html>
diff --git a/docs/relnotes-7.8.3.html b/docs/relnotes-7.8.3.html
new file mode 100644
index 0000000..1e9f433
--- /dev/null
+++ b/docs/relnotes-7.8.3.html
@@ -0,0 +1,89 @@
+<HTML>
+
+<TITLE>Mesa Release Notes</TITLE>
+
+<head><link rel="stylesheet" type="text/css" href="mesa.css"></head>
+
+<BODY>
+
+<body bgcolor="#eeeeee">
+
+<H1>Mesa 7.8.3 Release Notes / (date tbd)</H1>
+
+<p>
+Mesa 7.8.3 is a bug fix release which fixes bugs found since the 7.8.2 release.
+</p>
+<p>
+Mesa 7.8.3 implements the OpenGL 2.1 API, but the version reported by
+glGetString(GL_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 2.1.
+</p>
+<p>
+See the <a href="install.html">Compiling/Installing page</a> for prerequisites
+for DRI hardware acceleration.
+</p>
+
+
+<h2>MD5 checksums</h2>
+<pre>
+x  MesaLib-7.8.3.tar.gz
+x  MesaLib-7.8.3.tar.bz2
+x  MesaLib-7.8.3.zip
+x  MesaDemos-7.8.3.tar.gz
+x  MesaDemos-7.8.3.tar.bz2
+x  MesaDemos-7.8.3.zip
+x  MesaGLUT-7.8.3.tar.gz
+x  MesaGLUT-7.8.3.tar.bz2
+x  MesaGLUT-7.8.3.zip
+</pre>
+
+
+<h2>New features</h2>
+<p>None.</p>
+
+
+<h2>Changes</h2>
+<ul>
+<li>The radeon driver should use less memory when searching for a valid mip
+image.</li>
+</ul>
+
+
+<h2>Bug fixes</h2>
+<ul>
+<li>Fix unsupported FB with D24S8 (bug 
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=23670">29116</a>)</li>
+<li>Fix ReadPixels crash when reading depth/stencil from an FBO</li>
+<li>Fixed a bug rendering to 16-bit buffers using swrast.</li>
+<li>Fixed a state tracker/TGSI bug that caused crashes when using Windows'
+    memory debugging features.</li>
+<li>Fixed an issue rendering to 32-bit channels with swrast (bug
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=29487">29487</a>)</li>
+<li>GLSL: fix indirect <TT>gl_TextureMatrix</TT> addressing (bug
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=28967">28967</a>)</li>
+<li>GLSL: fix for bug
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=27216">27216</a></li>
+<li>GLSL: fix zw fragcoord entries in some cases (bug
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=29183">29183</a>)</li>
+<li>Fix texture env generation in some cases (bug
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=28169">28169</a>)</li>
+<li>osmesa: a fix for calling <TT>OSMesaMakeCurrent</TT> twice was applied (bug 
+    <a href="https://bugs.freedesktop.org/show_bug.cgi?id=10966">10966</a></li>
+<li>A bug was fixed which could cause Mesa to ignore the
+    <TT>MESA_EXTENSION_OVERRIDE</TT> environment variable.</li>
+<li>A bug related to specular highlights on backfaces was fixed.</li>
+<li>A radeon-specific issue with <TT>glCopyTex(Sub)Image</TT> was
+    corrected.</li>
+<li>radeon/wine: flush command stream in more cases, fixing wine d3d9
+    tests.</li>
+<li>r600: fix sin+cos normalization.</li>
+<li>r600: (properly) ignore <TT>GL_COORD_REPLACE</TT> when point sprites are
+    disabled.</li>
+<li>radeon: avoid flushing when the context is not current.</li>
+<li>r300c: a bug affecting unaligned BOs was fixed.</li>
+<li>r300c: a hardlock caused by ARB_half_float_vertex incorrectly advertised on some chipsets.</li>
+</ul>
+
+
+</body>
+</html>
diff --git a/docs/relnotes-7.9.html b/docs/relnotes-7.9.html
index b09fb1d..fe1fd5e 100644
--- a/docs/relnotes-7.9.html
+++ b/docs/relnotes-7.9.html
@@ -28,12 +28,12 @@ for DRI hardware acceleration.
 
 <h2>MD5 checksums</h2>
 <pre>
-f1f01a7baec255f13e9468fb4b05922a  MesaLib-7.9-rc1.tar.gz
-7ffbda3b7056c60b8f87e3082d853af1  MesaLib-7.9-rc1.tar.bz2
-9d4650df4e5b530178d6fde840f76664  MesaLib-7.9-rc1.zip
-a81c2e7a0c7832e67c768d6f209f2c8f  MesaGLUT-7.9-rc1.tar.gz
-b4c1c2f0b47a07be10fa2dd42e6a63d7  MesaGLUT-7.9-rc1.tar.bz2
-c9dd7419a19bcb24a1fe556ec2e78451  MesaGLUT-7.9-rc1.zip
+ed65ab425b25895c7f473d0a5e6e64f8  MesaLib-7.9.tar.gz
+82c740c49d572baa6da2b1a1eee90bca  MesaLib-7.9.tar.bz2
+cd2b6ecec759b0457475e94bbb38fedb  MesaLib-7.9.zip
+7b54af9fb9b1f6a1a65db2520f50848f  MesaGLUT-7.9.tar.gz
+20d07419d1929f833fdb36bced290ad5  MesaGLUT-7.9.tar.bz2
+62a7edecd7c92675cd6029b05217eb0a  MesaGLUT-7.9.zip
 </pre>
 
 
diff --git a/docs/relnotes.html b/docs/relnotes.html
index 47e7f80..4487af9 100644
--- a/docs/relnotes.html
+++ b/docs/relnotes.html
@@ -14,6 +14,7 @@ The release notes summarize what's new or changed in each Mesa release.
 
 <UL>
 <LI><A HREF="relnotes-7.9.html">7.9 release notes</A>
+<LI><A HREF="relnotes-7.8.3.html">7.8.3 release notes</A>
 <LI><A HREF="relnotes-7.8.2.html">7.8.2 release notes</A>
 <LI><A HREF="relnotes-7.8.1.html">7.8.1 release notes</A>
 <LI><A HREF="relnotes-7.8.html">7.8 release notes</A>
diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 9c4ff56..4a6506c 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -741,7 +741,7 @@ dri2_create_screen(_EGLDisplay *disp)
    if (dri2_dpy->dri2->base.version >= 2)
       api_mask = dri2_dpy->dri2->getAPIMask(dri2_dpy->dri_screen);
    else
-      api_mask = __DRI_API_OPENGL;
+      api_mask = 1 << __DRI_API_OPENGL;
 
    disp->ClientAPIsMask = 0;
    if (api_mask & (1 <<__DRI_API_OPENGL))
diff --git a/src/egl/main/eglcontext.c b/src/egl/main/eglcontext.c
index bc22913..763b1b3 100644
--- a/src/egl/main/eglcontext.c
+++ b/src/egl/main/eglcontext.c
@@ -272,10 +272,6 @@ _eglCheckMakeCurrent(_EGLContext *ctx, _EGLSurface *draw, _EGLSurface *read)
    if (!surfaceless && (draw == NULL || read == NULL))
       return _eglError(EGL_BAD_MATCH, "eglMakeCurrent");
 
-   /* context stealing from another thread is not allowed */
-   if (ctx->Binding && ctx->Binding != t)
-      return _eglError(EGL_BAD_ACCESS, "eglMakeCurrent");
-
    /*
     * The spec says
     *
@@ -283,16 +279,23 @@ _eglCheckMakeCurrent(_EGLContext *ctx, _EGLSurface *draw, _EGLSurface *read)
     * bound to contexts in another thread, an EGL_BAD_ACCESS error is
     * generated."
     *
-    * But it also says
+    * and
     *
     * "at most one context may be bound to a particular surface at a given
     * time"
-    *
-    * The latter is more restrictive so we can check only the latter case.
     */
-   if ((draw && draw->CurrentContext && draw->CurrentContext != ctx) ||
-       (read && read->CurrentContext && read->CurrentContext != ctx))
+   if (ctx->Binding && ctx->Binding != t)
       return _eglError(EGL_BAD_ACCESS, "eglMakeCurrent");
+   if (draw && draw->CurrentContext && draw->CurrentContext != ctx) {
+      if (draw->CurrentContext->Binding != t ||
+          draw->CurrentContext->ClientAPI != ctx->ClientAPI)
+         return _eglError(EGL_BAD_ACCESS, "eglMakeCurrent");
+   }
+   if (read && read->CurrentContext && read->CurrentContext != ctx) {
+      if (read->CurrentContext->Binding != t ||
+          read->CurrentContext->ClientAPI != ctx->ClientAPI)
+         return _eglError(EGL_BAD_ACCESS, "eglMakeCurrent");
+   }
 
    /* simply require the configs to be equal */
    if ((draw && draw->Config != ctx->Config) ||
diff --git a/src/egl/main/egldriver.h b/src/egl/main/egldriver.h
index c618feb..950774f 100644
--- a/src/egl/main/egldriver.h
+++ b/src/egl/main/egldriver.h
@@ -4,7 +4,7 @@
 
 #include "egltypedefs.h"
 #include "eglapi.h"
-
+#include <stddef.h>
 
 /**
  * Define an inline driver typecast function.
diff --git a/src/gallium/drivers/llvmpipe/lp_bld_depth.c b/src/gallium/drivers/llvmpipe/lp_bld_depth.c
index 99a768a..749ae66 100644
--- a/src/gallium/drivers/llvmpipe/lp_bld_depth.c
+++ b/src/gallium/drivers/llvmpipe/lp_bld_depth.c
@@ -262,7 +262,7 @@ lp_build_stencil_op_single(struct lp_build_context *bld,
       LLVMValueRef writemask = lp_build_const_int_vec(type, stencil->writemask);
       mask = LLVMBuildAnd(bld->builder, mask, writemask, "");
       /* res = (res & mask) | (stencilVals & ~mask) */
-      res = lp_build_select_bitwise(bld, writemask, res, stencilVals);
+      res = lp_build_select_bitwise(bld, mask, res, stencilVals);
    }
    else {
       /* res = mask ? res : stencilVals */
diff --git a/src/gallium/drivers/r300/r300_chipset.c b/src/gallium/drivers/r300/r300_chipset.c
index 48c2409..583e981 100644
--- a/src/gallium/drivers/r300/r300_chipset.c
+++ b/src/gallium/drivers/r300/r300_chipset.c
@@ -424,4 +424,5 @@ void r300_parse_chipset(struct r300_capabilities* caps)
     }
 
     caps->is_rv350 = caps->family >= CHIP_FAMILY_RV350;
+    caps->dxtc_swizzle = caps->is_r400 || caps->is_r500;
 }
diff --git a/src/gallium/drivers/r300/r300_chipset.h b/src/gallium/drivers/r300/r300_chipset.h
index e7ca642..7ea4175 100644
--- a/src/gallium/drivers/r300/r300_chipset.h
+++ b/src/gallium/drivers/r300/r300_chipset.h
@@ -79,6 +79,8 @@ struct r300_capabilities {
     boolean is_r500;
     /* Whether or not the second pixel pipe is accessed with the high bit */
     boolean high_second_pipe;
+    /* DXTC texture swizzling. */
+    boolean dxtc_swizzle;
 };
 
 /* Enumerations for legibility and telling which card we're running on. */
diff --git a/src/gallium/drivers/r300/r300_context.c b/src/gallium/drivers/r300/r300_context.c
index 624dadd..46504f5 100644
--- a/src/gallium/drivers/r300/r300_context.c
+++ b/src/gallium/drivers/r300/r300_context.c
@@ -79,6 +79,9 @@ static void r300_release_referenced_objects(struct r300_context *r300)
                 NULL);
     }
 
+    /* The dummy VBO. */
+    pipe_resource_reference(&r300->dummy_vb, NULL);
+
     /* The SWTCL VBO. */
     pipe_resource_reference(&r300->vbo, NULL);
 
@@ -488,6 +491,7 @@ struct pipe_context* r300_create_context(struct pipe_screen* screen,
         rtempl.target = PIPE_TEXTURE_2D;
         rtempl.format = PIPE_FORMAT_I8_UNORM;
         rtempl.bind = PIPE_BIND_SAMPLER_VIEW;
+        rtempl.usage = PIPE_USAGE_IMMUTABLE;
         rtempl.width0 = 1;
         rtempl.height0 = 1;
         rtempl.depth0 = 1;
@@ -501,6 +505,19 @@ struct pipe_context* r300_create_context(struct pipe_screen* screen,
         pipe_resource_reference(&tex, NULL);
     }
 
+    {
+        struct pipe_resource vb = {};
+        vb.target = PIPE_BUFFER;
+        vb.format = PIPE_FORMAT_R8_UNORM;
+        vb.bind = PIPE_BIND_VERTEX_BUFFER;
+        vb.usage = PIPE_USAGE_IMMUTABLE;
+        vb.width0 = sizeof(float) * 16;
+        vb.height0 = 1;
+        vb.depth0 = 1;
+
+        r300->dummy_vb = screen->resource_create(screen, &vb);
+    }
+
     return &r300->context;
 
  fail:
diff --git a/src/gallium/drivers/r300/r300_context.h b/src/gallium/drivers/r300/r300_context.h
index 8f4e2de..743e9da 100644
--- a/src/gallium/drivers/r300/r300_context.h
+++ b/src/gallium/drivers/r300/r300_context.h
@@ -470,6 +470,10 @@ struct r300_context {
      * dummy texture there. */
     struct r300_sampler_view *texkill_sampler;
 
+    /* When no vertex buffer is set, this one is used instead to prevent
+     * hardlocks. */
+    struct pipe_resource *dummy_vb;
+
     /* The currently active query. */
     struct r300_query *query_current;
     /* The saved query for blitter operations. */
diff --git a/src/gallium/drivers/r300/r300_reg.h b/src/gallium/drivers/r300/r300_reg.h
index 6bea783..788c513 100644
--- a/src/gallium/drivers/r300/r300_reg.h
+++ b/src/gallium/drivers/r300/r300_reg.h
@@ -1520,11 +1520,11 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 #	define R300_TX_TRI_PERF_3_8            (3<<15)
 #	define R300_ANISO_THRESHOLD_MASK       (7<<17)
 
+#       define R400_DXTC_SWIZZLE_ENABLE        (1<<21)
 #	define R500_MACRO_SWITCH               (1<<22)
 #       define R500_TX_MAX_ANISO(x)            ((x) << 23)
 #       define R500_TX_MAX_ANISO_MASK          (63 << 23)
 #       define R500_TX_ANISO_HIGH_QUALITY      (1 << 30)
-
 #	define R500_BORDER_FIX                 (1<<31)
 
 #define R300_TX_FORMAT0_0                   0x4480
diff --git a/src/gallium/drivers/r300/r300_render.c b/src/gallium/drivers/r300/r300_render.c
index 2f00c87..7a3eb09 100644
--- a/src/gallium/drivers/r300/r300_render.c
+++ b/src/gallium/drivers/r300/r300_render.c
@@ -676,9 +676,6 @@ static void r300_draw_vbo(struct pipe_context* pipe,
 {
     struct r300_context* r300 = r300_context(pipe);
 
-    if (!r300->velems->count || !r300->vertex_buffer_count)
-	    return;
-
     if (info->indexed && r300->index_buffer.buffer) {
         unsigned offset;
 
diff --git a/src/gallium/drivers/r300/r300_screen.c b/src/gallium/drivers/r300/r300_screen.c
index 7f41ff0..c349e7f 100644
--- a/src/gallium/drivers/r300/r300_screen.c
+++ b/src/gallium/drivers/r300/r300_screen.c
@@ -114,8 +114,9 @@ static int r300_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
         case PIPE_CAP_TEXTURE_MIRROR_CLAMP:
         case PIPE_CAP_TEXTURE_MIRROR_REPEAT:
         case PIPE_CAP_BLEND_EQUATION_SEPARATE:
-        case PIPE_CAP_TEXTURE_SWIZZLE:
             return 1;
+        case PIPE_CAP_TEXTURE_SWIZZLE:
+            return util_format_s3tc_enabled ? r300screen->caps.dxtc_swizzle : 1;
 
         /* Unsupported features (boolean caps). */
         case PIPE_CAP_TIMER_QUERY:
diff --git a/src/gallium/drivers/r300/r300_state.c b/src/gallium/drivers/r300/r300_state.c
index 53c1657..7779766 100644
--- a/src/gallium/drivers/r300/r300_state.c
+++ b/src/gallium/drivers/r300/r300_state.c
@@ -1363,6 +1363,7 @@ r300_create_sampler_view(struct pipe_context *pipe,
     struct r300_sampler_view *view = CALLOC_STRUCT(r300_sampler_view);
     struct r300_texture *tex = r300_texture(texture);
     boolean is_r500 = r300_screen(pipe->screen)->caps.is_r500;
+    boolean dxtc_swizzle = r300_screen(pipe->screen)->caps.dxtc_swizzle;
 
     if (view) {
         view->base = *templ;
@@ -1379,7 +1380,8 @@ r300_create_sampler_view(struct pipe_context *pipe,
         view->format = tex->tx_format;
         view->format.format1 |= r300_translate_texformat(templ->format,
                                                          view->swizzle,
-                                                         is_r500);
+                                                         is_r500,
+                                                         dxtc_swizzle);
         if (is_r500) {
             view->format.format2 |= r500_tx_format_msb_bit(templ->format);
         }
@@ -1464,6 +1466,15 @@ static void r300_set_vertex_buffers(struct pipe_context* pipe,
     struct pipe_vertex_buffer *vbo;
     unsigned i, max_index = (1 << 24) - 1;
     boolean any_user_buffer = FALSE;
+    struct pipe_vertex_buffer dummy_vb = {0};
+
+    /* There must be at least one vertex buffer set, otherwise it locks up. */
+    if (!count) {
+        dummy_vb.buffer = r300->dummy_vb;
+        dummy_vb.max_index = r300->dummy_vb->width0 / 4;
+        buffers = &dummy_vb;
+        count = 1;
+    }
 
     if (count == r300->vertex_buffer_count &&
         memcmp(r300->vertex_buffer, buffers,
@@ -1617,6 +1628,14 @@ static void* r300_create_vertex_elements_state(struct pipe_context* pipe,
     struct r300_vertex_element_state *velems;
     unsigned i;
     enum pipe_format *format;
+    struct pipe_vertex_element dummy_attrib = {0};
+
+    /* R300 Programmable Stream Control (PSC) doesn't support 0 vertex elements. */
+    if (!count) {
+        dummy_attrib.src_format = PIPE_FORMAT_R8G8B8A8_UNORM;
+        attribs = &dummy_attrib;
+        count = 1;
+    }
 
     assert(count <= PIPE_MAX_ATTRIBS);
     velems = CALLOC_STRUCT(r300_vertex_element_state);
@@ -1683,7 +1702,8 @@ static void* r300_create_vertex_elements_state(struct pipe_context* pipe,
              * swizzles are already set up.
              * Also compute the vertex size. */
             for (i = 0; i < count; i++) {
-                /* This is OK because we check for aligned strides too. */
+                /* This is OK because we check for aligned strides too
+                 * elsewhere. */
                 velems->hw_format_size[i] =
                     align(util_format_get_blocksize(velems->hw_format[i]), 4);
                 velems->vertex_size_dwords += velems->hw_format_size[i] / 4;
diff --git a/src/gallium/drivers/r300/r300_state_derived.c b/src/gallium/drivers/r300/r300_state_derived.c
index 2613e70..9d8b6da 100644
--- a/src/gallium/drivers/r300/r300_state_derived.c
+++ b/src/gallium/drivers/r300/r300_state_derived.c
@@ -25,6 +25,7 @@
 
 #include "util/u_math.h"
 #include "util/u_memory.h"
+#include "util/u_pack_color.h"
 
 #include "r300_context.h"
 #include "r300_fs.h"
@@ -568,55 +569,93 @@ static void r300_update_rs_block(struct r300_context *r300)
 }
 
 static uint32_t r300_get_border_color(enum pipe_format format,
-                                      const float border[4])
+                                      const float border[4],
+                                      boolean is_r500)
 {
     const struct util_format_description *desc;
-    float border_swizzled[4] = {
-        border[2],
-        border[1],
-        border[0],
-        border[3]
-    };
-    uint32_t r;
+    float border_swizzled[4] = {0};
+    unsigned i;
+    union util_color uc = {0};
 
     desc = util_format_description(format);
 
-    /* We don't use util_pack_format because it does not handle the formats
-     * we want, e.g. R4G4B4A4 is non-existent in Gallium. */
+    /* Do depth formats first. */
+    if (util_format_is_depth_or_stencil(format)) {
+        switch (format) {
+        case PIPE_FORMAT_Z16_UNORM:
+            return util_pack_z(PIPE_FORMAT_Z16_UNORM, border[0]);
+        case PIPE_FORMAT_X8Z24_UNORM:
+        case PIPE_FORMAT_S8_USCALED_Z24_UNORM:
+            if (is_r500) {
+                return util_pack_z(PIPE_FORMAT_X8Z24_UNORM, border[0]);
+            } else {
+                return util_pack_z(PIPE_FORMAT_Z16_UNORM, border[0]) << 16;
+            }
+        default:
+            assert(0);
+            return 0;
+        }
+    }
+
+    /* Apply inverse swizzle of the format. */
+    for (i = 0; i < 4; i++) {
+        switch (desc->swizzle[i]) {
+        case UTIL_FORMAT_SWIZZLE_X:
+            border_swizzled[2] = border[i];
+            break;
+        case UTIL_FORMAT_SWIZZLE_Y:
+            border_swizzled[1] = border[i];
+            break;
+        case UTIL_FORMAT_SWIZZLE_Z:
+            border_swizzled[0] = border[i];
+            break;
+        case UTIL_FORMAT_SWIZZLE_W:
+            border_swizzled[3] = border[i];
+            break;
+        }
+    }
+
+    /* Compressed formats. */
+    if (util_format_is_compressed(format)) {
+        util_pack_color(border_swizzled, PIPE_FORMAT_R8G8B8A8_UNORM, &uc);
+        return uc.ui;
+    }
+
     switch (desc->channel[0].size) {
         case 4:
-            r = ((float_to_ubyte(border_swizzled[0]) & 0xf0) >> 4) |
-                ((float_to_ubyte(border_swizzled[1]) & 0xf0) << 0) |
-                ((float_to_ubyte(border_swizzled[2]) & 0xf0) << 4) |
-                ((float_to_ubyte(border_swizzled[3]) & 0xf0) << 8);
+            util_pack_color(border_swizzled, PIPE_FORMAT_B4G4R4A4_UNORM, &uc);
             break;
 
         case 5:
             if (desc->channel[1].size == 5) {
-                r = ((float_to_ubyte(border_swizzled[0]) & 0xf8) >> 3) |
-                    ((float_to_ubyte(border_swizzled[1]) & 0xf8) << 2) |
-                    ((float_to_ubyte(border_swizzled[2]) & 0xf8) << 7) |
-                    ((float_to_ubyte(border_swizzled[3]) & 0x80) << 8);
+                util_pack_color(border_swizzled, PIPE_FORMAT_B5G5R5A1_UNORM, &uc);
             } else if (desc->channel[1].size == 6) {
-                r = ((float_to_ubyte(border_swizzled[0]) & 0xf8) >> 3) |
-                    ((float_to_ubyte(border_swizzled[1]) & 0xfc) << 3) |
-                    ((float_to_ubyte(border_swizzled[2]) & 0xf8) << 8);
+                util_pack_color(border_swizzled, PIPE_FORMAT_B5G6R5_UNORM, &uc);
             } else {
                 assert(0);
             }
             break;
 
         default:
-            /* I think the fat formats (16, 32) are specified
-             * as the 8-bit ones. I am not sure how compressed formats
-             * work here. */
-            r = ((float_to_ubyte(border_swizzled[0]) & 0xff) << 0) |
-                ((float_to_ubyte(border_swizzled[1]) & 0xff) << 8) |
-                ((float_to_ubyte(border_swizzled[2]) & 0xff) << 16) |
-                ((float_to_ubyte(border_swizzled[3]) & 0xff) << 24);
+        case 8:
+            util_pack_color(border_swizzled, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
+            break;
+
+        case 10:
+            util_pack_color(border_swizzled, PIPE_FORMAT_B10G10R10A2_UNORM, &uc);
+            break;
+
+        case 16:
+            if (desc->nr_channels <= 2) {
+                border_swizzled[0] = border_swizzled[2];
+                util_pack_color(border_swizzled, PIPE_FORMAT_R16G16_UNORM, &uc);
+            } else {
+                util_pack_color(border_swizzled, PIPE_FORMAT_B8G8R8A8_UNORM, &uc);
+            }
+            break;
     }
 
-    return r;
+    return uc.ui;
 }
 
 static void r300_merge_textures_and_samplers(struct r300_context* r300)
@@ -655,7 +694,8 @@ static void r300_merge_textures_and_samplers(struct r300_context* r300)
             /* Set the border color. */
             texstate->border_color =
                 r300_get_border_color(view->base.format,
-                                      sampler->state.border_color);
+                                      sampler->state.border_color,
+                                      r300->screen->caps.is_r500);
 
             /* determine min/max levels */
             max_level = MIN3(sampler->max_lod + view->base.first_level,
@@ -701,13 +741,18 @@ static void r300_merge_textures_and_samplers(struct r300_context* r300)
                 if (sampler->state.compare_mode == PIPE_TEX_COMPARE_NONE) {
                     texstate->format.format1 |=
                         r300_get_swizzle_combined(depth_swizzle,
-                                                  view->swizzle);
+                                                  view->swizzle, FALSE);
                 } else {
                     texstate->format.format1 |=
-                        r300_get_swizzle_combined(depth_swizzle, 0);
+                        r300_get_swizzle_combined(depth_swizzle, 0, FALSE);
                 }
             }
 
+            if (r300->screen->caps.dxtc_swizzle &&
+                util_format_is_compressed(tex->desc.b.b.format)) {
+                texstate->filter1 |= R400_DXTC_SWIZZLE_ENABLE;
+            }
+
             /* to emulate 1D textures through 2D ones correctly */
             if (tex->desc.b.b.target == PIPE_TEXTURE_1D) {
                 texstate->filter0 &= ~R300_TX_WRAP_T_MASK;
diff --git a/src/gallium/drivers/r300/r300_texture.c b/src/gallium/drivers/r300/r300_texture.c
index 34105aa..7e2f69a 100644
--- a/src/gallium/drivers/r300/r300_texture.c
+++ b/src/gallium/drivers/r300/r300_texture.c
@@ -40,7 +40,8 @@
 #include "pipe/p_screen.h"
 
 unsigned r300_get_swizzle_combined(const unsigned char *swizzle_format,
-                                   const unsigned char *swizzle_view)
+                                   const unsigned char *swizzle_view,
+                                   boolean dxtc_swizzle)
 {
     unsigned i;
     unsigned char swizzle[4];
@@ -51,10 +52,10 @@ unsigned r300_get_swizzle_combined(const unsigned char *swizzle_format,
         R300_TX_FORMAT_B_SHIFT,
         R300_TX_FORMAT_A_SHIFT
     };
-    const uint32_t swizzle_bit[4] = {
-        R300_TX_FORMAT_X,
+    uint32_t swizzle_bit[4] = {
+        dxtc_swizzle ? R300_TX_FORMAT_Z : R300_TX_FORMAT_X,
         R300_TX_FORMAT_Y,
-        R300_TX_FORMAT_Z,
+        dxtc_swizzle ? R300_TX_FORMAT_X : R300_TX_FORMAT_Z,
         R300_TX_FORMAT_W
     };
 
@@ -107,7 +108,8 @@ unsigned r300_get_swizzle_combined(const unsigned char *swizzle_format,
  * makes available X, Y, Z, W, ZERO, and ONE for swizzling. */
 uint32_t r300_translate_texformat(enum pipe_format format,
                                   const unsigned char *swizzle_view,
-                                  boolean is_r500)
+                                  boolean is_r500,
+                                  boolean dxtc_swizzle)
 {
     uint32_t result = 0;
     const struct util_format_description *desc;
@@ -169,7 +171,8 @@ uint32_t r300_translate_texformat(enum pipe_format format,
             }
     }
 
-    result |= r300_get_swizzle_combined(desc->swizzle, swizzle_view);
+    result |= r300_get_swizzle_combined(desc->swizzle, swizzle_view,
+                    util_format_is_compressed(format) && dxtc_swizzle);
 
     /* S3TC formats. */
     if (desc->layout == UTIL_FORMAT_LAYOUT_S3TC) {
@@ -538,7 +541,7 @@ boolean r300_is_zs_format_supported(enum pipe_format format)
 
 boolean r300_is_sampler_format_supported(enum pipe_format format)
 {
-    return r300_translate_texformat(format, 0, TRUE) != ~0;
+    return r300_translate_texformat(format, 0, TRUE, FALSE) != ~0;
 }
 
 void r300_texture_setup_format_state(struct r300_screen *screen,
diff --git a/src/gallium/drivers/r300/r300_texture.h b/src/gallium/drivers/r300/r300_texture.h
index c4588a0..fe9d351 100644
--- a/src/gallium/drivers/r300/r300_texture.h
+++ b/src/gallium/drivers/r300/r300_texture.h
@@ -35,11 +35,13 @@ struct r300_texture;
 struct r300_screen;
 
 unsigned r300_get_swizzle_combined(const unsigned char *swizzle_format,
-                                   const unsigned char *swizzle_view);
+                                   const unsigned char *swizzle_view,
+                                   boolean dxtc_swizzle);
 
 uint32_t r300_translate_texformat(enum pipe_format format,
                                   const unsigned char *swizzle_view,
-                                  boolean is_r500);
+                                  boolean is_r500,
+                                  boolean dxtc_swizzle);
 
 uint32_t r500_tx_format_msb_bit(enum pipe_format format);
 
diff --git a/src/gallium/drivers/r300/r300_texture_desc.c b/src/gallium/drivers/r300/r300_texture_desc.c
index e2d01cd..ff6d2b2 100644
--- a/src/gallium/drivers/r300/r300_texture_desc.c
+++ b/src/gallium/drivers/r300/r300_texture_desc.c
@@ -44,7 +44,7 @@ unsigned r300_get_pixel_alignment(enum pipe_format format,
             {{ 32, 1}, { 8,  4}, { 0,  0}}, /*   8 bits per pixel */
             {{ 16, 1}, { 8,  2}, { 4,  4}}, /*  16 bits per pixel */
             {{  8, 1}, { 4,  2}, { 0,  0}}, /*  32 bits per pixel */
-            {{  4, 1}, { 0,  0}, { 2,  2}}, /*  64 bits per pixel */
+            {{  4, 1}, { 2,  2}, { 0,  0}}, /*  64 bits per pixel */
             {{  2, 1}, { 0,  0}, { 0,  0}}  /* 128 bits per pixel */
         },
         {
@@ -53,7 +53,7 @@ unsigned r300_get_pixel_alignment(enum pipe_format format,
             {{256, 8}, {64, 32}, { 0,  0}}, /*   8 bits per pixel */
             {{128, 8}, {64, 16}, {32, 32}}, /*  16 bits per pixel */
             {{ 64, 8}, {32, 16}, { 0,  0}}, /*  32 bits per pixel */
-            {{ 32, 8}, { 0,  0}, {16, 16}}, /*  64 bits per pixel */
+            {{ 32, 8}, {16, 16}, { 0,  0}}, /*  64 bits per pixel */
             {{ 16, 8}, { 0,  0}, { 0,  0}}  /* 128 bits per pixel */
         }
     };
@@ -368,11 +368,11 @@ static void r300_setup_tiling(struct r300_screen *screen,
     switch (util_format_get_blocksize(format)) {
         case 1:
         case 4:
+        case 8:
             desc->microtile = R300_BUFFER_TILED;
             break;
 
         case 2:
-        case 8:
             if (rws->get_value(rws, R300_VID_SQUARE_TILING_SUPPORT)) {
                 desc->microtile = R300_BUFFER_SQUARETILED;
             }
diff --git a/src/gallium/state_trackers/egl/Makefile b/src/gallium/state_trackers/egl/Makefile
index 8dbfc5b..8cfcef9 100644
--- a/src/gallium/state_trackers/egl/Makefile
+++ b/src/gallium/state_trackers/egl/Makefile
@@ -17,7 +17,7 @@ x11_INCLUDES = \
 	-I$(TOP)/src/mapi \
 	-I$(TOP)/src/mesa \
 	$(X11_CFLAGS) \
-	$(shell pkg-config --cflags-only-I libdrm)
+	$(shell pkg-config --cflags-only-I libdrm dri2proto)
 
 x11_SOURCES = $(wildcard x11/*.c) \
 	      $(TOP)/src/glx/dri2.c
diff --git a/src/gallium/state_trackers/egl/common/egl_g3d_api.c b/src/gallium/state_trackers/egl/common/egl_g3d_api.c
index c0164da..3bde397 100644
--- a/src/gallium/state_trackers/egl/common/egl_g3d_api.c
+++ b/src/gallium/state_trackers/egl/common/egl_g3d_api.c
@@ -609,8 +609,10 @@ egl_g3d_wait_client(_EGLDriver *drv, _EGLDisplay *dpy, _EGLContext *ctx)
 
    gctx->stctxi->flush(gctx->stctxi,
          PIPE_FLUSH_RENDER_CACHE | PIPE_FLUSH_FRAME, &fence);
-   screen->fence_finish(screen, fence, 0);
-   screen->fence_reference(screen, &fence, NULL);
+   if (fence) {
+      screen->fence_finish(screen, fence, 0);
+      screen->fence_reference(screen, &fence, NULL);
+   }
 
    return EGL_TRUE;
 }
diff --git a/src/gallium/state_trackers/egl/x11/native_x11.h b/src/gallium/state_trackers/egl/x11/native_x11.h
index 0b47837..8945117 100644
--- a/src/gallium/state_trackers/egl/x11/native_x11.h
+++ b/src/gallium/state_trackers/egl/x11/native_x11.h
@@ -27,6 +27,7 @@
 #define _NATIVE_X11_H_
 
 #include "common/native.h"
+#include <X11/Xlib.h>
 
 struct native_display *
 x11_create_ximage_display(Display *dpy,
diff --git a/src/gallium/state_trackers/vega/api_context.c b/src/gallium/state_trackers/vega/api_context.c
index 0d04d8e..d6bbda5 100644
--- a/src/gallium/state_trackers/vega/api_context.c
+++ b/src/gallium/state_trackers/vega/api_context.c
@@ -73,7 +73,8 @@ void vegaFinish(void)
    pipe = ctx->pipe;
 
    pipe->flush(pipe, PIPE_FLUSH_RENDER_CACHE | PIPE_FLUSH_FRAME, &fence);
-
-   pipe->screen->fence_finish(pipe->screen, fence, 0);
-   pipe->screen->fence_reference(pipe->screen, &fence, NULL);
+   if (fence) {
+      pipe->screen->fence_finish(pipe->screen, fence, 0);
+      pipe->screen->fence_reference(pipe->screen, &fence, NULL);
+   }
 }
diff --git a/src/gallium/state_trackers/vega/vg_manager.c b/src/gallium/state_trackers/vega/vg_manager.c
index e799674..232deef 100644
--- a/src/gallium/state_trackers/vega/vg_manager.c
+++ b/src/gallium/state_trackers/vega/vg_manager.c
@@ -352,7 +352,7 @@ vg_api_create_context(struct st_api *stapi, struct st_manager *smapi,
       return NULL;
 
    /* only 1.0 is supported */
-   if (attribs->major != 1 || attribs->minor > 0)
+   if (attribs->major > 1 || (attribs->major == 1 && attribs->minor > 0))
       return NULL;
 
    pipe = smapi->screen->context_create(smapi->screen, NULL);
diff --git a/src/gallium/state_trackers/xorg/Makefile b/src/gallium/state_trackers/xorg/Makefile
index cb2c3ae..7a44d28 100644
--- a/src/gallium/state_trackers/xorg/Makefile
+++ b/src/gallium/state_trackers/xorg/Makefile
@@ -10,7 +10,7 @@ LIBRARY_INCLUDES = \
 	$(shell pkg-config libkms --atleast-version=1.0 \
 				&& echo "-DHAVE_LIBKMS") \
 	$(shell pkg-config libkms --silence-errors --cflags-only-I) \
-	$(shell pkg-config --cflags-only-I pixman-1 xorg-server libdrm xproto) \
+	$(shell pkg-config --cflags-only-I pixman-1 xorg-server libdrm xproto dri2proto) \
 	-I$(TOP)/src/gallium/include \
 	-I$(TOP)/src/gallium/auxiliary \
 	-I$(TOP)/include \
diff --git a/src/gallium/state_trackers/xorg/xorg_crtc.c b/src/gallium/state_trackers/xorg/xorg_crtc.c
index 26a907f..80af82d 100644
--- a/src/gallium/state_trackers/xorg/xorg_crtc.c
+++ b/src/gallium/state_trackers/xorg/xorg_crtc.c
@@ -234,6 +234,10 @@ crtc_load_cursor_argb_ga3d(xf86CrtcPtr crtc, CARD32 * image)
 		   64, 64, (void*)image, 64 * 4, 0, 0);
     ms->ctx->transfer_unmap(ms->ctx, transfer);
     ms->ctx->transfer_destroy(ms->ctx, transfer);
+
+    if (crtc->cursor_shown)
+	drmModeSetCursor(ms->fd, crtcp->drm_crtc->crtc_id,
+			 crtcp->cursor_handle, 64, 64);
 }
 
 #if HAVE_LIBKMS
@@ -271,6 +275,10 @@ crtc_load_cursor_argb_kms(xf86CrtcPtr crtc, CARD32 * image)
     memcpy(ptr, image, 64*64*4);
     kms_bo_unmap(crtcp->cursor_bo);
 
+    if (crtc->cursor_shown)
+	drmModeSetCursor(ms->fd, crtcp->drm_crtc->crtc_id,
+			 crtcp->cursor_handle, 64, 64);
+
     return;
 
 err_bo_destroy:
@@ -353,7 +361,7 @@ crtc_destroy(xf86CrtcPtr crtc)
 
     drmModeFreeCrtc(crtcp->drm_crtc);
 
-    xfree(crtcp);
+    free(crtcp);
     crtc->driver_private = NULL;
 }
 
@@ -401,7 +409,7 @@ xorg_crtc_init(ScrnInfoPtr pScrn)
 	if (crtc == NULL)
 	    goto out;
 
-	crtcp = xcalloc(1, sizeof(struct crtc_private));
+	crtcp = calloc(1, sizeof(struct crtc_private));
 	if (!crtcp) {
 	    xf86CrtcDestroy(crtc);
 	    goto out;
diff --git a/src/gallium/state_trackers/xorg/xorg_dri2.c b/src/gallium/state_trackers/xorg/xorg_dri2.c
index 704aed6..b723a8e 100644
--- a/src/gallium/state_trackers/xorg/xorg_dri2.c
+++ b/src/gallium/state_trackers/xorg/xorg_dri2.c
@@ -201,11 +201,11 @@ dri2_create_buffer(DrawablePtr pDraw, unsigned int attachment, unsigned int form
     DRI2Buffer2Ptr buffer;
     BufferPrivatePtr private;
 
-    buffer = xcalloc(1, sizeof *buffer);
+    buffer = calloc(1, sizeof *buffer);
     if (!buffer)
 	return NULL;
 
-    private = xcalloc(1, sizeof *private);
+    private = calloc(1, sizeof *private);
     if (!private) {
 	goto fail;
     }
@@ -217,9 +217,9 @@ dri2_create_buffer(DrawablePtr pDraw, unsigned int attachment, unsigned int form
     if (dri2_do_create_buffer(pDraw, (DRI2BufferPtr)buffer, format))
 	return buffer;
 
-    xfree(private);
+    free(private);
 fail:
-    xfree(buffer);
+    free(buffer);
     return NULL;
 }
 
@@ -229,8 +229,8 @@ dri2_destroy_buffer(DrawablePtr pDraw, DRI2Buffer2Ptr buffer)
     /* So far it is safe to downcast a DRI2Buffer2Ptr to DRI2BufferPtr */
     dri2_do_destroy_buffer(pDraw, (DRI2BufferPtr)buffer);
 
-    xfree(buffer->driverPrivate);
-    xfree(buffer);
+    free(buffer->driverPrivate);
+    free(buffer);
 }
 
 #endif /* DRI2INFOREC_VERSION >= 2 */
@@ -244,11 +244,11 @@ dri2_create_buffers(DrawablePtr pDraw, unsigned int *attachments, int count)
     DRI2BufferPtr buffers;
     int i;
 
-    buffers = xcalloc(count, sizeof *buffers);
+    buffers = calloc(count, sizeof *buffers);
     if (!buffers)
 	goto fail_buffers;
 
-    privates = xcalloc(count, sizeof *privates);
+    privates = calloc(count, sizeof *privates);
     if (!privates)
 	goto fail_privates;
 
@@ -263,9 +263,9 @@ dri2_create_buffers(DrawablePtr pDraw, unsigned int *attachments, int count)
     return buffers;
 
 fail:
-    xfree(privates);
+    free(privates);
 fail_privates:
-    xfree(buffers);
+    free(buffers);
 fail_buffers:
     return NULL;
 }
@@ -280,8 +280,8 @@ dri2_destroy_buffers(DrawablePtr pDraw, DRI2BufferPtr buffers, int count)
     }
 
     if (buffers) {
-	xfree(buffers[0].driverPrivate);
-	xfree(buffers);
+	free(buffers[0].driverPrivate);
+	free(buffers);
     }
 }
 
diff --git a/src/gallium/state_trackers/xorg/xorg_driver.c b/src/gallium/state_trackers/xorg/xorg_driver.c
index e10ff2f..1ec772d 100644
--- a/src/gallium/state_trackers/xorg/xorg_driver.c
+++ b/src/gallium/state_trackers/xorg/xorg_driver.c
@@ -45,6 +45,7 @@
 #include "miscstruct.h"
 #include "dixstruct.h"
 #include "xf86xv.h"
+#include "xorgVersion.h"
 #ifndef XSERVER_LIBPCIACCESS
 #error "libpciaccess needed"
 #endif
@@ -122,7 +123,7 @@ xorg_tracker_set_functions(ScrnInfoPtr scrn)
 Bool
 xorg_tracker_have_modesetting(ScrnInfoPtr pScrn, struct pci_device *device)
 {
-    char *BusID = xalloc(64);
+    char *BusID = malloc(64);
     sprintf(BusID, "pci:%04x:%02x:%02x.%d",
 	    device->domain, device->bus,
 	    device->dev, device->func);
@@ -130,14 +131,14 @@ xorg_tracker_have_modesetting(ScrnInfoPtr pScrn, struct pci_device *device)
     if (drmCheckModesettingSupported(BusID)) {
 	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 0,
 		       "Drm modesetting not supported %s\n", BusID);
-	xfree(BusID);
+	free(BusID);
 	return FALSE;
     }
 
     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 0,
 		   "Drm modesetting supported on %s\n", BusID);
 
-    xfree(BusID);
+    free(BusID);
     return TRUE;
 }
 
@@ -174,7 +175,7 @@ drv_free_rec(ScrnInfoPtr pScrn)
     if (!pScrn->driverPrivate)
 	return;
 
-    xfree(pScrn->driverPrivate);
+    free(pScrn->driverPrivate);
 
     pScrn->driverPrivate = NULL;
 }
@@ -274,7 +275,7 @@ drv_init_drm(ScrnInfoPtr pScrn)
     if (ms->fd < 0) {
 	char *BusID;
 
-	BusID = xalloc(64);
+	BusID = malloc(64);
 	sprintf(BusID, "PCI:%d:%d:%d",
 		((ms->PciInfo->domain << 8) | ms->PciInfo->bus),
 		ms->PciInfo->dev, ms->PciInfo->func
@@ -283,7 +284,7 @@ drv_init_drm(ScrnInfoPtr pScrn)
 
 	ms->fd = drmOpen(driver_descriptor.driver_name, BusID);
 	ms->isMaster = TRUE;
-	xfree(BusID);
+	free(BusID);
 
 	if (ms->fd >= 0)
 	    return TRUE;
@@ -369,6 +370,7 @@ drv_pre_init(ScrnInfoPtr pScrn, int flags)
     ms = modesettingPTR(pScrn);
     ms->pEnt = pEnt;
     ms->cust = cust;
+    ms->fb_id = -1;
 
     pScrn->displayWidth = 640;	       /* default it */
 
@@ -402,19 +404,6 @@ drv_pre_init(ScrnInfoPtr pScrn, int flags)
     if (!drv_init_drm(pScrn))
 	return FALSE;
 
-    use3D = cust ? !cust->no_3d : TRUE;
-    ms->from_3D = xf86GetOptValBool(ms->Options, OPTION_3D_ACCEL,
-				    &use3D) ?
-	X_CONFIG : X_PROBED;
-
-    ms->no3D = !use3D;
-
-    if (!drv_init_resource_management(pScrn)) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Could not init "
-					       "Gallium3D or libKMS.");
-	return FALSE;
-    }
-
     pScrn->monitor = pScrn->confScreen->monitor;
     pScrn->progClock = TRUE;
     pScrn->rgbBits = 8;
@@ -444,11 +433,24 @@ drv_pre_init(ScrnInfoPtr pScrn, int flags)
 
     /* Process the options */
     xf86CollectOptions(pScrn, NULL);
-    if (!(ms->Options = xalloc(sizeof(drv_options))))
+    if (!(ms->Options = malloc(sizeof(drv_options))))
 	return FALSE;
     memcpy(ms->Options, drv_options, sizeof(drv_options));
     xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, ms->Options);
 
+    use3D = cust ? !cust->no_3d : TRUE;
+    ms->from_3D = xf86GetOptValBool(ms->Options, OPTION_3D_ACCEL,
+				    &use3D) ?
+	X_CONFIG : X_PROBED;
+
+    ms->no3D = !use3D;
+
+    if (!drv_init_resource_management(pScrn)) {
+	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Could not init "
+					       "Gallium3D or libKMS.");
+	return FALSE;
+    }
+
     /* Allocate an xf86CrtcConfig */
     xf86CrtcConfigInit(pScrn, &crtc_config_funcs);
     xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
@@ -791,7 +793,9 @@ drv_screen_init(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     if (!ms->SWCursor)
 	xf86_cursors_init(pScreen, 64, 64,
 			  HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64 |
-			  HARDWARE_CURSOR_ARGB);
+			  HARDWARE_CURSOR_ARGB |
+			  ((cust && cust->unhidden_hw_cursor_update) ?
+			   HARDWARE_CURSOR_UPDATE_UNHIDDEN : 0));
 
     /* Must force it before EnterVT, so we are in control of VT and
      * later memory should be bound when allocating, e.g rotate_mem */
@@ -862,8 +866,10 @@ drv_leave_vt(int scrnIndex, int flags)
 	}
     }
 
-    drmModeRmFB(ms->fd, ms->fb_id);
-    ms->fb_id = -1;
+    if (ms->fb_id != -1) {
+	drmModeRmFB(ms->fd, ms->fb_id);
+	ms->fb_id = -1;
+    }
 
     /* idle hardware */
     if (!ms->kms)
@@ -944,7 +950,6 @@ drv_close_screen(int scrnIndex, ScreenPtr pScreen)
     }
 #endif
 
-    drmModeRmFB(ms->fd, ms->fb_id);
     ms->destroy_front_buffer(pScrn);
 
     if (ms->exa)
@@ -1178,6 +1183,8 @@ drv_bind_front_buffer_kms(ScrnInfoPtr pScrn)
 				stride,
 				ptr);
 
+#if (XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1, 9, 99, 1, 0))
+
     /* This a hack to work around EnableDisableFBAccess setting the pointer
      * the real fix would be to replace pScrn->EnableDisableFBAccess hook
      * and set the rootPixmap->devPrivate.ptr to something valid before that.
@@ -1187,6 +1194,8 @@ drv_bind_front_buffer_kms(ScrnInfoPtr pScrn)
      */
     pScrn->pixmapPrivate.ptr = ptr;
 
+#endif
+
     return TRUE;
 
 err_destroy:
diff --git a/src/gallium/state_trackers/xorg/xorg_exa.c b/src/gallium/state_trackers/xorg/xorg_exa.c
index 6b2c80f..0e5693d 100644
--- a/src/gallium/state_trackers/xorg/xorg_exa.c
+++ b/src/gallium/state_trackers/xorg/xorg_exa.c
@@ -720,7 +720,7 @@ ExaCreatePixmap(ScreenPtr pScreen, int size, int align)
 {
     struct exa_pixmap_priv *priv;
 
-    priv = xcalloc(1, sizeof(struct exa_pixmap_priv));
+    priv = calloc(1, sizeof(struct exa_pixmap_priv));
     if (!priv)
 	return NULL;
 
@@ -737,7 +737,7 @@ ExaDestroyPixmap(ScreenPtr pScreen, void *dPriv)
 
     pipe_resource_reference(&priv->tex, NULL);
 
-    xfree(priv);
+    free(priv);
 }
 
 static Bool
@@ -975,7 +975,7 @@ xorg_exa_close(ScrnInfoPtr pScrn)
    ms->ctx = NULL;
 
    exaDriverFini(pScrn->pScreen);
-   xfree(exa);
+   free(exa);
    ms->exa = NULL;
 }
 
@@ -987,7 +987,7 @@ xorg_exa_init(ScrnInfoPtr pScrn, Bool accel)
    ExaDriverPtr pExa;
    CustomizerPtr cust = ms->cust;
 
-   exa = xcalloc(1, sizeof(struct exa_context));
+   exa = calloc(1, sizeof(struct exa_context));
    if (!exa)
       return NULL;
 
diff --git a/src/gallium/state_trackers/xorg/xorg_output.c b/src/gallium/state_trackers/xorg/xorg_output.c
index 61206ed..5555b51 100644
--- a/src/gallium/state_trackers/xorg/xorg_output.c
+++ b/src/gallium/state_trackers/xorg/xorg_output.c
@@ -128,7 +128,7 @@ output_get_modes(xf86OutputPtr output)
     for (i = 0; i < drm_connector->count_modes; i++) {
 	drm_mode = &drm_connector->modes[i];
 	if (drm_mode) {
-	    mode = xcalloc(1, sizeof(DisplayModeRec));
+	    mode = calloc(1, sizeof(DisplayModeRec));
 	    if (!mode)
 		continue;
 	    mode->Clock = drm_mode->clock;
@@ -195,7 +195,7 @@ output_destroy(xf86OutputPtr output)
 {
     struct output_private *priv = output->driver_private;
     drmModeFreeConnector(priv->drm_connector);
-    xfree(priv);
+    free(priv);
     output->driver_private = NULL;
 }
 
@@ -262,14 +262,14 @@ xorg_output_init(ScrnInfoPtr pScrn)
 		 drm_connector->connector_type_id);
 
 
-	priv = xcalloc(sizeof(*priv), 1);
+	priv = calloc(sizeof(*priv), 1);
 	if (!priv) {
 	    continue;
 	}
 
 	output = xf86OutputCreate(pScrn, &output_funcs, name);
 	if (!output) {
-	    xfree(priv);
+	    free(priv);
 	    continue;
 	}
 
diff --git a/src/gallium/state_trackers/xorg/xorg_tracker.h b/src/gallium/state_trackers/xorg/xorg_tracker.h
index be1a9fd..a3fb5e5 100644
--- a/src/gallium/state_trackers/xorg/xorg_tracker.h
+++ b/src/gallium/state_trackers/xorg/xorg_tracker.h
@@ -76,6 +76,7 @@ typedef struct _CustomizerRec
     Bool dirty_throttling;
     Bool swap_throttling;
     Bool no_3d;
+    Bool unhidden_hw_cursor_update;
     Bool (*winsys_pre_init) (struct _CustomizerRec *cust, int fd);
     Bool (*winsys_screen_init)(struct _CustomizerRec *cust);
     Bool (*winsys_screen_close)(struct _CustomizerRec *cust);
diff --git a/src/gallium/state_trackers/xorg/xorg_xv.c b/src/gallium/state_trackers/xorg/xorg_xv.c
index f98bd93..f64959f 100644
--- a/src/gallium/state_trackers/xorg/xorg_xv.c
+++ b/src/gallium/state_trackers/xorg/xorg_xv.c
@@ -536,8 +536,10 @@ display_video(ScrnInfoPtr pScrn, struct xorg_xv_port_priv *pPriv, int id,
    dst_surf = xorg_gpu_surface(pPriv->r->pipe->screen, dst);
    hdtv = ((src_w >= RES_720P_X) && (src_h >= RES_720P_Y));
 
+#ifdef COMPOSITE
    REGION_TRANSLATE(pScrn->pScreen, dstRegion, -pPixmap->screen_x,
                     -pPixmap->screen_y);
+#endif
 
    dxo = dstRegion->extents.x1;
    dyo = dstRegion->extents.y1;
@@ -562,11 +564,16 @@ display_video(ScrnInfoPtr pScrn, struct xorg_xv_port_priv *pPriv, int id,
       int box_y2 = pbox->y2;
       float diff_x = (float)src_w / (float)dst_w;
       float diff_y = (float)src_h / (float)dst_h;
-      float offset_x = box_x1 - dstX + pPixmap->screen_x;
-      float offset_y = box_y1 - dstY + pPixmap->screen_y;
+      float offset_x = box_x1 - dstX;
+      float offset_y = box_y1 - dstY;
       float offset_w;
       float offset_h;
 
+#ifdef COMPOSITE
+      offset_x += pPixmap->screen_x;
+      offset_y += pPixmap->screen_y;
+#endif
+
       x = box_x1;
       y = box_y1;
       w = box_x2 - box_x1;
diff --git a/src/gallium/targets/Makefile.dri b/src/gallium/targets/Makefile.dri
index 59961e9..3fb4cc6 100644
--- a/src/gallium/targets/Makefile.dri
+++ b/src/gallium/targets/Makefile.dri
@@ -80,7 +80,7 @@ $(LIBNAME): $(OBJECTS) $(MESA_MODULES) $(PIPE_DRIVERS) Makefile \
 		$(OBJECTS) $(PIPE_DRIVERS) \
                 -Wl,--start-group $(MESA_MODULES) -Wl,--end-group \
                  $(DRI_LIB_DEPS) $(DRIVER_EXTRAS)
-	$(CXX) $(CFLAGS) -o $@.test $(TOP)/src/mesa/drivers/dri/common/dri_test.o $@.tmp $(DRI_LIB_DEPS);
+	$(CXX) $(CFLAGS) -o $@.test $(TOP)/src/mesa/drivers/dri/common/dri_test.o $@.tmp $(DRI_LIB_DEPS) $(LDFLAGS);
 	@rm -f $@.test
 	mv -f $@.tmp $@
 
diff --git a/src/gallium/targets/Makefile.xorg b/src/gallium/targets/Makefile.xorg
index 762c905..87eedd7 100644
--- a/src/gallium/targets/Makefile.xorg
+++ b/src/gallium/targets/Makefile.xorg
@@ -29,7 +29,7 @@ INCLUDES = \
 LIBNAME_STAGING = $(TOP)/$(LIB_DIR)/gallium/$(TARGET)
 
 ifeq ($(MESA_LLVM),1)
-LD = g++
+LD = $(CXX)
 LDFLAGS += $(LLVM_LDFLAGS)
 USE_CXX=1
 DRIVER_PIPES += $(TOP)/src/gallium/drivers/llvmpipe/libllvmpipe.a
@@ -42,7 +42,7 @@ endif
 default: depend $(TOP)/$(LIB_DIR)/gallium $(LIBNAME) $(LIBNAME_STAGING)
 
 $(LIBNAME): $(OBJECTS) Makefile ../Makefile.xorg $(LIBS) $(DRIVER_PIPES)
-	$(MKLIB) -noprefix -o $@ $(LDFLAGS) $(OBJECTS) $(DRIVER_PIPES) $(GALLIUM_AUXILIARIES) $(DRIVER_LINKS)
+	$(MKLIB) -linker $(CC) -noprefix -o $@ $(LDFLAGS) $(OBJECTS) $(DRIVER_PIPES) $(GALLIUM_AUXILIARIES) $(DRIVER_LINKS)
 
 depend: $(C_SOURCES) $(CPP_SOURCES) $(ASM_SOURCES) $(SYMLINKS) $(GENERATED_SOURCES)
 	rm -f depend
diff --git a/src/gallium/targets/dri-vmwgfx/Makefile b/src/gallium/targets/dri-vmwgfx/Makefile
index 97c703b..38f7893 100644
--- a/src/gallium/targets/dri-vmwgfx/Makefile
+++ b/src/gallium/targets/dri-vmwgfx/Makefile
@@ -12,6 +12,7 @@ PIPE_DRIVERS = \
 
 C_SOURCES = \
 	target.c \
+	vmw_powf.c \
 	$(COMMON_GALLIUM_SOURCES)
 
 DRIVER_DEFINES = \
diff --git a/src/gallium/targets/dri-vmwgfx/vmw_powf.c b/src/gallium/targets/dri-vmwgfx/vmw_powf.c
new file mode 100644
index 0000000..ca5e39b
--- /dev/null
+++ b/src/gallium/targets/dri-vmwgfx/vmw_powf.c
@@ -0,0 +1,17 @@
+/**
+ * Powf may leave an unresolved symbol pointing to a libstdc++.so powf.
+ * However, not all libstdc++.so include this function, so optionally
+ * replace the powf function with calls to expf and logf.
+ */
+
+#ifdef VMW_RESOLVE_POWF
+
+extern float expf(float x);
+extern float logf(float x);
+extern float powf(float x, float y);
+
+float powf(float x, float y) {
+    return expf(logf(x)*y);
+}
+
+#endif
diff --git a/src/gallium/targets/egl/Makefile b/src/gallium/targets/egl/Makefile
index 47c24ce..38e60db 100644
--- a/src/gallium/targets/egl/Makefile
+++ b/src/gallium/targets/egl/Makefile
@@ -24,7 +24,9 @@ common_CPPFLAGS := \
 	-I$(TOP)/src/gallium/auxiliary \
 	-I$(TOP)/src/gallium/drivers \
 	-I$(TOP)/src/gallium/include \
-	-I$(TOP)/src/gallium/winsys
+	-I$(TOP)/src/gallium/winsys \
+	$(LIBDRM_CFLAGS)
+
 common_SYS :=
 common_LIBS := \
 	$(TOP)/src/gallium/drivers/identity/libidentity.a \
@@ -41,11 +43,11 @@ egl_SYS := -lm $(DLOPEN_LIBS) -L$(TOP)/$(LIB_DIR) -lEGL
 egl_LIBS := $(TOP)/src/gallium/state_trackers/egl/libegl.a
 
 ifneq ($(findstring x11, $(EGL_PLATFORMS)),)
-egl_SYS += -lX11 -lXext -lXfixes
+egl_SYS += -lX11 -lXext -lXfixes $(LIBDRM_LIB)
 egl_LIBS += $(TOP)/src/gallium/winsys/sw/xlib/libws_xlib.a
 endif
-ifneq ($(findstring kms, $(EGL_PLATFORMS)),)
-egl_SYS += -ldrm
+ifneq ($(findstring drm, $(EGL_PLATFORMS)),)
+egl_SYS += $(LIBDRM_LIB)
 endif
 ifneq ($(findstring fbdev, $(EGL_PLATFORMS)),)
 egl_LIBS += $(TOP)/src/gallium/winsys/sw/fbdev/libfbdev.a
diff --git a/src/gallium/targets/egl/pipe_i965.c b/src/gallium/targets/egl/pipe_i965.c
index 43bf646..36b03b3 100644
--- a/src/gallium/targets/egl/pipe_i965.c
+++ b/src/gallium/targets/egl/pipe_i965.c
@@ -1,6 +1,7 @@
 
 #include "target-helpers/inline_wrapper_sw_helper.h"
 #include "target-helpers/inline_debug_helper.h"
+#include "target-helpers/inline_wrapper_sw_helper.h"
 #include "state_tracker/drm_driver.h"
 #include "i965/drm/i965_drm_public.h"
 #include "i965/brw_public.h"
diff --git a/src/gallium/targets/xorg-vmwgfx/vmw_ctrl.c b/src/gallium/targets/xorg-vmwgfx/vmw_ctrl.c
index 237b308..9b422e6 100644
--- a/src/gallium/targets/xorg-vmwgfx/vmw_ctrl.c
+++ b/src/gallium/targets/xorg-vmwgfx/vmw_ctrl.c
@@ -32,6 +32,7 @@
  *      allows X clients to communicate with the driver.
  */
 
+#include <xorg-server.h>
 #include "dixstruct.h"
 #include "extnsionst.h"
 #include <X11/X.h>
@@ -211,7 +212,7 @@ VMwareCtrlDoSetTopology(ScrnInfoPtr pScrn,
    struct vmw_customizer *vmw = vmw_customizer(xorg_customizer(pScrn));
    int i;
 
-   rects = xcalloc(number, sizeof(*rects));
+   rects = calloc(number, sizeof(*rects));
    if (!rects)
       return FALSE;
 
@@ -224,7 +225,7 @@ VMwareCtrlDoSetTopology(ScrnInfoPtr pScrn,
 
    vmw_ioctl_update_layout(vmw, number, rects);
 
-   xfree(rects);
+   free(rects);
    return TRUE;
 }
 
diff --git a/src/gallium/targets/xorg-vmwgfx/vmw_ioctl.c b/src/gallium/targets/xorg-vmwgfx/vmw_ioctl.c
index 7c799b5..7625d2f 100644
--- a/src/gallium/targets/xorg-vmwgfx/vmw_ioctl.c
+++ b/src/gallium/targets/xorg-vmwgfx/vmw_ioctl.c
@@ -165,7 +165,7 @@ vmw_ioctl_buffer_create(struct vmw_customizer *vmw, uint32_t size, unsigned *han
     struct drm_vmw_dmabuf_rep *rep = &arg.rep;
     int ret;
 
-    buf = xcalloc(1, sizeof(*buf));
+    buf = calloc(1, sizeof(*buf));
     if (!buf)
 	goto err;
 
@@ -192,7 +192,7 @@ vmw_ioctl_buffer_create(struct vmw_customizer *vmw, uint32_t size, unsigned *han
     return buf;
 
 err_free:
-    xfree(buf);
+    free(buf);
 err:
     return NULL;
 }
@@ -211,7 +211,7 @@ vmw_ioctl_buffer_destroy(struct vmw_customizer *vmw, struct vmw_dma_buffer *buf)
     arg.handle = buf->handle; 
     drmCommandWrite(vmw->fd, DRM_VMW_UNREF_DMABUF, &arg, sizeof(arg)); 
 
-    xfree(buf); 
+    free(buf);
 } 
 
 void *
diff --git a/src/gallium/targets/xorg-vmwgfx/vmw_screen.c b/src/gallium/targets/xorg-vmwgfx/vmw_screen.c
index 8173908..7662203 100644
--- a/src/gallium/targets/xorg-vmwgfx/vmw_screen.c
+++ b/src/gallium/targets/xorg-vmwgfx/vmw_screen.c
@@ -245,6 +245,7 @@ vmw_screen_pre_init(ScrnInfoPtr pScrn, int flags)
     cust->winsys_enter_vt = vmw_screen_enter_vt;
     cust->winsys_leave_vt = vmw_screen_leave_vt;
     cust->no_3d = TRUE;
+    cust->unhidden_hw_cursor_update = TRUE;
     vmw->pScrn = pScrn;
 
     pScrn->driverPrivate = cust;
diff --git a/src/gallium/targets/xorg-vmwgfx/vmw_video.c b/src/gallium/targets/xorg-vmwgfx/vmw_video.c
index eced60d..94465e5 100644
--- a/src/gallium/targets/xorg-vmwgfx/vmw_video.c
+++ b/src/gallium/targets/xorg-vmwgfx/vmw_video.c
@@ -300,7 +300,7 @@ vmw_video_init(struct vmw_customizer *vmw)
         numAdaptors = 1;
         overlayAdaptors = &newAdaptor;
     } else {
-         newAdaptors = xalloc((numAdaptors + 1) *
+         newAdaptors = malloc((numAdaptors + 1) *
                               sizeof(XF86VideoAdaptorPtr*));
          if (!newAdaptors) {
             xf86XVFreeVideoAdaptorRec(newAdaptor);
@@ -320,7 +320,7 @@ vmw_video_init(struct vmw_customizer *vmw)
     }
 
     if (newAdaptors) {
-        xfree(newAdaptors);
+        free(newAdaptors);
     }
 
     debug_printf("Initialized VMware Xv extension successfully\n");
@@ -438,7 +438,7 @@ vmw_video_init_adaptor(ScrnInfoPtr pScrn, struct vmw_customizer *vmw)
         return NULL;
     }
 
-    video = xcalloc(1, sizeof(*video));
+    video = calloc(1, sizeof(*video));
     if (!video) {
         debug_printf("Not enough memory.\n");
         xf86XVFreeVideoAdaptorRec(adaptor);
@@ -742,7 +742,7 @@ vmw_video_buffer_alloc(struct vmw_customizer *vmw, int size,
     }
 
     out->size = size;
-    out->extra_data = xcalloc(1, size);
+    out->extra_data = calloc(1, size);
 
     debug_printf("\t\t%s: allocated buffer %p of size %i\n", __func__, out, size);
 
@@ -773,7 +773,7 @@ vmw_video_buffer_free(struct vmw_customizer *vmw,
     if (out->size == 0)
 	return Success;
 
-    xfree(out->extra_data);
+    free(out->extra_data);
     vmw_ioctl_buffer_unmap(vmw, out->buf);
     vmw_ioctl_buffer_destroy(vmw, out->buf);
 
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm.h b/src/gallium/winsys/radeon/drm/radeon_drm.h
index df6dd91..061229f 100644
--- a/src/gallium/winsys/radeon/drm/radeon_drm.h
+++ b/src/gallium/winsys/radeon/drm/radeon_drm.h
@@ -37,7 +37,214 @@
  * I believe that this check is valid, but I haven't been exhaustive. */
 static INLINE boolean is_r3xx(int pciid)
 {
-    return (pciid > 0x3150) && (pciid < 0x796f);
+      switch (pciid) {
+      case 0x4144: /* PCI_CHIP_R300_AD */
+      case 0x4145: /* PCI_CHIP_R300_AE */
+      case 0x4146: /* PCI_CHIP_R300_AF */
+      case 0x4147: /* PCI_CHIP_R300_AG */
+      case 0x4E44: /* PCI_CHIP_R300_ND */
+      case 0x4E45: /* PCI_CHIP_R300_NE */
+      case 0x4E46: /* PCI_CHIP_R300_NF */
+      case 0x4E47: /* PCI_CHIP_R300_NG */
+      case 0x4E48: /* PCI_CHIP_R350_NH */
+      case 0x4E49: /* PCI_CHIP_R350_NI */
+      case 0x4E4B: /* PCI_CHIP_R350_NK */
+      case 0x4148: /* PCI_CHIP_R350_AH */
+      case 0x4149: /* PCI_CHIP_R350_AI */
+      case 0x414A: /* PCI_CHIP_R350_AJ */
+      case 0x414B: /* PCI_CHIP_R350_AK */
+      case 0x4E4A: /* PCI_CHIP_R360_NJ */
+      case 0x4150: /* PCI_CHIP_RV350_AP */
+      case 0x4151: /* PCI_CHIP_RV350_AQ */
+      case 0x4152: /* PCI_CHIP_RV350_AR */
+      case 0x4153: /* PCI_CHIP_RV350_AS */
+      case 0x4154: /* PCI_CHIP_RV350_AT */
+      case 0x4155: /* PCI_CHIP_RV350_AU */
+      case 0x4156: /* PCI_CHIP_RV350_AV */
+      case 0x4E50: /* PCI_CHIP_RV350_NP */
+      case 0x4E51: /* PCI_CHIP_RV350_NQ */
+      case 0x4E52: /* PCI_CHIP_RV350_NR */
+      case 0x4E53: /* PCI_CHIP_RV350_NS */
+      case 0x4E54: /* PCI_CHIP_RV350_NT */
+      case 0x4E56: /* PCI_CHIP_RV350_NV */
+      case 0x5460: /* PCI_CHIP_RV370_5460 */
+      case 0x5462: /* PCI_CHIP_RV370_5462 */
+      case 0x5464: /* PCI_CHIP_RV370_5464 */
+      case 0x5B60: /* PCI_CHIP_RV370_5B60 */
+      case 0x5B62: /* PCI_CHIP_RV370_5B62 */
+      case 0x5B63: /* PCI_CHIP_RV370_5B63 */
+      case 0x5B64: /* PCI_CHIP_RV370_5B64 */
+      case 0x5B65: /* PCI_CHIP_RV370_5B65 */
+      case 0x3150: /* PCI_CHIP_RV380_3150 */
+      case 0x3152: /* PCI_CHIP_RV380_3152 */
+      case 0x3154: /* PCI_CHIP_RV380_3154 */
+      case 0x3155: /* PCI_CHIP_RV380_3155 */
+      case 0x3E50: /* PCI_CHIP_RV380_3E50 */
+      case 0x3E54: /* PCI_CHIP_RV380_3E54 */
+      case 0x4A48: /* PCI_CHIP_R420_JH */
+      case 0x4A49: /* PCI_CHIP_R420_JI */
+      case 0x4A4A: /* PCI_CHIP_R420_JJ */
+      case 0x4A4B: /* PCI_CHIP_R420_JK */
+      case 0x4A4C: /* PCI_CHIP_R420_JL */
+      case 0x4A4D: /* PCI_CHIP_R420_JM */
+      case 0x4A4E: /* PCI_CHIP_R420_JN */
+      case 0x4A4F: /* PCI_CHIP_R420_JO */
+      case 0x4A50: /* PCI_CHIP_R420_JP */
+      case 0x4A54: /* PCI_CHIP_R420_JT */
+      case 0x5548: /* PCI_CHIP_R423_UH */
+      case 0x5549: /* PCI_CHIP_R423_UI */
+      case 0x554A: /* PCI_CHIP_R423_UJ */
+      case 0x554B: /* PCI_CHIP_R423_UK */
+      case 0x5550: /* PCI_CHIP_R423_5550 */
+      case 0x5551: /* PCI_CHIP_R423_UQ */
+      case 0x5552: /* PCI_CHIP_R423_UR */
+      case 0x5554: /* PCI_CHIP_R423_UT */
+      case 0x5D57: /* PCI_CHIP_R423_5D57 */
+      case 0x554C: /* PCI_CHIP_R430_554C */
+      case 0x554D: /* PCI_CHIP_R430_554D */
+      case 0x554E: /* PCI_CHIP_R430_554E */
+      case 0x554F: /* PCI_CHIP_R430_554F */
+      case 0x5D48: /* PCI_CHIP_R430_5D48 */
+      case 0x5D49: /* PCI_CHIP_R430_5D49 */
+      case 0x5D4A: /* PCI_CHIP_R430_5D4A */
+      case 0x5D4C: /* PCI_CHIP_R480_5D4C */
+      case 0x5D4D: /* PCI_CHIP_R480_5D4D */
+      case 0x5D4E: /* PCI_CHIP_R480_5D4E */
+      case 0x5D4F: /* PCI_CHIP_R480_5D4F */
+      case 0x5D50: /* PCI_CHIP_R480_5D50 */
+      case 0x5D52: /* PCI_CHIP_R480_5D52 */
+      case 0x4B49: /* PCI_CHIP_R481_4B49 */
+      case 0x4B4A: /* PCI_CHIP_R481_4B4A */
+      case 0x4B4B: /* PCI_CHIP_R481_4B4B */
+      case 0x4B4C: /* PCI_CHIP_R481_4B4C */
+      case 0x564A: /* PCI_CHIP_RV410_564A */
+      case 0x564B: /* PCI_CHIP_RV410_564B */
+      case 0x564F: /* PCI_CHIP_RV410_564F */
+      case 0x5652: /* PCI_CHIP_RV410_5652 */
+      case 0x5653: /* PCI_CHIP_RV410_5653 */
+      case 0x5657: /* PCI_CHIP_RV410_5657 */
+      case 0x5E48: /* PCI_CHIP_RV410_5E48 */
+      case 0x5E4A: /* PCI_CHIP_RV410_5E4A */
+      case 0x5E4B: /* PCI_CHIP_RV410_5E4B */
+      case 0x5E4C: /* PCI_CHIP_RV410_5E4C */
+      case 0x5E4D: /* PCI_CHIP_RV410_5E4D */
+      case 0x5E4F: /* PCI_CHIP_RV410_5E4F */
+      case 0x5A41: /* PCI_CHIP_RS400_5A41 */
+      case 0x5A42: /* PCI_CHIP_RS400_5A42 */
+      case 0x5A61: /* PCI_CHIP_RC410_5A61 */
+      case 0x5A62: /* PCI_CHIP_RC410_5A62 */
+      case 0x5954: /* PCI_CHIP_RS480_5954 */
+      case 0x5955: /* PCI_CHIP_RS480_5955 */
+      case 0x5974: /* PCI_CHIP_RS482_5974 */
+      case 0x5975: /* PCI_CHIP_RS482_5975 */
+      case 0x7100: /* PCI_CHIP_R520_7100 */
+      case 0x7101: /* PCI_CHIP_R520_7101 */
+      case 0x7102: /* PCI_CHIP_R520_7102 */
+      case 0x7103: /* PCI_CHIP_R520_7103 */
+      case 0x7104: /* PCI_CHIP_R520_7104 */
+      case 0x7105: /* PCI_CHIP_R520_7105 */
+      case 0x7106: /* PCI_CHIP_R520_7106 */
+      case 0x7108: /* PCI_CHIP_R520_7108 */
+      case 0x7109: /* PCI_CHIP_R520_7109 */
+      case 0x710A: /* PCI_CHIP_R520_710A */
+      case 0x710B: /* PCI_CHIP_R520_710B */
+      case 0x710C: /* PCI_CHIP_R520_710C */
+      case 0x710E: /* PCI_CHIP_R520_710E */
+      case 0x710F: /* PCI_CHIP_R520_710F */
+      case 0x7140: /* PCI_CHIP_RV515_7140 */
+      case 0x7141: /* PCI_CHIP_RV515_7141 */
+      case 0x7142: /* PCI_CHIP_RV515_7142 */
+      case 0x7143: /* PCI_CHIP_RV515_7143 */
+      case 0x7144: /* PCI_CHIP_RV515_7144 */
+      case 0x7145: /* PCI_CHIP_RV515_7145 */
+      case 0x7146: /* PCI_CHIP_RV515_7146 */
+      case 0x7147: /* PCI_CHIP_RV515_7147 */
+      case 0x7149: /* PCI_CHIP_RV515_7149 */
+      case 0x714A: /* PCI_CHIP_RV515_714A */
+      case 0x714B: /* PCI_CHIP_RV515_714B */
+      case 0x714C: /* PCI_CHIP_RV515_714C */
+      case 0x714D: /* PCI_CHIP_RV515_714D */
+      case 0x714E: /* PCI_CHIP_RV515_714E */
+      case 0x714F: /* PCI_CHIP_RV515_714F */
+      case 0x7151: /* PCI_CHIP_RV515_7151 */
+      case 0x7152: /* PCI_CHIP_RV515_7152 */
+      case 0x7153: /* PCI_CHIP_RV515_7153 */
+      case 0x715E: /* PCI_CHIP_RV515_715E */
+      case 0x715F: /* PCI_CHIP_RV515_715F */
+      case 0x7180: /* PCI_CHIP_RV515_7180 */
+      case 0x7181: /* PCI_CHIP_RV515_7181 */
+      case 0x7183: /* PCI_CHIP_RV515_7183 */
+      case 0x7186: /* PCI_CHIP_RV515_7186 */
+      case 0x7187: /* PCI_CHIP_RV515_7187 */
+      case 0x7188: /* PCI_CHIP_RV515_7188 */
+      case 0x718A: /* PCI_CHIP_RV515_718A */
+      case 0x718B: /* PCI_CHIP_RV515_718B */
+      case 0x718C: /* PCI_CHIP_RV515_718C */
+      case 0x718D: /* PCI_CHIP_RV515_718D */
+      case 0x718F: /* PCI_CHIP_RV515_718F */
+      case 0x7193: /* PCI_CHIP_RV515_7193 */
+      case 0x7196: /* PCI_CHIP_RV515_7196 */
+      case 0x719B: /* PCI_CHIP_RV515_719B */
+      case 0x719F: /* PCI_CHIP_RV515_719F */
+      case 0x7200: /* PCI_CHIP_RV515_7200 */
+      case 0x7210: /* PCI_CHIP_RV515_7210 */
+      case 0x7211: /* PCI_CHIP_RV515_7211 */
+      case 0x71C0: /* PCI_CHIP_RV530_71C0 */
+      case 0x71C1: /* PCI_CHIP_RV530_71C1 */
+      case 0x71C2: /* PCI_CHIP_RV530_71C2 */
+      case 0x71C3: /* PCI_CHIP_RV530_71C3 */
+      case 0x71C4: /* PCI_CHIP_RV530_71C4 */
+      case 0x71C5: /* PCI_CHIP_RV530_71C5 */
+      case 0x71C6: /* PCI_CHIP_RV530_71C6 */
+      case 0x71C7: /* PCI_CHIP_RV530_71C7 */
+      case 0x71CD: /* PCI_CHIP_RV530_71CD */
+      case 0x71CE: /* PCI_CHIP_RV530_71CE */
+      case 0x71D2: /* PCI_CHIP_RV530_71D2 */
+      case 0x71D4: /* PCI_CHIP_RV530_71D4 */
+      case 0x71D5: /* PCI_CHIP_RV530_71D5 */
+      case 0x71D6: /* PCI_CHIP_RV530_71D6 */
+      case 0x71DA: /* PCI_CHIP_RV530_71DA */
+      case 0x71DE: /* PCI_CHIP_RV530_71DE */
+      case 0x7281: /* PCI_CHIP_RV560_7281 */
+      case 0x7283: /* PCI_CHIP_RV560_7283 */
+      case 0x7287: /* PCI_CHIP_RV560_7287 */
+      case 0x7290: /* PCI_CHIP_RV560_7290 */
+      case 0x7291: /* PCI_CHIP_RV560_7291 */
+      case 0x7293: /* PCI_CHIP_RV560_7293 */
+      case 0x7297: /* PCI_CHIP_RV560_7297 */
+      case 0x7280: /* PCI_CHIP_RV570_7280 */
+      case 0x7288: /* PCI_CHIP_RV570_7288 */
+      case 0x7289: /* PCI_CHIP_RV570_7289 */
+      case 0x728B: /* PCI_CHIP_RV570_728B */
+      case 0x728C: /* PCI_CHIP_RV570_728C */
+      case 0x7240: /* PCI_CHIP_R580_7240 */
+      case 0x7243: /* PCI_CHIP_R580_7243 */
+      case 0x7244: /* PCI_CHIP_R580_7244 */
+      case 0x7245: /* PCI_CHIP_R580_7245 */
+      case 0x7246: /* PCI_CHIP_R580_7246 */
+      case 0x7247: /* PCI_CHIP_R580_7247 */
+      case 0x7248: /* PCI_CHIP_R580_7248 */
+      case 0x7249: /* PCI_CHIP_R580_7249 */
+      case 0x724A: /* PCI_CHIP_R580_724A */
+      case 0x724B: /* PCI_CHIP_R580_724B */
+      case 0x724C: /* PCI_CHIP_R580_724C */
+      case 0x724D: /* PCI_CHIP_R580_724D */
+      case 0x724E: /* PCI_CHIP_R580_724E */
+      case 0x724F: /* PCI_CHIP_R580_724F */
+      case 0x7284: /* PCI_CHIP_R580_7284 */
+      case 0x793F: /* PCI_CHIP_RS600_793F */
+      case 0x7941: /* PCI_CHIP_RS600_7941 */
+      case 0x7942: /* PCI_CHIP_RS600_7942 */
+      case 0x791E: /* PCI_CHIP_RS690_791E */
+      case 0x791F: /* PCI_CHIP_RS690_791F */
+      case 0x796C: /* PCI_CHIP_RS740_796C */
+      case 0x796D: /* PCI_CHIP_RS740_796D */
+      case 0x796E: /* PCI_CHIP_RS740_796E */
+      case 0x796F: /* PCI_CHIP_RS740_796F */
+	      return TRUE;
+      default:
+	      return FALSE;
+      }
 }
 
 #endif
diff --git a/src/glsl/glsl_parser.cpp b/src/glsl/glsl_parser.cpp
index 301c221..ad99eee 100644
--- a/src/glsl/glsl_parser.cpp
+++ b/src/glsl/glsl_parser.cpp
@@ -1,9 +1,9 @@
-/* A Bison parser, made by GNU Bison 2.4.3.  */
+/* A Bison parser, made by GNU Bison 2.4.2.  */
 
 /* Skeleton implementation for Bison's Yacc-like parsers in C
    
-      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-   2009, 2010 Free Software Foundation, Inc.
+      Copyright (C) 1984, 1989-1990, 2000-2006, 2009-2010 Free Software
+   Foundation, Inc.
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -45,7 +45,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.4.3"
+#define YYBISON_VERSION "2.4.2"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -2621,7 +2621,7 @@ YYLTYPE yylloc;
     YYLTYPE *yylsp;
 
     /* The locations where the error started and ended.  */
-    YYLTYPE yyerror_range[3];
+    YYLTYPE yyerror_range[2];
 
     YYSIZE_T yystacksize;
 
@@ -5084,7 +5084,7 @@ yyerrlab:
 #endif
     }
 
-  yyerror_range[1] = yylloc;
+  yyerror_range[0] = yylloc;
 
   if (yyerrstatus == 3)
     {
@@ -5121,7 +5121,7 @@ yyerrorlab:
   if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
 
-  yyerror_range[1] = yylsp[1-yylen];
+  yyerror_range[0] = yylsp[1-yylen];
   /* Do not reclaim the symbols of the rule which action triggered
      this YYERROR.  */
   YYPOPSTACK (yylen);
@@ -5155,7 +5155,7 @@ yyerrlab1:
       if (yyssp == yyss)
 	YYABORT;
 
-      yyerror_range[1] = *yylsp;
+      yyerror_range[0] = *yylsp;
       yydestruct ("Error: popping",
 		  yystos[yystate], yyvsp, yylsp, state);
       YYPOPSTACK (1);
@@ -5165,10 +5165,10 @@ yyerrlab1:
 
   *++yyvsp = yylval;
 
-  yyerror_range[2] = yylloc;
+  yyerror_range[1] = yylloc;
   /* Using YYLLOC is tempting, but would change the location of
      the lookahead.  YYLOC is available though.  */
-  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);
+  YYLLOC_DEFAULT (yyloc, (yyerror_range - 1), 2);
   *++yylsp = yyloc;
 
   /* Shift the error token.  */
diff --git a/src/glsl/glsl_parser.h b/src/glsl/glsl_parser.h
index 4a78037..266a4a2 100644
--- a/src/glsl/glsl_parser.h
+++ b/src/glsl/glsl_parser.h
@@ -1,9 +1,9 @@
-/* A Bison parser, made by GNU Bison 2.4.3.  */
+/* A Bison parser, made by GNU Bison 2.4.2.  */
 
 /* Skeleton interface for Bison's Yacc-like parsers in C
    
-      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
-   2009, 2010 Free Software Foundation, Inc.
+      Copyright (C) 1984, 1989-1990, 2000-2006, 2009-2010 Free Software
+   Foundation, Inc.
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
diff --git a/src/mesa/Makefile b/src/mesa/Makefile
index c41c38c..8b0756b 100644
--- a/src/mesa/Makefile
+++ b/src/mesa/Makefile
@@ -34,9 +34,9 @@ ES1_CPPFLAGS := -DFEATURE_ES1=1 $(DEFINES)
 ES2_CPPFLAGS := -DFEATURE_ES2=1 $(DEFINES)
 
 # append include dirs
-MESA_CPPFLAGS += $(INCLUDE_DIRS)
-ES1_CPPFLAGS += -I$(TOP)/src/mapi/es1api $(INCLUDE_DIRS)
-ES2_CPPFLAGS += -I$(TOP)/src/mapi/es2api $(INCLUDE_DIRS)
+MESA_CPPFLAGS += $(INCLUDE_DIRS) $(TALLOC_CFLAGS)
+ES1_CPPFLAGS += -I$(TOP)/src/mapi/es1api $(INCLUDE_DIRS) $(TALLOC_CFLAGS)
+ES2_CPPFLAGS += -I$(TOP)/src/mapi/es2api $(INCLUDE_DIRS) $(TALLOC_CFLAGS)
 
 # tidy compiler flags
 CFLAGS := $(filter-out $(DEFINES), $(CFLAGS))
diff --git a/src/mesa/drivers/common/meta.c b/src/mesa/drivers/common/meta.c
index a03cb68..20dda5f 100644
--- a/src/mesa/drivers/common/meta.c
+++ b/src/mesa/drivers/common/meta.c
@@ -1385,6 +1385,7 @@ _mesa_meta_Clear(GLcontext *ctx, GLbitfield buffers)
    struct vertex verts[4];
    /* save all state but scissor, pixel pack/unpack */
    GLbitfield metaSave = META_ALL - META_SCISSOR - META_PIXEL_STORE;
+   const GLuint stencilMax = (1 << ctx->DrawBuffer->Visual.stencilBits) - 1;
 
    if (buffers & BUFFER_BITS_COLOR) {
       /* if clearing color buffers, don't save/restore colormask */
@@ -1440,7 +1441,7 @@ _mesa_meta_Clear(GLcontext *ctx, GLbitfield buffers)
       _mesa_StencilOpSeparate(GL_FRONT_AND_BACK,
                               GL_REPLACE, GL_REPLACE, GL_REPLACE);
       _mesa_StencilFuncSeparate(GL_FRONT_AND_BACK, GL_ALWAYS,
-                                ctx->Stencil.Clear & 0x7fffffff,
+                                ctx->Stencil.Clear & stencilMax,
                                 ctx->Stencil.WriteMask[0]);
    }
    else {
diff --git a/src/mesa/drivers/dri/r200/r200_swtcl.c b/src/mesa/drivers/dri/r200/r200_swtcl.c
index dbf4ad4..160e7e7 100644
--- a/src/mesa/drivers/dri/r200/r200_swtcl.c
+++ b/src/mesa/drivers/dri/r200/r200_swtcl.c
@@ -319,10 +319,9 @@ static INLINE GLuint reduced_hw_prim( GLcontext *ctx, GLuint prim)
 {
    switch (prim) {
    case GL_POINTS:
-      return (ctx->Point.PointSprite ||
-	 ((ctx->_TriangleCaps & (DD_POINT_SIZE | DD_POINT_ATTEN)) &&
-	 !(ctx->_TriangleCaps & (DD_POINT_SMOOTH)))) ?
-	 R200_VF_PRIM_POINT_SPRITES : R200_VF_PRIM_POINTS;
+      return (((R200_CONTEXT(ctx))->radeon.radeonScreen->drmSupportsPointSprites &&
+              !(ctx->_TriangleCaps & DD_POINT_SMOOTH)) ?
+	 R200_VF_PRIM_POINT_SPRITES : R200_VF_PRIM_POINTS);
    case GL_LINES:
    /* fallthrough */
    case GL_LINE_LOOP:
@@ -613,6 +612,9 @@ static void r200RasterPrimitive( GLcontext *ctx, GLuint hwprim )
    r200ContextPtr rmesa = R200_CONTEXT(ctx);
 
    radeon_prepare_render(&rmesa->radeon);
+   if (rmesa->radeon.NewGLState)
+      r200ValidateState( ctx );
+
 
    if (rmesa->radeon.swtcl.hw_primitive != hwprim) {
       /* need to disable perspective-correct texturing for point sprites */
diff --git a/src/mesa/drivers/dri/r200/r200_tcl.c b/src/mesa/drivers/dri/r200/r200_tcl.c
index 4ae0f30..2743997 100644
--- a/src/mesa/drivers/dri/r200/r200_tcl.c
+++ b/src/mesa/drivers/dri/r200/r200_tcl.c
@@ -68,9 +68,8 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #define HAVE_ELTS        1
 
 
-#define HW_POINTS           ((ctx->Point.PointSprite || \
-				((ctx->_TriangleCaps & (DD_POINT_SIZE | DD_POINT_ATTEN)) && \
-	 			!(ctx->_TriangleCaps & (DD_POINT_SMOOTH)))) ? \
+#define HW_POINTS           (((R200_CONTEXT(ctx))->radeon.radeonScreen->drmSupportsPointSprites && \
+			      !(ctx->_TriangleCaps & DD_POINT_SMOOTH)) ? \
 				R200_VF_PRIM_POINT_SPRITES : R200_VF_PRIM_POINTS)
 #define HW_LINES            R200_VF_PRIM_LINES
 #define HW_LINE_LOOP        0
@@ -265,6 +264,8 @@ void r200TclPrimitive( GLcontext *ctx,
    GLuint newprim = hw_prim | R200_VF_TCL_OUTPUT_VTX_ENABLE;
 
    radeon_prepare_render(&rmesa->radeon);
+   if (rmesa->radeon.NewGLState)
+      r200ValidateState( ctx );
 
    if (newprim != rmesa->tcl.hw_primitive ||
        !discrete_prim[hw_prim&0xf]) {
diff --git a/src/mesa/drivers/dri/r300/compiler/r300_fragprog_emit.c b/src/mesa/drivers/dri/r300/compiler/r300_fragprog_emit.c
index 3b2b06f..9f19f8f 100644
--- a/src/mesa/drivers/dri/r300/compiler/r300_fragprog_emit.c
+++ b/src/mesa/drivers/dri/r300/compiler/r300_fragprog_emit.c
@@ -76,6 +76,9 @@ static void use_temporary(struct r300_fragment_program_code *code, unsigned int
 
 static unsigned int use_source(struct r300_fragment_program_code* code, struct radeon_pair_instruction_source src)
 {
+	if (!src.Used)
+		return 0;
+
 	if (src.File == RC_FILE_CONSTANT) {
 		return src.Index | (1 << 5);
 	} else if (src.File == RC_FILE_TEMPORARY) {
diff --git a/src/mesa/drivers/dri/r300/compiler/r300_fragprog_swizzle.c b/src/mesa/drivers/dri/r300/compiler/r300_fragprog_swizzle.c
index caa48fe..1aa40c7 100644
--- a/src/mesa/drivers/dri/r300/compiler/r300_fragprog_swizzle.c
+++ b/src/mesa/drivers/dri/r300/compiler/r300_fragprog_swizzle.c
@@ -94,6 +94,10 @@ static const struct swizzle_data* lookup_native_swizzle(unsigned int swizzle)
  */
 static int r300_swizzle_is_native(rc_opcode opcode, struct rc_src_register reg)
 {
+	const struct swizzle_data* sd;
+	unsigned int relevant;
+	int j;
+
 	if (reg.Abs)
 		reg.Negate = RC_MASK_NONE;
 
@@ -117,8 +121,7 @@ static int r300_swizzle_is_native(rc_opcode opcode, struct rc_src_register reg)
 		return 1;
 	}
 
-	unsigned int relevant = 0;
-	int j;
+	relevant = 0;
 
 	for(j = 0; j < 3; ++j)
 		if (GET_SWZ(reg.Swizzle, j) != RC_SWIZZLE_UNUSED)
@@ -127,7 +130,8 @@ static int r300_swizzle_is_native(rc_opcode opcode, struct rc_src_register reg)
 	if ((reg.Negate & relevant) && ((reg.Negate & relevant) != relevant))
 		return 0;
 
-	if (!lookup_native_swizzle(reg.Swizzle))
+	sd = lookup_native_swizzle(reg.Swizzle);
+	if (!sd || (reg.File == RC_FILE_PRESUB && sd->srcp_stride == 0))
 		return 0;
 
 	return 1;
@@ -200,7 +204,7 @@ unsigned int r300FPTranslateRGBSwizzle(unsigned int src, unsigned int swizzle)
 {
 	const struct swizzle_data* sd = lookup_native_swizzle(swizzle);
 
-	if (!sd) {
+	if (!sd || (src == RC_PAIR_PRESUB_SRC && sd->srcp_stride == 0)) {
 		fprintf(stderr, "Not a native swizzle: %08x\n", swizzle);
 		return 0;
 	}
diff --git a/src/mesa/drivers/dri/r300/compiler/r3xx_fragprog.c b/src/mesa/drivers/dri/r300/compiler/r3xx_fragprog.c
index 4793f33..d9a398d 100644
--- a/src/mesa/drivers/dri/r300/compiler/r3xx_fragprog.c
+++ b/src/mesa/drivers/dri/r300/compiler/r3xx_fragprog.c
@@ -54,6 +54,8 @@ static void rc_rewrite_depth_out(struct radeon_compiler *cc, void *user)
 
 	for (rci = c->Base.Program.Instructions.Next; rci != &c->Base.Program.Instructions; rci = rci->Next) {
 		struct rc_sub_instruction * inst = &rci->U.I;
+		unsigned i;
+		const struct rc_opcode_info *info = rc_get_opcode_info(inst->Opcode);
 
 		if (inst->DstReg.File != RC_FILE_OUTPUT || inst->DstReg.Index != c->OutputDepth)
 			continue;
@@ -65,27 +67,12 @@ static void rc_rewrite_depth_out(struct radeon_compiler *cc, void *user)
 			continue;
 		}
 
-		switch (inst->Opcode) {
-			case RC_OPCODE_FRC:
-			case RC_OPCODE_MOV:
-				inst->SrcReg[0] = lmul_swizzle(RC_SWIZZLE_ZZZZ, inst->SrcReg[0]);
-				break;
-			case RC_OPCODE_ADD:
-			case RC_OPCODE_MAX:
-			case RC_OPCODE_MIN:
-			case RC_OPCODE_MUL:
-				inst->SrcReg[0] = lmul_swizzle(RC_SWIZZLE_ZZZZ, inst->SrcReg[0]);
-				inst->SrcReg[1] = lmul_swizzle(RC_SWIZZLE_ZZZZ, inst->SrcReg[1]);
-				break;
-			case RC_OPCODE_CMP:
-			case RC_OPCODE_MAD:
-				inst->SrcReg[0] = lmul_swizzle(RC_SWIZZLE_ZZZZ, inst->SrcReg[0]);
-				inst->SrcReg[1] = lmul_swizzle(RC_SWIZZLE_ZZZZ, inst->SrcReg[1]);
-				inst->SrcReg[2] = lmul_swizzle(RC_SWIZZLE_ZZZZ, inst->SrcReg[2]);
-				break;
-			default:
-				// Scalar instructions needn't be reswizzled
-				break;
+		if (!info->IsComponentwise) {
+			continue;
+		}
+
+		for (i = 0; i < info->NumSrcRegs; i++) {
+			inst->SrcReg[i] = lmul_swizzle(RC_SWIZZLE_ZZZZ, inst->SrcReg[i]);
 		}
 	}
 }
diff --git a/src/mesa/drivers/dri/r300/compiler/r500_fragprog_emit.c b/src/mesa/drivers/dri/r300/compiler/r500_fragprog_emit.c
index efa3bb5..abbf704 100644
--- a/src/mesa/drivers/dri/r300/compiler/r500_fragprog_emit.c
+++ b/src/mesa/drivers/dri/r300/compiler/r500_fragprog_emit.c
@@ -200,6 +200,9 @@ static void use_temporary(struct r500_fragment_program_code* code, unsigned int
 
 static unsigned int use_source(struct r500_fragment_program_code* code, struct radeon_pair_instruction_source src)
 {
+	if (!src.Used)
+		return 0;
+
 	if (src.File == RC_FILE_CONSTANT) {
 		return src.Index | 0x100;
 	} else if (src.File == RC_FILE_TEMPORARY) {
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_optimize.c b/src/mesa/drivers/dri/r300/compiler/radeon_optimize.c
index 3be50b9..bebe806 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_optimize.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_optimize.c
@@ -566,6 +566,7 @@ static int presub_helper(
 		for(i = 0; i < info->NumSrcRegs; i++) {
 			unsigned int mask = src_reads_dst_mask(
 				inst->U.I.SrcReg[i], s->Inst->U.I.DstReg);
+			struct rc_src_register src = inst->U.I.SrcReg[i];
 			/* XXX We could be more aggressive here using
 			 * presubtract.  It is okay if SrcReg[i] only reads
 			 * from some of the mask components. */
@@ -577,6 +578,11 @@ static int presub_helper(
 					continue;
 				}
 			}
+			src.File = RC_FILE_PRESUB;
+			if (!c->SwizzleCaps->IsNative(inst->U.I.Opcode, src)){
+				can_remove = 0;
+				break;
+			}
 			if (cant_sub || !can_use_presub) {
 				can_remove = 0;
 				break;
@@ -635,7 +641,9 @@ static void presub_replace_add(struct peephole_state *s,
 	inst->U.I.SrcReg[src_index].Index = presub_opcode;
 }
 
-static int is_presub_candidate(struct rc_instruction * inst)
+static int is_presub_candidate(
+	struct radeon_compiler * c,
+	struct rc_instruction * inst)
 {
 	const struct rc_opcode_info * info = rc_get_opcode_info(inst->U.I.Opcode);
 	unsigned int i;
@@ -644,7 +652,12 @@ static int is_presub_candidate(struct rc_instruction * inst)
 		return 0;
 
 	for(i = 0; i < info->NumSrcRegs; i++) {
-		if (src_reads_dst_mask(inst->U.I.SrcReg[i], inst->U.I.DstReg))
+		struct rc_src_register src = inst->U.I.SrcReg[i];
+		if (src_reads_dst_mask(src, inst->U.I.DstReg))
+			return 0;
+
+		src.File = RC_FILE_PRESUB;
+		if (!c->SwizzleCaps->IsNative(inst->U.I.Opcode, src))
 			return 0;
 	}
 	return 1;
@@ -659,7 +672,7 @@ static int peephole_add_presub_add(
 	unsigned int i;
 	struct peephole_state s;
 
-	if (!is_presub_candidate(inst_add))
+	if (!is_presub_candidate(c, inst_add))
 		return 0;
 
 	if (inst_add->U.I.SrcReg[0].Swizzle != inst_add->U.I.SrcReg[1].Swizzle)
@@ -726,7 +739,7 @@ static int peephole_add_presub_inv(
 	unsigned int i, swz, mask;
 	struct peephole_state s;
 
-	if (!is_presub_candidate(inst_add))
+	if (!is_presub_candidate(c, inst_add))
 		return 0;
 
 	mask = inst_add->U.I.DstReg.WriteMask;
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_pair_regalloc.c b/src/mesa/drivers/dri/r300/compiler/radeon_pair_regalloc.c
index c738455..126b50b 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_pair_regalloc.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_pair_regalloc.c
@@ -66,10 +66,13 @@ struct regalloc_state {
 	struct hardware_register * HwTemporary;
 	unsigned int NumHwTemporaries;
 	/**
-	 * If an instruction is inside of a loop, end_loop will be the
-	 * IP of the ENDLOOP instruction, otherwise end_loop will be 0
+	 * If an instruction is inside of a loop, EndLoop will be the
+	 * IP of the ENDLOOP instruction, and BeginLoop will be the IP
+	 * of the BGNLOOP instruction.  Otherwise, EndLoop and BeginLoop
+	 * will be -1.
 	 */
-	int end_loop;
+	int EndLoop;
+	int BeginLoop;
 };
 
 static void print_live_intervals(struct live_intervals * src)
@@ -180,11 +183,13 @@ static void scan_callback(void * data, struct rc_instruction * inst,
 		reg->Used = 1;
 		if (file == RC_FILE_INPUT)
 			reg->Live.Start = -1;
+		else if (s->BeginLoop >= 0)
+			reg->Live.Start = s->BeginLoop;
 		else
 			reg->Live.Start = inst->IP;
 		reg->Live.End = inst->IP;
-	} else if (s->end_loop)
-		reg->Live.End = s->end_loop;
+	} else if (s->EndLoop >= 0)
+		reg->Live.End = s->EndLoop;
 	else if (inst->IP > reg->Live.End)
 		reg->Live.End = inst->IP;
 }
@@ -195,6 +200,8 @@ static void compute_live_intervals(struct radeon_compiler *c,
 	memset(s, 0, sizeof(*s));
 	s->C = c;
 	s->NumHwTemporaries = c->max_temp_regs;
+	s->BeginLoop = -1;
+	s->EndLoop = -1;
 	s->HwTemporary =
 		memory_pool_malloc(&c->Pool,
 				   s->NumHwTemporaries * sizeof(struct hardware_register));
@@ -207,8 +214,10 @@ static void compute_live_intervals(struct radeon_compiler *c,
 	    inst = inst->Next) {
 
 		/* For all instructions inside of a loop, the ENDLOOP
-		 * instruction is used as the end of the live interval. */
-		if (inst->U.I.Opcode == RC_OPCODE_BGNLOOP && !s->end_loop) {
+		 * instruction is used as the end of the live interval and
+		 * the BGNLOOP instruction is used as the beginning. */
+		if (inst->U.I.Opcode == RC_OPCODE_BGNLOOP && s->EndLoop < 0) {
+			s->BeginLoop = inst->IP;
 			int loops = 1;
 			struct rc_instruction * tmp;
 			for(tmp = inst->Next;
@@ -219,15 +228,17 @@ static void compute_live_intervals(struct radeon_compiler *c,
 				} else if (tmp->U.I.Opcode
 							== RC_OPCODE_ENDLOOP) {
 					if(!--loops) {
-						s->end_loop = tmp->IP;
+						s->EndLoop = tmp->IP;
 						break;
 					}
 				}
 			}
 		}
 
-		if (inst->IP == s->end_loop)
-			s->end_loop = 0;
+		if (inst->IP == s->EndLoop) {
+			s->EndLoop = -1;
+			s->BeginLoop = -1;
+		}
 
 		rc_for_all_reads_mask(inst, scan_callback, s);
 		rc_for_all_writes_mask(inst, scan_callback, s);
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_pair_schedule.c b/src/mesa/drivers/dri/r300/compiler/radeon_pair_schedule.c
index 7ab2df3..0b003d7 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_pair_schedule.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_pair_schedule.c
@@ -126,15 +126,6 @@ static struct reg_value ** get_reg_valuep(struct schedule_state * s,
 	return &s->Temporary[index].Values[chan];
 }
 
-static struct reg_value * get_reg_value(struct schedule_state * s,
-		rc_register_file file, unsigned int index, unsigned int chan)
-{
-	struct reg_value ** pv = get_reg_valuep(s, file, index, chan);
-	if (!pv)
-		return 0;
-	return *pv;
-}
-
 static void add_inst_to_list(struct schedule_instruction ** list, struct schedule_instruction * inst)
 {
 	inst->NextReady = *list;
@@ -602,12 +593,13 @@ static void scan_read(void * data, struct rc_instruction * inst,
 		rc_register_file file, unsigned int index, unsigned int chan)
 {
 	struct schedule_state * s = data;
-	struct reg_value * v = get_reg_value(s, file, index, chan);
+	struct reg_value ** v = get_reg_valuep(s, file, index, chan);
+	struct reg_value_reader * reader;
 
 	if (!v)
 		return;
 
-	if (v->Writer == s->Current) {
+	if (*v && (*v)->Writer == s->Current) {
 		/* The instruction reads and writes to a register component.
 		 * In this case, we only want to increment dependencies by one.
 		 */
@@ -616,18 +608,30 @@ static void scan_read(void * data, struct rc_instruction * inst,
 
 	DBG("%i: read %i[%i] chan %i\n", s->Current->Instruction->IP, file, index, chan);
 
-	struct reg_value_reader * reader = memory_pool_malloc(&s->C->Pool, sizeof(*reader));
+	reader = memory_pool_malloc(&s->C->Pool, sizeof(*reader));
 	reader->Reader = s->Current;
-	reader->Next = v->Readers;
-	v->Readers = reader;
-	v->NumReaders++;
-
-	s->Current->NumDependencies++;
+	if (!*v) {
+		/* In this situation, the instruction reads from a register
+		 * that hasn't been written to or read from in the current
+		 * block. */
+		*v = memory_pool_malloc(&s->C->Pool, sizeof(struct reg_value));
+		memset(*v, 0, sizeof(struct reg_value));
+		(*v)->Readers = reader;
+	} else {
+		reader->Next = (*v)->Readers;
+		(*v)->Readers = reader;
+		/* Only update the current instruction's dependencies if the
+		 * register it reads from has been written to in this block. */
+		if ((*v)->Writer) {
+			s->Current->NumDependencies++;
+		}
+	}
+	(*v)->NumReaders++;
 
 	if (s->Current->NumReadValues >= 12) {
 		rc_error(s->C, "%s: NumReadValues overflow\n", __FUNCTION__);
 	} else {
-		s->Current->ReadValues[s->Current->NumReadValues++] = v;
+		s->Current->ReadValues[s->Current->NumReadValues++] = *v;
 	}
 }
 
diff --git a/src/mesa/drivers/dri/r300/compiler/radeon_pair_translate.c b/src/mesa/drivers/dri/r300/compiler/radeon_pair_translate.c
index ff82584..840c7a5 100644
--- a/src/mesa/drivers/dri/r300/compiler/radeon_pair_translate.c
+++ b/src/mesa/drivers/dri/r300/compiler/radeon_pair_translate.c
@@ -278,9 +278,12 @@ static void set_pair_instruction(struct r300_fragment_program_compiler *c,
 			pair->RGB.DestIndex = inst->DstReg.Index;
 			pair->RGB.WriteMask |= inst->DstReg.WriteMask & RC_MASK_XYZ;
 		}
+
 		if (needalpha) {
-			pair->Alpha.DestIndex = inst->DstReg.Index;
 			pair->Alpha.WriteMask |= GET_BIT(inst->DstReg.WriteMask, 3);
+			if (pair->Alpha.WriteMask) {
+				pair->Alpha.DestIndex = inst->DstReg.Index;
+			}
 		}
 	}
 
diff --git a/src/mesa/drivers/dri/r300/r300_draw.c b/src/mesa/drivers/dri/r300/r300_draw.c
index 5ae9f49..767778b 100644
--- a/src/mesa/drivers/dri/r300/r300_draw.c
+++ b/src/mesa/drivers/dri/r300/r300_draw.c
@@ -717,6 +717,10 @@ static void r300DrawPrims(GLcontext *ctx,
 			 GLuint max_index)
 {
 	GLboolean retval;
+	struct r300_context *r300 = R300_CONTEXT(ctx);
+	radeonContextPtr radeon = &r300->radeon;
+
+	radeon_prepare_render(radeon);
 
 	/* This check should get folded into just the places that
 	 * min/max index are really needed.
diff --git a/src/mesa/drivers/dri/r300/r300_render.c b/src/mesa/drivers/dri/r300/r300_render.c
index cf89ab7..bb8f914 100644
--- a/src/mesa/drivers/dri/r300/r300_render.c
+++ b/src/mesa/drivers/dri/r300/r300_render.c
@@ -327,8 +327,6 @@ void r300RunRenderPrimitive(GLcontext * ctx, int start, int end, int prim)
 	BATCH_LOCALS(&rmesa->radeon);
 	int type, num_verts;
 
-	radeon_prepare_render(&rmesa->radeon);
-
 	type = r300PrimitiveType(rmesa, prim);
 	num_verts = r300NumVerts(rmesa, end - start, prim);
 
diff --git a/src/mesa/drivers/dri/r600/evergreen_render.c b/src/mesa/drivers/dri/r600/evergreen_render.c
index 27089bf..1fa53d7 100644
--- a/src/mesa/drivers/dri/r600/evergreen_render.c
+++ b/src/mesa/drivers/dri/r600/evergreen_render.c
@@ -909,6 +909,10 @@ static void evergreenDrawPrims(GLcontext *ctx,
 {
 	GLboolean retval = GL_FALSE;
 
+	context_t *context = EVERGREEN_CONTEXT(ctx);
+	radeonContextPtr radeon = &context->radeon;
+	radeon_prepare_render(radeon);
+
 	/* This check should get folded into just the places that
 	 * min/max index are really needed.
 	 */
diff --git a/src/mesa/drivers/dri/radeon/radeon_common_context.c b/src/mesa/drivers/dri/radeon/radeon_common_context.c
index 85e4988..d4c7864 100644
--- a/src/mesa/drivers/dri/radeon/radeon_common_context.c
+++ b/src/mesa/drivers/dri/radeon/radeon_common_context.c
@@ -251,9 +251,9 @@ GLboolean radeonInitContext(radeonContextPtr radeon,
 			radeon->texture_rect_row_align = 512;
 			radeon->texture_compressed_row_align = 512;
 		} else {
-			radeon->texture_row_align = 256;
-			radeon->texture_rect_row_align = 256;
-			radeon->texture_compressed_row_align = 256;
+			radeon->texture_row_align = radeon->radeonScreen->group_bytes;
+			radeon->texture_rect_row_align = radeon->radeonScreen->group_bytes;
+			radeon->texture_compressed_row_align = radeon->radeonScreen->group_bytes;
 		}
 	} else if (IS_R200_CLASS(radeon->radeonScreen) ||
 		   IS_R100_CLASS(radeon->radeonScreen)) {
@@ -521,6 +521,7 @@ void radeon_prepare_render(radeonContextPtr radeon)
     __DRIcontext *driContext = radeon->dri.context;
     __DRIdrawable *drawable;
     __DRIscreen *screen;
+    struct radeon_framebuffer *draw;
 
     screen = driContext->driScreenPriv;
     if (!screen->dri2.loader)
@@ -531,9 +532,10 @@ void radeon_prepare_render(radeonContextPtr radeon)
 	if (drawable->lastStamp != drawable->dri2.stamp)
 	    radeon_update_renderbuffers(driContext, drawable, GL_FALSE);
 
-	/* Intel driver does the equivalent of this, no clue if it is needed:
-	 * radeon_draw_buffer(radeon->glCtx, &(drawable->driverPrivate)->base);
-	 */
+	/* Intel driver does the equivalent of this, no clue if it is needed:*/
+	draw = drawable->driverPrivate;
+	radeon_draw_buffer(radeon->glCtx, &draw->base);
+
 	driContext->dri2.draw_stamp = drawable->dri2.stamp;
     }
 
@@ -738,10 +740,9 @@ radeon_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable,
 						buffers[i].flags);
 
 			if (bo == NULL) {
-
 				fprintf(stderr, "failed to attach %s %d\n",
 					regname, buffers[i].name);
-
+				continue;
 			}
 
 			ret = radeon_bo_get_tiling(bo, &tiling_flags, &pitch);
diff --git a/src/mesa/drivers/dri/radeon/radeon_screen.c b/src/mesa/drivers/dri/radeon/radeon_screen.c
index 2ea77e5..0ca052d 100644
--- a/src/mesa/drivers/dri/radeon/radeon_screen.c
+++ b/src/mesa/drivers/dri/radeon/radeon_screen.c
@@ -1138,6 +1138,8 @@ radeonCreateScreen( __DRIscreen *sPriv )
    else
 	   screen->chip_flags |= RADEON_CLASS_R600;
 
+   /* set group bytes for r6xx+ */
+   screen->group_bytes = 256;
    screen->cpp = dri_priv->bpp / 8;
    screen->AGPMode = dri_priv->AGPMode;
 
@@ -1382,7 +1384,8 @@ radeonCreateScreen2(__DRIscreen *sPriv)
    else
 	   screen->chip_flags |= RADEON_CLASS_R600;
 
-   /* r6xx+ tiling */
+   /* r6xx+ tiling, default to 256 group bytes */
+   screen->group_bytes = 256;
    if (IS_R600_CLASS(screen) && (sPriv->drm_version.minor >= 6)) {
 	   ret = radeonGetParam(sPriv, RADEON_INFO_TILE_CONFIG, &temp);
 	   if (ret)
diff --git a/src/mesa/drivers/dri/radeon/radeon_swtcl.c b/src/mesa/drivers/dri/radeon/radeon_swtcl.c
index 29defe7..0a81843 100644
--- a/src/mesa/drivers/dri/radeon/radeon_swtcl.c
+++ b/src/mesa/drivers/dri/radeon/radeon_swtcl.c
@@ -412,6 +412,8 @@ static GLboolean radeon_run_render( GLcontext *ctx,
       return GL_TRUE;		
 
    radeon_prepare_render(&rmesa->radeon);
+   if (rmesa->radeon.NewGLState)
+      radeonValidateState( ctx );
 
    tnl->Driver.Render.Start( ctx );
 
diff --git a/src/mesa/drivers/dri/radeon/radeon_tcl.c b/src/mesa/drivers/dri/radeon/radeon_tcl.c
index 5e1718f..ded3ebe 100644
--- a/src/mesa/drivers/dri/radeon/radeon_tcl.c
+++ b/src/mesa/drivers/dri/radeon/radeon_tcl.c
@@ -253,6 +253,8 @@ void radeonTclPrimitive( GLcontext *ctx,
    GLuint newprim = hw_prim | RADEON_CP_VC_CNTL_TCL_ENABLE;
 
    radeon_prepare_render(&rmesa->radeon);
+   if (rmesa->radeon.NewGLState)
+      radeonValidateState( ctx );
 
    if (newprim != rmesa->tcl.hw_primitive ||
        !discrete_prim[hw_prim&0xf]) {
diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index 4797f29..d9eaada 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -55,6 +55,13 @@
 
 
 /**
+ * Used as a placeholder for buffer objects between glGenBuffers() and
+ * glBindBuffer() so that glIsBuffer() can work correctly.
+ */
+static struct gl_buffer_object DummyBufferObject;
+
+
+/**
  * Return pointer to address of a buffer object target.
  * \param ctx  the GL context
  * \param target  the buffer object target to be retrieved.
@@ -554,6 +561,9 @@ _mesa_copy_buffer_subdata(GLcontext *ctx,
 void
 _mesa_init_buffer_objects( GLcontext *ctx )
 {
+   memset(&DummyBufferObject, 0, sizeof(DummyBufferObject));
+   DummyBufferObject.RefCount = 1000*1000*1000; /* never delete */
+
    _mesa_reference_buffer_object(ctx, &ctx->Array.ArrayBufferObj,
                                  ctx->Shared->NullBufferObj);
    _mesa_reference_buffer_object(ctx, &ctx->Array.ElementArrayBufferObj,
@@ -611,8 +621,10 @@ bind_buffer_object(GLcontext *ctx, GLenum target, GLuint buffer)
    else {
       /* non-default buffer object */
       newBufObj = _mesa_lookup_bufferobj(ctx, buffer);
-      if (!newBufObj) {
-         /* if this is a new buffer object id, allocate a buffer object now */
+      if (!newBufObj || newBufObj == &DummyBufferObject) {
+         /* If this is a new buffer object id, or one which was generated but
+          * never used before, allocate a buffer object now.
+          */
          ASSERT(ctx->Driver.NewBufferObject);
          newBufObj = ctx->Driver.NewBufferObject(ctx, buffer, target);
          if (!newBufObj) {
@@ -992,7 +1004,7 @@ _mesa_DeleteBuffersARB(GLsizei n, const GLuint *ids)
          struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
          GLuint j;
 
-         ASSERT(bufObj->Name == ids[i]);
+         ASSERT(bufObj->Name == ids[i] || bufObj == &DummyBufferObject);
 
          if (_mesa_bufferobj_mapped(bufObj)) {
             /* if mapped, unmap it now */
@@ -1033,7 +1045,7 @@ _mesa_DeleteBuffersARB(GLsizei n, const GLuint *ids)
          }
 
          /* The ID is immediately freed for re-use */
-         _mesa_HashRemove(ctx->Shared->BufferObjects, bufObj->Name);
+         _mesa_HashRemove(ctx->Shared->BufferObjects, ids[i]);
          _mesa_reference_buffer_object(ctx, &bufObj, NULL);
       }
    }
@@ -1072,18 +1084,10 @@ _mesa_GenBuffersARB(GLsizei n, GLuint *buffer)
 
    first = _mesa_HashFindFreeKeyBlock(ctx->Shared->BufferObjects, n);
 
-   /* Allocate new, empty buffer objects and return identifiers */
+   /* Insert the ID and pointer to dummy buffer object into hash table */
    for (i = 0; i < n; i++) {
-      struct gl_buffer_object *bufObj;
-      GLuint name = first + i;
-      GLenum target = 0;
-      bufObj = ctx->Driver.NewBufferObject( ctx, name, target );
-      if (!bufObj) {
-         _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
-         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGenBuffersARB");
-         return;
-      }
-      _mesa_HashInsert(ctx->Shared->BufferObjects, first + i, bufObj);
+      _mesa_HashInsert(ctx->Shared->BufferObjects, first + i,
+                       &DummyBufferObject);
       buffer[i] = first + i;
    }
 
@@ -1109,7 +1113,7 @@ _mesa_IsBufferARB(GLuint id)
    bufObj = _mesa_lookup_bufferobj(ctx, id);
    _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
 
-   return bufObj ? GL_TRUE : GL_FALSE;
+   return bufObj && bufObj != &DummyBufferObject;
 }
 
 
diff --git a/src/mesa/main/formats.c b/src/mesa/main/formats.c
index 9db9f1c..c3fe8a3 100644
--- a/src/mesa/main/formats.c
+++ b/src/mesa/main/formats.c
@@ -1109,6 +1109,7 @@ _mesa_format_to_type_and_comps(gl_format format,
    case MESA_FORMAT_ARGB8888:
    case MESA_FORMAT_ARGB8888_REV:
    case MESA_FORMAT_XRGB8888:
+   case MESA_FORMAT_XRGB8888_REV:
       *datatype = GL_UNSIGNED_BYTE;
       *comps = 4;
       return;
@@ -1135,6 +1136,11 @@ _mesa_format_to_type_and_comps(gl_format format,
       *comps = 4;
       return;
 
+   case MESA_FORMAT_RGBA5551:
+      *datatype = GL_UNSIGNED_SHORT_5_5_5_1;
+      *comps = 4;
+      return;
+
    case MESA_FORMAT_AL88:
    case MESA_FORMAT_AL88_REV:
       *datatype = GL_UNSIGNED_BYTE;
@@ -1156,6 +1162,7 @@ _mesa_format_to_type_and_comps(gl_format format,
    case MESA_FORMAT_L8:
    case MESA_FORMAT_I8:
    case MESA_FORMAT_CI8:
+   case MESA_FORMAT_S8:
       *datatype = GL_UNSIGNED_BYTE;
       *comps = 1;
       return;
@@ -1201,12 +1208,26 @@ _mesa_format_to_type_and_comps(gl_format format,
       *comps = 2;
       return;
 
+   case MESA_FORMAT_SIGNED_R8:
+      *datatype = GL_BYTE;
+      *comps = 1;
+      return;
+   case MESA_FORMAT_SIGNED_RG88:
+      *datatype = GL_BYTE;
+      *comps = 2;
+      return;
    case MESA_FORMAT_SIGNED_RGBA8888:
    case MESA_FORMAT_SIGNED_RGBA8888_REV:
+   case MESA_FORMAT_SIGNED_RGBX8888:
       *datatype = GL_BYTE;
       *comps = 4;
       return;
 
+   case MESA_FORMAT_RGBA_16:
+      *datatype = GL_UNSIGNED_SHORT;
+      *comps = 4;
+      return;
+
    case MESA_FORMAT_SIGNED_R_16:
       *datatype = GL_SHORT;
       *comps = 1;
@@ -1331,9 +1352,14 @@ _mesa_format_to_type_and_comps(gl_format format,
       *comps = 4;
       return;
 
-
+   case MESA_FORMAT_NONE:
+   case MESA_FORMAT_COUNT:
+   /* For debug builds, warn if any formats are not handled */
+#ifndef DEBUG
    default:
-      _mesa_problem(NULL, "bad format in _mesa_format_to_type_and_comps");
+#endif
+      _mesa_problem(NULL, "bad format %s in _mesa_format_to_type_and_comps",
+                    _mesa_get_format_name(format));
       *datatype = 0;
       *comps = 1;
    }
diff --git a/src/mesa/main/imports.c b/src/mesa/main/imports.c
index 46e5c93..13dabde 100644
--- a/src/mesa/main/imports.c
+++ b/src/mesa/main/imports.c
@@ -88,7 +88,8 @@ _mesa_align_malloc(size_t bytes, unsigned long alignment)
 #if defined(HAVE_POSIX_MEMALIGN)
    void *mem;
    int err = posix_memalign(& mem, alignment, bytes);
-   (void) err;
+   if (err)
+      return NULL;
    return mem;
 #elif defined(_WIN32) && defined(_MSC_VER)
    return _aligned_malloc(bytes, alignment);
diff --git a/src/mesa/main/mipmap.c b/src/mesa/main/mipmap.c
index 3d1a4c4..71aa8c2 100644
--- a/src/mesa/main/mipmap.c
+++ b/src/mesa/main/mipmap.c
@@ -288,6 +288,54 @@ do_row(GLenum datatype, GLuint comps, GLint srcWidth,
          dst[i] = (rowA[j] + rowA[k] + rowB[j] + rowB[k]) / 4;
       }
    }
+
+   else if (datatype == GL_SHORT && comps == 4) {
+      GLuint i, j, k;
+      const GLshort(*rowA)[4] = (const GLshort(*)[4]) srcRowA;
+      const GLshort(*rowB)[4] = (const GLshort(*)[4]) srcRowB;
+      GLshort(*dst)[4] = (GLshort(*)[4]) dstRow;
+      for (i = j = 0, k = k0; i < (GLuint) dstWidth;
+           i++, j += colStride, k += colStride) {
+         dst[i][0] = (rowA[j][0] + rowA[k][0] + rowB[j][0] + rowB[k][0]) / 4;
+         dst[i][1] = (rowA[j][1] + rowA[k][1] + rowB[j][1] + rowB[k][1]) / 4;
+         dst[i][2] = (rowA[j][2] + rowA[k][2] + rowB[j][2] + rowB[k][2]) / 4;
+         dst[i][3] = (rowA[j][3] + rowA[k][3] + rowB[j][3] + rowB[k][3]) / 4;
+      }
+   }
+   else if (datatype == GL_SHORT && comps == 3) {
+      GLuint i, j, k;
+      const GLshort(*rowA)[3] = (const GLshort(*)[3]) srcRowA;
+      const GLshort(*rowB)[3] = (const GLshort(*)[3]) srcRowB;
+      GLshort(*dst)[3] = (GLshort(*)[3]) dstRow;
+      for (i = j = 0, k = k0; i < (GLuint) dstWidth;
+           i++, j += colStride, k += colStride) {
+         dst[i][0] = (rowA[j][0] + rowA[k][0] + rowB[j][0] + rowB[k][0]) / 4;
+         dst[i][1] = (rowA[j][1] + rowA[k][1] + rowB[j][1] + rowB[k][1]) / 4;
+         dst[i][2] = (rowA[j][2] + rowA[k][2] + rowB[j][2] + rowB[k][2]) / 4;
+      }
+   }
+   else if (datatype == GL_SHORT && comps == 2) {
+      GLuint i, j, k;
+      const GLshort(*rowA)[2] = (const GLshort(*)[2]) srcRowA;
+      const GLshort(*rowB)[2] = (const GLshort(*)[2]) srcRowB;
+      GLshort(*dst)[2] = (GLshort(*)[2]) dstRow;
+      for (i = j = 0, k = k0; i < (GLuint) dstWidth;
+           i++, j += colStride, k += colStride) {
+         dst[i][0] = (rowA[j][0] + rowA[k][0] + rowB[j][0] + rowB[k][0]) / 4;
+         dst[i][1] = (rowA[j][1] + rowA[k][1] + rowB[j][1] + rowB[k][1]) / 4;
+      }
+   }
+   else if (datatype == GL_SHORT && comps == 1) {
+      GLuint i, j, k;
+      const GLshort *rowA = (const GLshort *) srcRowA;
+      const GLshort *rowB = (const GLshort *) srcRowB;
+      GLshort *dst = (GLshort *) dstRow;
+      for (i = j = 0, k = k0; i < (GLuint) dstWidth;
+           i++, j += colStride, k += colStride) {
+         dst[i] = (rowA[j] + rowA[k] + rowB[j] + rowB[k]) / 4;
+      }
+   }
+
    else if (datatype == GL_FLOAT && comps == 4) {
       GLuint i, j, k;
       const GLfloat(*rowA)[4] = (const GLfloat(*)[4]) srcRowA;
@@ -507,6 +555,37 @@ do_row(GLenum datatype, GLuint comps, GLint srcWidth,
          dst[i] = (alpha << 15) | (blue << 10) | (green << 5) | red;
       }
    }
+   else if (datatype == GL_UNSIGNED_SHORT_5_5_5_1 && comps == 4) {
+      GLuint i, j, k;
+      const GLushort *rowA = (const GLushort *) srcRowA;
+      const GLushort *rowB = (const GLushort *) srcRowB;
+      GLushort *dst = (GLushort *) dstRow;
+      for (i = j = 0, k = k0; i < (GLuint) dstWidth;
+           i++, j += colStride, k += colStride) {
+         const GLint rowAr0 = (rowA[j] >> 11) & 0x1f;
+         const GLint rowAr1 = (rowA[k] >> 11) & 0x1f;
+         const GLint rowBr0 = (rowB[j] >> 11) & 0x1f;
+         const GLint rowBr1 = (rowB[k] >> 11) & 0x1f;
+         const GLint rowAg0 = (rowA[j] >> 6) & 0x1f;
+         const GLint rowAg1 = (rowA[k] >> 6) & 0x1f;
+         const GLint rowBg0 = (rowB[j] >> 6) & 0x1f;
+         const GLint rowBg1 = (rowB[k] >> 6) & 0x1f;
+         const GLint rowAb0 = (rowA[j] >> 1) & 0x1f;
+         const GLint rowAb1 = (rowA[k] >> 1) & 0x1f;
+         const GLint rowBb0 = (rowB[j] >> 1) & 0x1f;
+         const GLint rowBb1 = (rowB[k] >> 1) & 0x1f;
+         const GLint rowAa0 = (rowA[j] & 0x1);
+         const GLint rowAa1 = (rowA[k] & 0x1);
+         const GLint rowBa0 = (rowB[j] & 0x1);
+         const GLint rowBa1 = (rowB[k] & 0x1);
+         const GLint red = (rowAr0 + rowAr1 + rowBr0 + rowBr1) >> 2;
+         const GLint green = (rowAg0 + rowAg1 + rowBg0 + rowBg1) >> 2;
+         const GLint blue = (rowAb0 + rowAb1 + rowBb0 + rowBb1) >> 2;
+         const GLint alpha = (rowAa0 + rowAa1 + rowBa0 + rowBa1) >> 2;
+         dst[i] = (red << 11) | (green << 6) | (blue << 1) | alpha;
+      }
+   }
+
    else if (datatype == GL_UNSIGNED_BYTE_3_3_2 && comps == 3) {
       GLuint i, j, k;
       const GLubyte *rowA = (const GLubyte *) srcRowA;
@@ -606,7 +685,7 @@ do_row_3D(GLenum datatype, GLuint comps, GLint srcWidth,
          FILTER_3D(0);
       }
    }
-   if ((datatype == GL_BYTE) && (comps == 4)) {
+   else if ((datatype == GL_BYTE) && (comps == 4)) {
       DECLARE_ROW_POINTERS(GLbyte, 4);
 
       for (i = j = 0, k = k0; i < (GLuint) dstWidth;
@@ -682,6 +761,44 @@ do_row_3D(GLenum datatype, GLuint comps, GLint srcWidth,
          FILTER_3D(0);
       }
    }
+   else if ((datatype == GL_SHORT) && (comps == 4)) {
+      DECLARE_ROW_POINTERS(GLshort, 4);
+
+      for (i = j = 0, k = k0; i < (GLuint) dstWidth;
+           i++, j += colStride, k += colStride) {
+         FILTER_3D(0);
+         FILTER_3D(1);
+         FILTER_3D(2);
+         FILTER_3D(3);
+      }
+   }
+   else if ((datatype == GL_SHORT) && (comps == 3)) {
+      DECLARE_ROW_POINTERS(GLshort, 3);
+
+      for (i = j = 0, k = k0; i < (GLuint) dstWidth;
+           i++, j += colStride, k += colStride) {
+         FILTER_3D(0);
+         FILTER_3D(1);
+         FILTER_3D(2);
+      }
+   }
+   else if ((datatype == GL_SHORT) && (comps == 2)) {
+      DECLARE_ROW_POINTERS(GLshort, 2);
+
+      for (i = j = 0, k = k0; i < (GLuint) dstWidth;
+           i++, j += colStride, k += colStride) {
+         FILTER_3D(0);
+         FILTER_3D(1);
+      }
+   }
+   else if ((datatype == GL_SHORT) && (comps == 1)) {
+      DECLARE_ROW_POINTERS(GLshort, 1);
+
+      for (i = j = 0, k = k0; i < (GLuint) dstWidth;
+           i++, j += colStride, k += colStride) {
+         FILTER_3D(0);
+      }
+   }
    else if ((datatype == GL_FLOAT) && (comps == 4)) {
       DECLARE_ROW_POINTERS(GLfloat, 4);
 
@@ -910,6 +1027,55 @@ do_row_3D(GLenum datatype, GLuint comps, GLint srcWidth,
          dst[i] = (a << 15) | (b << 10) | (g << 5) | r;
       }
    }
+   else if ((datatype == GL_UNSIGNED_SHORT_5_5_5_1) && (comps == 4)) {
+      DECLARE_ROW_POINTERS0(GLushort);
+
+      for (i = j = 0, k = k0; i < (GLuint) dstWidth;
+           i++, j += colStride, k += colStride) {
+         const GLint rowAr0 = (rowA[j] >> 11) & 0x1f;
+         const GLint rowAr1 = (rowA[k] >> 11) & 0x1f;
+         const GLint rowBr0 = (rowB[j] >> 11) & 0x1f;
+         const GLint rowBr1 = (rowB[k] >> 11) & 0x1f;
+         const GLint rowCr0 = (rowC[j] >> 11) & 0x1f;
+         const GLint rowCr1 = (rowC[k] >> 11) & 0x1f;
+         const GLint rowDr0 = (rowD[j] >> 11) & 0x1f;
+         const GLint rowDr1 = (rowD[k] >> 11) & 0x1f;
+         const GLint rowAg0 = (rowA[j] >> 6) & 0x1f;
+         const GLint rowAg1 = (rowA[k] >> 6) & 0x1f;
+         const GLint rowBg0 = (rowB[j] >> 6) & 0x1f;
+         const GLint rowBg1 = (rowB[k] >> 6) & 0x1f;
+         const GLint rowCg0 = (rowC[j] >> 6) & 0x1f;
+         const GLint rowCg1 = (rowC[k] >> 6) & 0x1f;
+         const GLint rowDg0 = (rowD[j] >> 6) & 0x1f;
+         const GLint rowDg1 = (rowD[k] >> 6) & 0x1f;
+         const GLint rowAb0 = (rowA[j] >> 1) & 0x1f;
+         const GLint rowAb1 = (rowA[k] >> 1) & 0x1f;
+         const GLint rowBb0 = (rowB[j] >> 1) & 0x1f;
+         const GLint rowBb1 = (rowB[k] >> 1) & 0x1f;
+         const GLint rowCb0 = (rowC[j] >> 1) & 0x1f;
+         const GLint rowCb1 = (rowC[k] >> 1) & 0x1f;
+         const GLint rowDb0 = (rowD[j] >> 1) & 0x1f;
+         const GLint rowDb1 = (rowD[k] >> 1) & 0x1f;
+         const GLint rowAa0 = (rowA[j] & 0x1);
+         const GLint rowAa1 = (rowA[k] & 0x1);
+         const GLint rowBa0 = (rowB[j] & 0x1);
+         const GLint rowBa1 = (rowB[k] & 0x1);
+         const GLint rowCa0 = (rowC[j] & 0x1);
+         const GLint rowCa1 = (rowC[k] & 0x1);
+         const GLint rowDa0 = (rowD[j] & 0x1);
+         const GLint rowDa1 = (rowD[k] & 0x1);
+         const GLint r = FILTER_SUM_3D(rowAr0, rowAr1, rowBr0, rowBr1,
+                                       rowCr0, rowCr1, rowDr0, rowDr1);
+         const GLint g = FILTER_SUM_3D(rowAg0, rowAg1, rowBg0, rowBg1,
+                                       rowCg0, rowCg1, rowDg0, rowDg1);
+         const GLint b = FILTER_SUM_3D(rowAb0, rowAb1, rowBb0, rowBb1,
+                                       rowCb0, rowCb1, rowDb0, rowDb1);
+         const GLint a = FILTER_SUM_3D(rowAa0, rowAa1, rowBa0, rowBa1,
+                                       rowCa0, rowCa1, rowDa0, rowDa1);
+
+         dst[i] = (r << 11) | (g << 6) | (b << 1) | a;
+      }
+   }
    else if ((datatype == GL_UNSIGNED_BYTE_3_3_2) && (comps == 3)) {
       DECLARE_ROW_POINTERS0(GLushort);
 
diff --git a/src/mesa/program/prog_statevars.c b/src/mesa/program/prog_statevars.c
index 2687f8a..778447d 100644
--- a/src/mesa/program/prog_statevars.c
+++ b/src/mesa/program/prog_statevars.c
@@ -584,6 +584,24 @@ _mesa_fetch_state(GLcontext *ctx, const gl_state_index state[],
          value[3] = 0.0F;
          return;
 
+      case STATE_FB_WPOS_Y_TRANSFORM:
+         /* A driver may negate this conditional by using ZW swizzle
+          * instead of XY (based on e.g. some other state). */
+         if (ctx->DrawBuffer->Name != 0) {
+            /* Identity (XY) followed by flipping Y upside down (ZW). */
+            value[0] = 1.0F;
+            value[1] = 0.0F;
+            value[2] = -1.0F;
+            value[3] = (GLfloat) (ctx->DrawBuffer->Height - 1);
+         } else {
+            /* Flipping Y upside down (XY) followed by identity (ZW). */
+            value[0] = -1.0F;
+            value[1] = (GLfloat) (ctx->DrawBuffer->Height - 1);
+            value[2] = 1.0F;
+            value[3] = 0.0F;
+         }
+         return;
+
       case STATE_ROT_MATRIX_0:
          {
             const int unit = (int) state[2];
@@ -711,6 +729,7 @@ _mesa_program_state_flags(const gl_state_index state[STATE_LENGTH])
          return _NEW_PIXEL;
 
       case STATE_FB_SIZE:
+      case STATE_FB_WPOS_Y_TRANSFORM:
          return _NEW_BUFFERS;
 
       default:
@@ -925,6 +944,9 @@ append_token(char *dst, gl_state_index k)
    case STATE_FB_SIZE:
       append(dst, "FbSize");
       break;
+   case STATE_FB_WPOS_Y_TRANSFORM:
+      append(dst, "FbWposYTransform");
+      break;
    case STATE_ROT_MATRIX_0:
       append(dst, "rotMatrixRow0");
       break;
diff --git a/src/mesa/program/prog_statevars.h b/src/mesa/program/prog_statevars.h
index 1753471..82712c5 100644
--- a/src/mesa/program/prog_statevars.h
+++ b/src/mesa/program/prog_statevars.h
@@ -120,6 +120,7 @@ typedef enum gl_state_index_ {
    STATE_PCM_BIAS,              /**< Post color matrix RGBA bias */
    STATE_SHADOW_AMBIENT,        /**< ARB_shadow_ambient fail value; token[2] is texture unit index */
    STATE_FB_SIZE,               /**< (width-1, height-1, 0, 0) */
+   STATE_FB_WPOS_Y_TRANSFORM,   /**< (1, 0, -1, height-1) if a FBO is bound, (-1, height-1, 1, 0) otherwise */
    STATE_ROT_MATRIX_0,          /**< ATI_envmap_bumpmap, rot matrix row 0 */
    STATE_ROT_MATRIX_1,          /**< ATI_envmap_bumpmap, rot matrix row 1 */
    STATE_INTERNAL_DRIVER	/* first available state index for drivers (must be last) */
diff --git a/src/mesa/state_tracker/st_cb_bufferobjects.c b/src/mesa/state_tracker/st_cb_bufferobjects.c
index 7991a93..50b352c 100644
--- a/src/mesa/state_tracker/st_cb_bufferobjects.c
+++ b/src/mesa/state_tracker/st_cb_bufferobjects.c
@@ -211,6 +211,13 @@ st_bufferobj_data(GLcontext *ctx,
 
 
 /**
+ * Dummy data whose's pointer is used for zero size buffers or ranges.
+ */
+static long st_bufferobj_zero_length = 0;
+
+
+
+/**
  * Called via glMapBufferARB().
  */
 static void *
@@ -233,10 +240,16 @@ st_bufferobj_map(GLcontext *ctx, GLenum target, GLenum access,
       break;      
    }
 
-   obj->Pointer = pipe_buffer_map(st_context(ctx)->pipe,
-                                  st_obj->buffer,
-                                  flags,
-                                  &st_obj->transfer);
+   /* Handle zero-size buffers here rather than in drivers */
+   if (obj->Size == 0) {
+      obj->Pointer = &st_bufferobj_zero_length;
+   }
+   else {
+      obj->Pointer = pipe_buffer_map(st_context(ctx)->pipe,
+                                     st_obj->buffer,
+                                     flags,
+                                     &st_obj->transfer);
+   }
 
    if (obj->Pointer) {
       obj->Offset = 0;
@@ -247,13 +260,6 @@ st_bufferobj_map(GLcontext *ctx, GLenum target, GLenum access,
 
 
 /**
- * Dummy data whose's pointer is used for zero length ranges.
- */
-static long
-st_bufferobj_zero_length_range = 0;
-
-
-/**
  * Called via glMapBufferRange().
  */
 static void *
@@ -293,7 +299,7 @@ st_bufferobj_map_range(GLcontext *ctx, GLenum target,
     * length range from the pipe driver.
     */
    if (!length) {
-      obj->Pointer = &st_bufferobj_zero_length_range;
+      obj->Pointer = &st_bufferobj_zero_length;
    }
    else {
       obj->Pointer = pipe_buffer_map_range(pipe, 
diff --git a/src/mesa/state_tracker/st_cb_eglimage.c b/src/mesa/state_tracker/st_cb_eglimage.c
index 3145416..c54baf4 100644
--- a/src/mesa/state_tracker/st_cb_eglimage.c
+++ b/src/mesa/state_tracker/st_cb_eglimage.c
@@ -129,6 +129,7 @@ st_bind_surface(GLcontext *ctx, GLenum target,
 
    /* FIXME create a non-default sampler view from the pipe_surface? */
    pipe_resource_reference(&stObj->pt, ps->texture);
+   pipe_sampler_view_reference(&stObj->sampler_view, NULL);
    pipe_resource_reference(&stImage->pt, stObj->pt);
 
    stObj->width0 = ps->width;
diff --git a/src/mesa/state_tracker/st_manager.c b/src/mesa/state_tracker/st_manager.c
index 66e32b4..cd418a0 100644
--- a/src/mesa/state_tracker/st_manager.c
+++ b/src/mesa/state_tracker/st_manager.c
@@ -486,9 +486,18 @@ st_context_notify_invalid_framebuffer(struct st_context_iface *stctxi,
    stfb = st_ws_framebuffer(st->ctx->WinSysDrawBuffer);
    if (!stfb || stfb->iface != stfbi)
       stfb = st_ws_framebuffer(st->ctx->WinSysReadBuffer);
-   assert(stfb && stfb->iface == stfbi);
 
-   p_atomic_set(&stfb->revalidate, TRUE);
+   if (stfb && stfb->iface == stfbi) {
+      p_atomic_set(&stfb->revalidate, TRUE);
+   }
+   else {
+      /* This function is probably getting called when we've detected a
+       * change in a window's size but the currently bound context is
+       * not bound to that window.
+       * If the st_framebuffer_iface structure had a pointer to the
+       * corresponding st_framebuffer we'd be able to handle this.
+       */
+   }
 }
 
 static void
diff --git a/src/mesa/state_tracker/st_mesa_to_tgsi.c b/src/mesa/state_tracker/st_mesa_to_tgsi.c
index 0ed822b..2712717 100644
--- a/src/mesa/state_tracker/st_mesa_to_tgsi.c
+++ b/src/mesa/state_tracker/st_mesa_to_tgsi.c
@@ -760,10 +760,13 @@ emit_adjusted_wpos( struct st_translate *t,
 
 /**
  * Emit the TGSI instructions for inverting the WPOS y coordinate.
+ * This code is unavoidable because it also depends on whether
+ * a FBO is bound (STATE_FB_WPOS_Y_TRANSFORM).
  */
 static void
-emit_inverted_wpos( struct st_translate *t,
-                    const struct gl_program *program )
+emit_wpos_inversion( struct st_translate *t,
+                     const struct gl_program *program,
+                     boolean invert)
 {
    struct ureg_program *ureg = t->ureg;
 
@@ -771,17 +774,17 @@ emit_inverted_wpos( struct st_translate *t,
     * Need to replace instances of INPUT[WPOS] with temp T
     * where T = INPUT[WPOS] by y is inverted.
     */
-   static const gl_state_index winSizeState[STATE_LENGTH]
-      = { STATE_INTERNAL, STATE_FB_SIZE, 0, 0, 0 };
+   static const gl_state_index wposTransformState[STATE_LENGTH]
+      = { STATE_INTERNAL, STATE_FB_WPOS_Y_TRANSFORM, 0, 0, 0 };
    
    /* XXX: note we are modifying the incoming shader here!  Need to
     * do this before emitting the constant decls below, or this
     * will be missed:
     */
-   unsigned winHeightConst = _mesa_add_state_reference(program->Parameters,
-                                                       winSizeState);
+   unsigned wposTransConst = _mesa_add_state_reference(program->Parameters,
+                                                       wposTransformState);
 
-   struct ureg_src winsize = ureg_DECL_constant( ureg, winHeightConst );
+   struct ureg_src wpostrans = ureg_DECL_constant( ureg, wposTransConst );
    struct ureg_dst wpos_temp;
    struct ureg_src wpos_input = t->inputs[t->inputMapping[FRAG_ATTRIB_WPOS]];
 
@@ -794,12 +797,23 @@ emit_inverted_wpos( struct st_translate *t,
       ureg_MOV( ureg, wpos_temp, wpos_input );
    }
 
-   /* SUB wpos_temp.y, winsize_const, wpos_input
-    */
-   ureg_SUB( ureg,
-             ureg_writemask(wpos_temp, TGSI_WRITEMASK_Y ),
-             winsize,
-             wpos_input);
+   if (invert) {
+      /* MAD wpos_temp.y, wpos_input, wpostrans.xxxx, wpostrans.yyyy
+       */
+      ureg_MAD( ureg,
+                ureg_writemask(wpos_temp, TGSI_WRITEMASK_Y ),
+                wpos_input,
+                ureg_scalar(wpostrans, 0),
+                ureg_scalar(wpostrans, 1));
+   } else {
+      /* MAD wpos_temp.y, wpos_input, wpostrans.zzzz, wpostrans.wwww
+       */
+      ureg_MAD( ureg,
+                ureg_writemask(wpos_temp, TGSI_WRITEMASK_Y ),
+                wpos_input,
+                ureg_scalar(wpostrans, 2),
+                ureg_scalar(wpostrans, 3));
+   }
 
    /* Use wpos_temp as position input from here on:
     */
@@ -861,8 +875,7 @@ emit_wpos(struct st_context *st,
 
    /* we invert after adjustment so that we avoid the MOV to temporary,
     * and reuse the adjustment ADD instead */
-   if (invert)
-      emit_inverted_wpos(t, program);
+   emit_wpos_inversion(t, program, invert);
 }
 
 
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 8c2d8b6..63faa4a 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -216,6 +216,8 @@ st_translate_vertex_program(struct st_context *st,
       return NULL;
    }
 
+   vpv->key = *key;
+
    vpv->num_inputs = stvp->num_inputs;
    num_outputs = stvp->num_outputs;
    if (key->passthrough_edgeflags) {
diff --git a/src/mesa/swrast/s_texfilter.c b/src/mesa/swrast/s_texfilter.c
index 3fc554c..28063e0 100644
--- a/src/mesa/swrast/s_texfilter.c
+++ b/src/mesa/swrast/s_texfilter.c
@@ -1368,6 +1368,7 @@ opt_sample_rgb_2d(GLcontext *ctx,
       rgba[k][RCOMP] = UBYTE_TO_FLOAT(texel[2]);
       rgba[k][GCOMP] = UBYTE_TO_FLOAT(texel[1]);
       rgba[k][BCOMP] = UBYTE_TO_FLOAT(texel[0]);
+      rgba[k][ACOMP] = 1.0F;
    }
 }
 
@@ -2972,11 +2973,16 @@ choose_depth_texture_level(const struct gl_texture_object *tObj, GLfloat lambda)
 {
    GLint level;
 
-   lambda = CLAMP(lambda, tObj->MinLod, tObj->MaxLod);
-
-   level = (GLint) lambda;
-
-   level = CLAMP(level, tObj->BaseLevel, tObj->_MaxLevel);
+   if (tObj->MinFilter == GL_NEAREST || tObj->MinFilter == GL_LINEAR) {
+      /* no mipmapping - use base level */
+      level = tObj->BaseLevel;
+   }
+   else {
+      /* choose mipmap level */
+      lambda = CLAMP(lambda, tObj->MinLod, tObj->MaxLod);
+      level = (GLint) lambda;
+      level = CLAMP(level, tObj->BaseLevel, tObj->_MaxLevel);
+   }
 
    return level;
 }
