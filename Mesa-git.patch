diff --git a/configs/darwin b/configs/darwin
index 77edf1a..f061500 100644
--- a/configs/darwin
+++ b/configs/darwin
@@ -6,6 +6,8 @@ CONFIG_NAME = darwin
 
 INSTALL_DIR = /usr/X11
 
+X11_DIR = $(INSTALL_DIR)
+
 # Compiler and flags
 CC = gcc
 CXX = gcc
@@ -21,9 +23,9 @@ DEFINES =  -D_DARWIN_C_SOURCE -D_POSIX_SOURCE -D_POSIX_C_SOURCE=199309L \
 ARCH_FLAGS += $(RC_CFLAGS)
 
 CFLAGS =  -ggdb3 -Os -Wall -Wmissing-prototypes -std=c99 -ffast-math -fno-strict-aliasing \
-	-I$(INSTALL_DIR)/include $(OPT_FLAGS) $(PIC_FLAGS) $(ARCH_FLAGS) $(ASM_FLAGS) $(DEFINES)
+	-I$(INSTALL_DIR)/include -I$(X11_DIR)/include $(OPT_FLAGS) $(PIC_FLAGS) $(ARCH_FLAGS) $(ASM_FLAGS) $(DEFINES)
 CXXFLAGS =  -ggdb3 -Os -Wall -fno-strict-aliasing \
-	-I$(INSTALL_DIR)/include $(OPT_FLAGS) $(PIC_FLAGS) $(ARCH_FLAGS) $(ASM_FLAGS) $(DEFINES)
+	-I$(INSTALL_DIR)/include -I$(X11_DIR)/include $(OPT_FLAGS) $(PIC_FLAGS) $(ARCH_FLAGS) $(ASM_FLAGS) $(DEFINES)
 
 # Library names (actual file names)
 GL_LIB_NAME = libGL.dylib
@@ -39,12 +41,12 @@ GLUT_LIB_GLOB = libglut.*dylib
 GLW_LIB_GLOB = libGLw.*dylib
 OSMESA_LIB_GLOB = libOSMesa.*dylib
 
-GL_LIB_DEPS = -L$(INSTALL_DIR)/$(LIB_DIR) -lX11 -lXext -lm -lpthread
+GL_LIB_DEPS = -L$(INSTALL_DIR)/$(LIB_DIR) -L$(X11_DIR)/$(LIB_DIR) -lX11 -lXext -lm -lpthread
 OSMESA_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GL_LIB)
 GLU_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GL_LIB)
-GLUT_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GLU_LIB) -l$(GL_LIB)  -L$(INSTALL_DIR)/$(LIB_DIR) -lX11 -lXmu -lXi -lXext
-GLW_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GL_LIB) -L$(INSTALL_DIR)/$(LIB_DIR) -lX11 -lXt
-APP_LIB_DEPS = -L$(TOP)/lib -l$(GLUT_LIB) -l$(GLU_LIB) -l$(GL_LIB) -L$(INSTALL_DIR)/$(LIB_DIR) -lX11 -lXmu -lXt -lXi -lm
+GLUT_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GLU_LIB) -l$(GL_LIB)  -L$(INSTALL_DIR)/$(LIB_DIR) -L$(X11_DIR)/$(LIB_DIR) -lX11 -lXmu -lXi -lXext
+GLW_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GL_LIB) -L$(INSTALL_DIR)/$(LIB_DIR) -L$(X11_DIR)/$(LIB_DIR) -lX11 -lXt
+APP_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GLUT_LIB) -l$(GLU_LIB) -l$(GL_LIB) -L$(INSTALL_DIR)/$(LIB_DIR) -L$(X11_DIR)/$(LIB_DIR) -lX11 -lXmu -lXt -lXi -lm
 
 # omit glw lib for now:
 SRC_DIRS = glx/x11 mesa glu glut/glx
diff --git a/src/glx/x11/indirect.c b/src/glx/x11/indirect.c
index 08d52ae..aea117e 100644
--- a/src/glx/x11/indirect.c
+++ b/src/glx/x11/indirect.c
@@ -5198,9 +5198,13 @@ glDeleteTexturesEXT(GLsizei n, const GLuint * textures)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING
     if (gc->driContext) {
         CALL_DeleteTextures(GET_DISPATCH(), (n, textures));
     } else {
+#else
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         const GLuint cmdlen = 4 + __GLX_PAD((n * 4));
@@ -5266,9 +5270,13 @@ glGenTexturesEXT(GLsizei n, GLuint * textures)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GenTextures(GET_DISPATCH(), (n, textures));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         const GLuint cmdlen = 4;
@@ -5328,9 +5336,13 @@ glIsTextureEXT(GLuint texture)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         return CALL_IsTexture(GET_DISPATCH(), (texture));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         GLboolean retval = (GLboolean) 0;
@@ -5641,9 +5653,13 @@ glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid * table)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetColorTable(GET_DISPATCH(), (target, format, type, table));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         const __GLXattribute *const state = gc->client_state_private;
         Display *const dpy = gc->currentDpy;
@@ -5714,10 +5730,14 @@ glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat * params)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetColorTableParameterfv(GET_DISPATCH(),
                                       (target, pname, params));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         const GLuint cmdlen = 8;
@@ -5784,10 +5804,14 @@ glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint * params)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetColorTableParameteriv(GET_DISPATCH(),
                                       (target, pname, params));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         const GLuint cmdlen = 8;
@@ -6107,10 +6131,14 @@ gl_dispatch_stub_356(GLenum target, GLenum format, GLenum type,
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetConvolutionFilter(GET_DISPATCH(),
                                   (target, format, type, image));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         const __GLXattribute *const state = gc->client_state_private;
         Display *const dpy = gc->currentDpy;
@@ -6182,10 +6210,14 @@ gl_dispatch_stub_357(GLenum target, GLenum pname, GLfloat * params)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetConvolutionParameterfv(GET_DISPATCH(),
                                        (target, pname, params));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         const GLuint cmdlen = 8;
@@ -6252,10 +6284,14 @@ gl_dispatch_stub_358(GLenum target, GLenum pname, GLint * params)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetConvolutionParameteriv(GET_DISPATCH(),
                                        (target, pname, params));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         const GLuint cmdlen = 8;
@@ -6329,10 +6365,14 @@ gl_dispatch_stub_361(GLenum target, GLboolean reset, GLenum format,
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetHistogram(GET_DISPATCH(),
                           (target, reset, format, type, values));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         const __GLXattribute *const state = gc->client_state_private;
         Display *const dpy = gc->currentDpy;
@@ -6403,9 +6443,13 @@ gl_dispatch_stub_362(GLenum target, GLenum pname, GLfloat * params)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetHistogramParameterfv(GET_DISPATCH(), (target, pname, params));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         const GLuint cmdlen = 8;
@@ -6471,9 +6515,13 @@ gl_dispatch_stub_363(GLenum target, GLenum pname, GLint * params)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetHistogramParameteriv(GET_DISPATCH(), (target, pname, params));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         const GLuint cmdlen = 8;
@@ -6543,9 +6591,13 @@ gl_dispatch_stub_364(GLenum target, GLboolean reset, GLenum format,
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetMinmax(GET_DISPATCH(), (target, reset, format, type, values));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         const __GLXattribute *const state = gc->client_state_private;
         Display *const dpy = gc->currentDpy;
@@ -6614,9 +6666,13 @@ gl_dispatch_stub_365(GLenum target, GLenum pname, GLfloat * params)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetMinmaxParameterfv(GET_DISPATCH(), (target, pname, params));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         const GLuint cmdlen = 8;
@@ -6679,9 +6735,13 @@ gl_dispatch_stub_366(GLenum target, GLenum pname, GLint * params)
 {
     __GLXcontext *const gc = __glXGetCurrentContext();
 
+#ifdef GLX_DIRECT_RENDERING    
     if (gc->driContext) {
         CALL_GetMinmaxParameteriv(GET_DISPATCH(), (target, pname, params));
     } else {
+#else 
+    {
+#endif
         __GLXcontext *const gc = __glXGetCurrentContext();
         Display *const dpy = gc->currentDpy;
         const GLuint cmdlen = 8;
diff --git a/src/mesa/main/drawpix.c b/src/mesa/main/drawpix.c
index ac97bc1..cb837de 100644
--- a/src/mesa/main/drawpix.c
+++ b/src/mesa/main/drawpix.c
@@ -77,28 +77,30 @@ _mesa_DrawPixels( GLsizei width, GLsizei height,
    }
 
    if (ctx->RenderMode == GL_RENDER) {
-      /* Round, to satisfy conformance tests (matches SGI's OpenGL) */
-      GLint x = IROUND(ctx->Current.RasterPos[0]);
-      GLint y = IROUND(ctx->Current.RasterPos[1]);
-
-      if (ctx->Unpack.BufferObj->Name) {
-         /* unpack from PBO */
-         if (!_mesa_validate_pbo_access(2, &ctx->Unpack, width, height, 1,
-                                        format, type, pixels)) {
-            _mesa_error(ctx, GL_INVALID_OPERATION,
-                        "glDrawPixels(invalid PBO access)");
-            return;
+      if (width > 0 && height > 0) {
+         /* Round, to satisfy conformance tests (matches SGI's OpenGL) */
+         GLint x = IROUND(ctx->Current.RasterPos[0]);
+         GLint y = IROUND(ctx->Current.RasterPos[1]);
+
+         if (ctx->Unpack.BufferObj->Name) {
+            /* unpack from PBO */
+            if (!_mesa_validate_pbo_access(2, &ctx->Unpack, width, height, 1,
+                                           format, type, pixels)) {
+               _mesa_error(ctx, GL_INVALID_OPERATION,
+                           "glDrawPixels(invalid PBO access)");
+               return;
+            }
+            if (ctx->Unpack.BufferObj->Pointer) {
+               /* buffer is mapped - that's an error */
+               _mesa_error(ctx, GL_INVALID_OPERATION,
+                           "glDrawPixels(PBO is mapped)");
+               return;
+            }
          }
-         if (ctx->Unpack.BufferObj->Pointer) {
-            /* buffer is mapped - that's an error */
-            _mesa_error(ctx, GL_INVALID_OPERATION,
-                        "glDrawPixels(PBO is mapped)");
-            return;
-         }
-      }
 
-      ctx->Driver.DrawPixels(ctx, x, y, width, height, format, type,
-			     &ctx->Unpack, pixels);
+         ctx->Driver.DrawPixels(ctx, x, y, width, height, format, type,
+                                &ctx->Unpack, pixels);
+      }
    }
    else if (ctx->RenderMode == GL_FEEDBACK) {
       /* Feedback the current raster pos info */
@@ -159,10 +161,12 @@ _mesa_CopyPixels( GLint srcx, GLint srcy, GLsizei width, GLsizei height,
 
    if (ctx->RenderMode == GL_RENDER) {
       /* Round to satisfy conformance tests (matches SGI's OpenGL) */
-      GLint destx = IROUND(ctx->Current.RasterPos[0]);
-      GLint desty = IROUND(ctx->Current.RasterPos[1]);
-      ctx->Driver.CopyPixels( ctx, srcx, srcy, width, height, destx, desty,
-			      type );
+      if (width > 0 && height > 0) {
+         GLint destx = IROUND(ctx->Current.RasterPos[0]);
+         GLint desty = IROUND(ctx->Current.RasterPos[1]);
+         ctx->Driver.CopyPixels( ctx, srcx, srcy, width, height, destx, desty,
+                                 type );
+      }
    }
    else if (ctx->RenderMode == GL_FEEDBACK) {
       FLUSH_CURRENT( ctx, 0 );
diff --git a/src/mesa/main/ffvertex_prog.c b/src/mesa/main/ffvertex_prog.c
index cc1b44d..4321b4c 100644
--- a/src/mesa/main/ffvertex_prog.c
+++ b/src/mesa/main/ffvertex_prog.c
@@ -1104,6 +1104,9 @@ static void build_lighting( struct tnl_program *p )
 
    if (twoside) {
       if (!p->state->material_shininess_is_zero) {
+         /* Note that we negate the back-face specular exponent here.
+          * The negation will be un-done later in the back-face code below.
+          */
          struct ureg shininess = get_material(p, 1, STATE_SHININESS);
          emit_op1(p, OPCODE_MOV, dots, WRITEMASK_Z, 
                   negate(swizzle1(shininess,X)));
@@ -1309,6 +1312,11 @@ static void build_lighting( struct tnl_program *p )
 	       mask1 = 0;
 	    }
 
+            /* For the back face we need to negate the X and Y component
+             * dot products.  dots.Z has the negated back-face specular
+             * exponent.  We swizzle that into the W position.  This
+             * negation makes the back-face specular term positive again.
+             */
             dots = negate(swizzle(dots,X,Y,W,Z));
 
 	    if (!is_undef(att)) {
@@ -1327,8 +1335,10 @@ static void build_lighting( struct tnl_program *p )
 
 	    emit_op3(p, OPCODE_MAD, res0, mask0, swizzle1(lit,Y), diffuse, _bfc0);
 	    emit_op3(p, OPCODE_MAD, res1, mask1, swizzle1(lit,Z), specular, _bfc1);
-            /* restore negate flag for next lighting */
-            dots = negate(dots);
+            /* restore dots to its original state for subsequent lights
+             * by negating and swizzling again.
+             */
+            dots = negate(swizzle(dots,X,Y,W,Z));
 
 	    release_temp(p, ambient);
 	    release_temp(p, diffuse);
diff --git a/src/mesa/main/glheader.h b/src/mesa/main/glheader.h
index 626806d..d17be37 100644
--- a/src/mesa/main/glheader.h
+++ b/src/mesa/main/glheader.h
@@ -145,7 +145,10 @@
 #if defined(__linux__)
 #include <byteswap.h>
 #define CPU_TO_LE32( x )	bswap_32( x )
-#else /*__linux__*/
+#elif defined(__APPLE__)
+#include <CoreFoundation/CFByteOrder.h>
+#define CPU_TO_LE32( x )	CFSwapInt32HostToLittle( x )
+#else /*__linux__ __APPLE__*/
 #include <sys/endian.h>
 #define CPU_TO_LE32( x )	bswap32( x )
 #endif /*__linux__*/
diff --git a/src/mesa/main/light.c b/src/mesa/main/light.c
index ce50224..4372f7b 100644
--- a/src/mesa/main/light.c
+++ b/src/mesa/main/light.c
@@ -209,7 +209,6 @@ _mesa_Lightfv( GLenum light, GLenum pname, const GLfloat *params )
 	 _math_matrix_analyse(ctx->ModelviewMatrixStack.Top);
       }
       TRANSFORM_DIRECTION(temp, params, ctx->ModelviewMatrixStack.Top->m);
-      NORMALIZE_3FV(temp);
       params = temp;
       break;
    case GL_SPOT_EXPONENT:
@@ -1137,12 +1136,18 @@ compute_light_positions( GLcontext *ctx )
       }
 
       if (light->_Flags & LIGHT_SPOT) {
+         /* Note: we normalize the spot direction now */
+
 	 if (ctx->_NeedEyeCoords) {
 	    COPY_3V( light->_NormDirection, light->EyeDirection );
+            NORMALIZE_3FV( light->_NormDirection );
 	 }
          else {
+            GLfloat spotDir[3];
+            COPY_3V(spotDir, light->EyeDirection);
+            NORMALIZE_3FV(spotDir);
 	    TRANSFORM_NORMAL( light->_NormDirection,
-			      light->EyeDirection,
+			      spotDir,
 			      ctx->ModelviewMatrixStack.Top->m);
 	 }
 
diff --git a/src/mesa/main/readpix.c b/src/mesa/main/readpix.c
index dfdd297..2326776 100644
--- a/src/mesa/main/readpix.c
+++ b/src/mesa/main/readpix.c
@@ -170,6 +170,9 @@ _mesa_ReadPixels( GLint x, GLint y, GLsizei width, GLsizei height,
       return;
    }
 
+   if (width == 0 || height == 0)
+      return; /* nothing to do */
+
    if (ctx->Pack.BufferObj->Name) {
       if (!_mesa_validate_pbo_access(2, &ctx->Pack, width, height, 1,
                                      format, type, pixels)) {
diff --git a/src/mesa/main/texparam.c b/src/mesa/main/texparam.c
index be4fc1d..e89bc5f 100644
--- a/src/mesa/main/texparam.c
+++ b/src/mesa/main/texparam.c
@@ -139,8 +139,11 @@ flush(GLcontext *ctx, struct gl_texture_object *texObj)
 }
 
 
-/** Set an integer-valued texture parameter */
-static void
+/**
+ * Set an integer-valued texture parameter
+ * \return GL_TRUE if legal AND the value changed, GL_FALSE otherwise
+ */
+static GLboolean
 set_tex_parameteri(GLcontext *ctx,
                    struct gl_texture_object *texObj,
                    GLenum pname, const GLint *params)
@@ -148,13 +151,13 @@ set_tex_parameteri(GLcontext *ctx,
    switch (pname) {
    case GL_TEXTURE_MIN_FILTER:
       if (texObj->MinFilter == params[0])
-         return;
+         return GL_FALSE;
       switch (params[0]) {
       case GL_NEAREST:
       case GL_LINEAR:
          flush(ctx, texObj);
          texObj->MinFilter = params[0];
-         return;
+         return GL_TRUE;
       case GL_NEAREST_MIPMAP_NEAREST:
       case GL_LINEAR_MIPMAP_NEAREST:
       case GL_NEAREST_MIPMAP_LINEAR:
@@ -162,77 +165,80 @@ set_tex_parameteri(GLcontext *ctx,
          if (texObj->Target != GL_TEXTURE_RECTANGLE_NV) {
             flush(ctx, texObj);
             texObj->MinFilter = params[0];
-            return;
+            return GL_TRUE;
          }
          /* fall-through */
       default:
          _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_MAG_FILTER:
       if (texObj->MagFilter == params[0])
-         return;
+         return GL_FALSE;
       switch (params[0]) {
       case GL_NEAREST:
       case GL_LINEAR:
          flush(ctx, texObj);
          texObj->MagFilter = params[0];
-         return;
+         return GL_TRUE;
       default:
          _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_WRAP_S:
       if (texObj->WrapS == params[0])
-         return;
+         return GL_FALSE;
       if (validate_texture_wrap_mode(ctx, texObj->Target, params[0])) {
          flush(ctx, texObj);
          texObj->WrapS = params[0];
+         return GL_TRUE;
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_WRAP_T:
       if (texObj->WrapT == params[0])
-         return;
+         return GL_FALSE;
       if (validate_texture_wrap_mode(ctx, texObj->Target, params[0])) {
          flush(ctx, texObj);
          texObj->WrapT = params[0];
+         return GL_TRUE;
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_WRAP_R:
       if (texObj->WrapR == params[0])
-         return;
+         return GL_FALSE;
       if (validate_texture_wrap_mode(ctx, texObj->Target, params[0])) {
          flush(ctx, texObj);
          texObj->WrapR = params[0];
+         return GL_TRUE;
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_BASE_LEVEL:
       if (texObj->BaseLevel == params[0])
-         return;
+         return GL_FALSE;
       if (params[0] < 0 ||
           (texObj->Target == GL_TEXTURE_RECTANGLE_ARB && params[0] != 0)) {
          _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)");
-         return;
+         return GL_FALSE;
       }
       flush(ctx, texObj);
       texObj->BaseLevel = params[0];
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_MAX_LEVEL:
       if (texObj->MaxLevel == params[0])
-         return;
+         return GL_FALSE;
       if (params[0] < 0 || texObj->Target == GL_TEXTURE_RECTANGLE_ARB) {
          _mesa_error(ctx, GL_INVALID_OPERATION, "glTexParameter(param)");
-         return;
+         return GL_FALSE;
       }
       flush(ctx, texObj);
       texObj->MaxLevel = params[0];
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_COMPARE_SGIX:
       if (ctx->Extensions.SGIX_shadow) {
@@ -243,7 +249,7 @@ set_tex_parameteri(GLcontext *ctx,
          _mesa_error(ctx, GL_INVALID_ENUM,
                      "glTexParameter(pname=GL_TEXTURE_COMPARE_SGIX)");
       }
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
       if (ctx->Extensions.SGIX_shadow &&
@@ -256,20 +262,22 @@ set_tex_parameteri(GLcontext *ctx,
          _mesa_error(ctx, GL_INVALID_ENUM,
                      "glTexParameter(GL_TEXTURE_COMPARE_OPERATOR_SGIX)");
       }
-      return;
+      return GL_TRUE;
 
    case GL_GENERATE_MIPMAP_SGIS:
       if (ctx->Extensions.SGIS_generate_mipmap) {
          if (texObj->GenerateMipmap != params[0]) {
             flush(ctx, texObj);
             texObj->GenerateMipmap = params[0] ? GL_TRUE : GL_FALSE;
+            return GL_TRUE;
          }
+         return GL_FALSE;
       }
       else {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      "glTexParameter(pname=GL_GENERATE_MIPMAP_SGIS)");
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_COMPARE_MODE_ARB:
       if (ctx->Extensions.ARB_shadow &&
@@ -278,24 +286,26 @@ set_tex_parameteri(GLcontext *ctx,
          if (texObj->CompareMode != params[0]) {
             flush(ctx, texObj);
             texObj->CompareMode = params[0];
+            return GL_TRUE;
          }
+         return GL_FALSE;
       }
       else {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      "glTexParameter(GL_TEXTURE_COMPARE_MODE_ARB)");
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_COMPARE_FUNC_ARB:
       if (ctx->Extensions.ARB_shadow) {
          if (texObj->CompareFunc == params[0])
-            return;
+            return GL_FALSE;
          switch (params[0]) {
          case GL_LEQUAL:
          case GL_GEQUAL:
             flush(ctx, texObj);
             texObj->CompareFunc = params[0];
-            return;
+            return GL_TRUE;
          case GL_EQUAL:
          case GL_NOTEQUAL:
          case GL_LESS:
@@ -305,7 +315,7 @@ set_tex_parameteri(GLcontext *ctx,
             if (ctx->Extensions.EXT_shadow_funcs) {
                flush(ctx, texObj);
                texObj->CompareFunc = params[0];
-               return;
+               return GL_TRUE;
             }
             /* fall-through */
          default:
@@ -316,7 +326,7 @@ set_tex_parameteri(GLcontext *ctx,
       else {
          _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(param)");
       }
-      return;
+      return GL_FALSE;
 
    case GL_DEPTH_TEXTURE_MODE_ARB:
       if (ctx->Extensions.ARB_depth_texture &&
@@ -326,13 +336,14 @@ set_tex_parameteri(GLcontext *ctx,
          if (texObj->DepthMode != params[0]) {
             flush(ctx, texObj);
             texObj->DepthMode = params[0];
+            return GL_TRUE;
          }
       }
       else {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      "glTexParameter(GL_DEPTH_TEXTURE_MODE_ARB)");
       }
-      return;
+      return GL_FALSE;
 
 #ifdef FEATURE_OES_draw_texture
    case GL_TEXTURE_CROP_RECT_OES:
@@ -340,17 +351,21 @@ set_tex_parameteri(GLcontext *ctx,
       texObj->CropRect[1] = params[1];
       texObj->CropRect[2] = params[2];
       texObj->CropRect[3] = params[3];
-      break;
+      return GL_TRUE;
 #endif
 
    default:
       _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
    }
+   return GL_FALSE;
 }
 
 
-/** Set a float-valued texture parameter */
-static void
+/**
+ * Set a float-valued texture parameter
+ * \return GL_TRUE if legal AND the value changed, GL_FALSE otherwise
+ */
+static GLboolean
 set_tex_parameterf(GLcontext *ctx,
                    struct gl_texture_object *texObj,
                    GLenum pname, const GLfloat *params)
@@ -358,54 +373,56 @@ set_tex_parameterf(GLcontext *ctx,
    switch (pname) {
    case GL_TEXTURE_MIN_LOD:
       if (texObj->MinLod == params[0])
-         return;
+         return GL_FALSE;
       flush(ctx, texObj);
       texObj->MinLod = params[0];
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_MAX_LOD:
       if (texObj->MaxLod == params[0])
-         return;
+         return GL_FALSE;
       flush(ctx, texObj);
       texObj->MaxLod = params[0];
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_PRIORITY:
       flush(ctx, texObj);
       texObj->Priority = CLAMP(params[0], 0.0F, 1.0F);
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_MAX_ANISOTROPY_EXT:
       if (ctx->Extensions.EXT_texture_filter_anisotropic) {
          if (texObj->MaxAnisotropy == params[0])
-            return;
+            return GL_FALSE;
          if (params[0] < 1.0) {
             _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
-            return;
+            return GL_FALSE;
          }
          flush(ctx, texObj);
          /* clamp to max, that's what NVIDIA does */
          texObj->MaxAnisotropy = MIN2(params[0],
                                       ctx->Const.MaxTextureMaxAnisotropy);
+         return GL_TRUE;
       }
       else {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      "glTexParameter(pname=GL_TEXTURE_MAX_ANISOTROPY_EXT)");
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
       if (ctx->Extensions.SGIX_shadow_ambient) {
          if (texObj->ShadowAmbient != params[0]) {
             flush(ctx, texObj);
             texObj->ShadowAmbient = CLAMP(params[0], 0.0F, 1.0F);
+            return GL_TRUE;
          }
       }
       else {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      "glTexParameter(pname=GL_SHADOW_AMBIENT_SGIX)");
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_LOD_BIAS:
       /* NOTE: this is really part of OpenGL 1.4, not EXT_texture_lod_bias */
@@ -413,7 +430,9 @@ set_tex_parameterf(GLcontext *ctx,
          if (texObj->LodBias != params[0]) {
             flush(ctx, texObj);
             texObj->LodBias = params[0];
+            return GL_TRUE;
          }
+         return GL_FALSE;
       }
       break;
 
@@ -427,17 +446,19 @@ set_tex_parameterf(GLcontext *ctx,
       UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[GCOMP], params[1]);
       UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[BCOMP], params[2]);
       UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[ACOMP], params[3]);
-      return;
+      return GL_TRUE;
 
    default:
       _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(pname=0x%x)", pname);
    }
+   return GL_FALSE;
 }
 
 
 void GLAPIENTRY
 _mesa_TexParameterf(GLenum target, GLenum pname, GLfloat param)
 {
+   GLboolean need_update;
    struct gl_texture_object *texObj;
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END(ctx);
@@ -463,15 +484,15 @@ _mesa_TexParameterf(GLenum target, GLenum pname, GLfloat param)
       {
          /* convert float param to int */
          GLint p = (GLint) param;
-         set_tex_parameteri(ctx, texObj, pname, &p);
+         need_update = set_tex_parameteri(ctx, texObj, pname, &p);
       }
-      return;
+      break;
    default:
       /* this will generate an error if pname is illegal */
-      set_tex_parameterf(ctx, texObj, pname, &param);
+      need_update = set_tex_parameterf(ctx, texObj, pname, &param);
    }
 
-   if (ctx->Driver.TexParameter && ctx->ErrorValue == GL_NO_ERROR) {
+   if (ctx->Driver.TexParameter && need_update) {
       ctx->Driver.TexParameter(ctx, target, texObj, pname, &param);
    }
 }
@@ -480,6 +501,7 @@ _mesa_TexParameterf(GLenum target, GLenum pname, GLfloat param)
 void GLAPIENTRY
 _mesa_TexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
 {
+   GLboolean need_update;
    struct gl_texture_object *texObj;
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END(ctx);
@@ -505,7 +527,7 @@ _mesa_TexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
       {
          /* convert float param to int */
          GLint p = (GLint) params[0];
-         set_tex_parameteri(ctx, texObj, pname, &p);
+         need_update = set_tex_parameteri(ctx, texObj, pname, &p);
       }
       break;
 
@@ -518,17 +540,17 @@ _mesa_TexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
          iparams[1] = (GLint) params[1];
          iparams[2] = (GLint) params[2];
          iparams[3] = (GLint) params[3];
-         set_tex_parameteri(ctx, target, iparams);
+         need_update = set_tex_parameteri(ctx, target, iparams);
       }
       break;
 #endif
 
    default:
       /* this will generate an error if pname is illegal */
-      set_tex_parameterf(ctx, texObj, pname, params);
+      need_update = set_tex_parameterf(ctx, texObj, pname, params);
    }
 
-   if (ctx->Driver.TexParameter && ctx->ErrorValue == GL_NO_ERROR) {
+   if (ctx->Driver.TexParameter && need_update) {
       ctx->Driver.TexParameter(ctx, target, texObj, pname, params);
    }
 }
@@ -537,6 +559,7 @@ _mesa_TexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
 void GLAPIENTRY
 _mesa_TexParameteri(GLenum target, GLenum pname, GLint param)
 {
+   GLboolean need_update;
    struct gl_texture_object *texObj;
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END(ctx);
@@ -555,15 +578,15 @@ _mesa_TexParameteri(GLenum target, GLenum pname, GLint param)
       {
          GLfloat fparam = (GLfloat) param;
          /* convert int param to float */
-         set_tex_parameterf(ctx, texObj, pname, &fparam);
+         need_update = set_tex_parameterf(ctx, texObj, pname, &fparam);
       }
       break;
    default:
       /* this will generate an error if pname is illegal */
-      set_tex_parameteri(ctx, texObj, pname, &param);
+      need_update = set_tex_parameteri(ctx, texObj, pname, &param);
    }
 
-   if (ctx->Driver.TexParameter && ctx->ErrorValue == GL_NO_ERROR) {
+   if (ctx->Driver.TexParameter && need_update) {
       GLfloat fparam = (GLfloat) param;
       ctx->Driver.TexParameter(ctx, target, texObj, pname, &fparam);
    }
@@ -573,6 +596,7 @@ _mesa_TexParameteri(GLenum target, GLenum pname, GLint param)
 void GLAPIENTRY
 _mesa_TexParameteriv(GLenum target, GLenum pname, const GLint *params)
 {
+   GLboolean need_update;
    struct gl_texture_object *texObj;
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END(ctx);
@@ -590,7 +614,7 @@ _mesa_TexParameteriv(GLenum target, GLenum pname, const GLint *params)
          fparams[1] = INT_TO_FLOAT(params[1]);
          fparams[2] = INT_TO_FLOAT(params[2]);
          fparams[3] = INT_TO_FLOAT(params[3]);
-         set_tex_parameterf(ctx, texObj, pname, fparams);
+         need_update = set_tex_parameterf(ctx, texObj, pname, fparams);
       }
       break;
    case GL_TEXTURE_MIN_LOD:
@@ -602,15 +626,15 @@ _mesa_TexParameteriv(GLenum target, GLenum pname, const GLint *params)
       {
          /* convert int param to float */
          GLfloat fparam = (GLfloat) params[0];
-         set_tex_parameterf(ctx, texObj, pname, &fparam);
+         need_update = set_tex_parameterf(ctx, texObj, pname, &fparam);
       }
       break;
    default:
       /* this will generate an error if pname is illegal */
-      set_tex_parameteri(ctx, texObj, pname, params);
+      need_update = set_tex_parameteri(ctx, texObj, pname, params);
    }
 
-   if (ctx->Driver.TexParameter && ctx->ErrorValue == GL_NO_ERROR) {
+   if (ctx->Driver.TexParameter && need_update) {
       GLfloat fparams[4];
       fparams[0] = INT_TO_FLOAT(params[0]);
       if (pname == GL_TEXTURE_BORDER_COLOR ||
diff --git a/src/mesa/shader/prog_execute.c b/src/mesa/shader/prog_execute.c
index a93733c..6a79cf4 100644
--- a/src/mesa/shader/prog_execute.c
+++ b/src/mesa/shader/prog_execute.c
@@ -1577,8 +1577,8 @@ _mesa_execute_program(GLcontext * ctx,
       case OPCODE_TXB:         /* GL_ARB_fragment_program only */
          /* Texel lookup with LOD bias */
          {
-            const struct gl_texture_unit *texUnit
-               = &ctx->Texture.Unit[inst->TexSrcUnit];
+            const GLuint unit = machine->Samplers[inst->TexSrcUnit];
+            const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
             GLfloat texcoord[4], color[4], lodBias;
 
             fetch_vector4(&inst->SrcReg[0], machine, texcoord);
diff --git a/src/mesa/shader/slang/slang_builtin.c b/src/mesa/shader/slang/slang_builtin.c
index c0f4c79..5a67394 100644
--- a/src/mesa/shader/slang/slang_builtin.c
+++ b/src/mesa/shader/slang/slang_builtin.c
@@ -457,28 +457,36 @@ emit_statevars(const char *name, int array_len,
          tokens[0] = STATE_TEXENV_COLOR;
       }
       else if (strcmp(name, "gl_EyePlaneS") == 0) {
-         tokens[0] = STATE_TEXGEN_EYE_S;
+         tokens[0] = STATE_TEXGEN;
+         tokens[2] = STATE_TEXGEN_EYE_S;
       }
       else if (strcmp(name, "gl_EyePlaneT") == 0) {
-         tokens[0] = STATE_TEXGEN_EYE_T;
+         tokens[0] = STATE_TEXGEN;
+         tokens[2] = STATE_TEXGEN_EYE_T;
       }
       else if (strcmp(name, "gl_EyePlaneR") == 0) {
-         tokens[0] = STATE_TEXGEN_EYE_R;
+         tokens[0] = STATE_TEXGEN;
+         tokens[2] = STATE_TEXGEN_EYE_R;
       }
       else if (strcmp(name, "gl_EyePlaneQ") == 0) {
-         tokens[0] = STATE_TEXGEN_EYE_Q;
+         tokens[0] = STATE_TEXGEN;
+         tokens[2] = STATE_TEXGEN_EYE_Q;
       }
       else if (strcmp(name, "gl_ObjectPlaneS") == 0) {
-         tokens[0] = STATE_TEXGEN_OBJECT_S;
+         tokens[0] = STATE_TEXGEN;
+         tokens[2] = STATE_TEXGEN_OBJECT_S;
       }
       else if (strcmp(name, "gl_ObjectPlaneT") == 0) {
-         tokens[0] = STATE_TEXGEN_OBJECT_T;
+         tokens[0] = STATE_TEXGEN;
+         tokens[2] = STATE_TEXGEN_OBJECT_T;
       }
       else if (strcmp(name, "gl_ObjectPlaneR") == 0) {
-         tokens[0] = STATE_TEXGEN_OBJECT_R;
+         tokens[0] = STATE_TEXGEN;
+         tokens[2] = STATE_TEXGEN_OBJECT_R;
       }
       else if (strcmp(name, "gl_ObjectPlaneQ") == 0) {
-         tokens[0] = STATE_TEXGEN_OBJECT_Q;
+         tokens[0] = STATE_TEXGEN;
+         tokens[2] = STATE_TEXGEN_OBJECT_Q;
       }
       else {
          return -1; /* invalid array name */
diff --git a/src/mesa/swrast/s_span.c b/src/mesa/swrast/s_span.c
index e36c1a4..f07014f 100644
--- a/src/mesa/swrast/s_span.c
+++ b/src/mesa/swrast/s_span.c
@@ -1399,11 +1399,17 @@ _swrast_write_rgba_span( GLcontext *ctx, SWspan *span)
    }
 
    /*
-    * Write to renderbuffers
+    * Write to renderbuffers.
+    * Depending on glDrawBuffer() state and the which color outputs are
+    * written by the fragment shader, we may either replicate one color to
+    * all renderbuffers or write a different color to each renderbuffer.
+    * multiFragOutputs=TRUE for the later case.
     */
    {
       const GLuint numBuffers = fb->_NumColorDrawBuffers;
-      const GLboolean multiFragOutputs = numBuffers > 1;
+      const struct gl_fragment_program *fp = ctx->FragmentProgram._Current;
+      const GLboolean multiFragOutputs = 
+         (fp && fp->Base.OutputsWritten >= (1 << FRAG_RESULT_DATA0));
       GLuint buf;
 
       for (buf = 0; buf < numBuffers; buf++) {
